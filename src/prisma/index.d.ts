
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model access_type
 * 
 */
export type access_type = $Result.DefaultSelection<Prisma.$access_typePayload>
/**
 * Model branch
 * 
 */
export type branch = $Result.DefaultSelection<Prisma.$branchPayload>
/**
 * Model cart
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type cart = $Result.DefaultSelection<Prisma.$cartPayload>
/**
 * Model category
 * 
 */
export type category = $Result.DefaultSelection<Prisma.$categoryPayload>
/**
 * Model customer
 * 
 */
export type customer = $Result.DefaultSelection<Prisma.$customerPayload>
/**
 * Model discount
 * 
 */
export type discount = $Result.DefaultSelection<Prisma.$discountPayload>
/**
 * Model employee
 * 
 */
export type employee = $Result.DefaultSelection<Prisma.$employeePayload>
/**
 * Model inventory
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type inventory = $Result.DefaultSelection<Prisma.$inventoryPayload>
/**
 * Model payment_method
 * 
 */
export type payment_method = $Result.DefaultSelection<Prisma.$payment_methodPayload>
/**
 * Model product
 * 
 */
export type product = $Result.DefaultSelection<Prisma.$productPayload>
/**
 * Model sales_history
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type sales_history = $Result.DefaultSelection<Prisma.$sales_historyPayload>
/**
 * Model supplier
 * 
 */
export type supplier = $Result.DefaultSelection<Prisma.$supplierPayload>
/**
 * Model user_credentials
 * 
 */
export type user_credentials = $Result.DefaultSelection<Prisma.$user_credentialsPayload>
/**
 * Model user_role
 * 
 */
export type user_role = $Result.DefaultSelection<Prisma.$user_rolePayload>
/**
 * Model variable_options
 * 
 */
export type variable_options = $Result.DefaultSelection<Prisma.$variable_optionsPayload>
/**
 * Model working_hour
 * 
 */
export type working_hour = $Result.DefaultSelection<Prisma.$working_hourPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Access_types
 * const access_types = await prisma.access_type.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Access_types
   * const access_types = await prisma.access_type.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.access_type`: Exposes CRUD operations for the **access_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Access_types
    * const access_types = await prisma.access_type.findMany()
    * ```
    */
  get access_type(): Prisma.access_typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.branchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): Prisma.cartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.customerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discount`: Exposes CRUD operations for the **discount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Discounts
    * const discounts = await prisma.discount.findMany()
    * ```
    */
  get discount(): Prisma.discountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.employeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.inventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_method`: Exposes CRUD operations for the **payment_method** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_methods
    * const payment_methods = await prisma.payment_method.findMany()
    * ```
    */
  get payment_method(): Prisma.payment_methodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.productDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sales_history`: Exposes CRUD operations for the **sales_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales_histories
    * const sales_histories = await prisma.sales_history.findMany()
    * ```
    */
  get sales_history(): Prisma.sales_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.supplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_credentials`: Exposes CRUD operations for the **user_credentials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_credentials
    * const user_credentials = await prisma.user_credentials.findMany()
    * ```
    */
  get user_credentials(): Prisma.user_credentialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_role`: Exposes CRUD operations for the **user_role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_roles
    * const user_roles = await prisma.user_role.findMany()
    * ```
    */
  get user_role(): Prisma.user_roleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.variable_options`: Exposes CRUD operations for the **variable_options** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Variable_options
    * const variable_options = await prisma.variable_options.findMany()
    * ```
    */
  get variable_options(): Prisma.variable_optionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.working_hour`: Exposes CRUD operations for the **working_hour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Working_hours
    * const working_hours = await prisma.working_hour.findMany()
    * ```
    */
  get working_hour(): Prisma.working_hourDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    access_type: 'access_type',
    branch: 'branch',
    cart: 'cart',
    category: 'category',
    customer: 'customer',
    discount: 'discount',
    employee: 'employee',
    inventory: 'inventory',
    payment_method: 'payment_method',
    product: 'product',
    sales_history: 'sales_history',
    supplier: 'supplier',
    user_credentials: 'user_credentials',
    user_role: 'user_role',
    variable_options: 'variable_options',
    working_hour: 'working_hour'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "access_type" | "branch" | "cart" | "category" | "customer" | "discount" | "employee" | "inventory" | "payment_method" | "product" | "sales_history" | "supplier" | "user_credentials" | "user_role" | "variable_options" | "working_hour"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      access_type: {
        payload: Prisma.$access_typePayload<ExtArgs>
        fields: Prisma.access_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.access_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.access_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_typePayload>
          }
          findFirst: {
            args: Prisma.access_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.access_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_typePayload>
          }
          findMany: {
            args: Prisma.access_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_typePayload>[]
          }
          create: {
            args: Prisma.access_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_typePayload>
          }
          createMany: {
            args: Prisma.access_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.access_typeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_typePayload>[]
          }
          delete: {
            args: Prisma.access_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_typePayload>
          }
          update: {
            args: Prisma.access_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_typePayload>
          }
          deleteMany: {
            args: Prisma.access_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.access_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.access_typeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_typePayload>[]
          }
          upsert: {
            args: Prisma.access_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$access_typePayload>
          }
          aggregate: {
            args: Prisma.Access_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccess_type>
          }
          groupBy: {
            args: Prisma.access_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Access_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.access_typeCountArgs<ExtArgs>
            result: $Utils.Optional<Access_typeCountAggregateOutputType> | number
          }
        }
      }
      branch: {
        payload: Prisma.$branchPayload<ExtArgs>
        fields: Prisma.branchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.branchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.branchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchPayload>
          }
          findFirst: {
            args: Prisma.branchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.branchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchPayload>
          }
          findMany: {
            args: Prisma.branchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchPayload>[]
          }
          create: {
            args: Prisma.branchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchPayload>
          }
          createMany: {
            args: Prisma.branchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.branchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchPayload>[]
          }
          delete: {
            args: Prisma.branchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchPayload>
          }
          update: {
            args: Prisma.branchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchPayload>
          }
          deleteMany: {
            args: Prisma.branchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.branchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.branchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchPayload>[]
          }
          upsert: {
            args: Prisma.branchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.branchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.branchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      cart: {
        payload: Prisma.$cartPayload<ExtArgs>
        fields: Prisma.cartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          findFirst: {
            args: Prisma.cartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          findMany: {
            args: Prisma.cartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartPayload>[]
          }
          create: {
            args: Prisma.cartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          createMany: {
            args: Prisma.cartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartPayload>[]
          }
          delete: {
            args: Prisma.cartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          update: {
            args: Prisma.cartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          deleteMany: {
            args: Prisma.cartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartPayload>[]
          }
          upsert: {
            args: Prisma.cartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCart>
          }
          groupBy: {
            args: Prisma.cartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartGroupByOutputType>[]
          }
          count: {
            args: Prisma.cartCountArgs<ExtArgs>
            result: $Utils.Optional<CartCountAggregateOutputType> | number
          }
        }
      }
      category: {
        payload: Prisma.$categoryPayload<ExtArgs>
        fields: Prisma.categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findFirst: {
            args: Prisma.categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findMany: {
            args: Prisma.categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          create: {
            args: Prisma.categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          createMany: {
            args: Prisma.categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          delete: {
            args: Prisma.categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          update: {
            args: Prisma.categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          deleteMany: {
            args: Prisma.categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.categoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          upsert: {
            args: Prisma.categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      customer: {
        payload: Prisma.$customerPayload<ExtArgs>
        fields: Prisma.customerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findFirst: {
            args: Prisma.customerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findMany: {
            args: Prisma.customerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          create: {
            args: Prisma.customerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          createMany: {
            args: Prisma.customerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.customerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          delete: {
            args: Prisma.customerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          update: {
            args: Prisma.customerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          deleteMany: {
            args: Prisma.customerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.customerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          upsert: {
            args: Prisma.customerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.customerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.customerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      discount: {
        payload: Prisma.$discountPayload<ExtArgs>
        fields: Prisma.discountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.discountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.discountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discountPayload>
          }
          findFirst: {
            args: Prisma.discountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.discountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discountPayload>
          }
          findMany: {
            args: Prisma.discountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discountPayload>[]
          }
          create: {
            args: Prisma.discountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discountPayload>
          }
          createMany: {
            args: Prisma.discountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.discountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discountPayload>[]
          }
          delete: {
            args: Prisma.discountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discountPayload>
          }
          update: {
            args: Prisma.discountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discountPayload>
          }
          deleteMany: {
            args: Prisma.discountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.discountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.discountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discountPayload>[]
          }
          upsert: {
            args: Prisma.discountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discountPayload>
          }
          aggregate: {
            args: Prisma.DiscountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscount>
          }
          groupBy: {
            args: Prisma.discountGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscountGroupByOutputType>[]
          }
          count: {
            args: Prisma.discountCountArgs<ExtArgs>
            result: $Utils.Optional<DiscountCountAggregateOutputType> | number
          }
        }
      }
      employee: {
        payload: Prisma.$employeePayload<ExtArgs>
        fields: Prisma.employeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          findFirst: {
            args: Prisma.employeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          findMany: {
            args: Prisma.employeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>[]
          }
          create: {
            args: Prisma.employeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          createMany: {
            args: Prisma.employeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.employeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>[]
          }
          delete: {
            args: Prisma.employeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          update: {
            args: Prisma.employeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          deleteMany: {
            args: Prisma.employeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.employeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>[]
          }
          upsert: {
            args: Prisma.employeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.employeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.employeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      inventory: {
        payload: Prisma.$inventoryPayload<ExtArgs>
        fields: Prisma.inventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          findFirst: {
            args: Prisma.inventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          findMany: {
            args: Prisma.inventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>[]
          }
          create: {
            args: Prisma.inventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          createMany: {
            args: Prisma.inventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.inventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>[]
          }
          delete: {
            args: Prisma.inventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          update: {
            args: Prisma.inventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          deleteMany: {
            args: Prisma.inventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.inventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.inventoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>[]
          }
          upsert: {
            args: Prisma.inventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.inventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.inventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      payment_method: {
        payload: Prisma.$payment_methodPayload<ExtArgs>
        fields: Prisma.payment_methodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_methodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_methodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          findFirst: {
            args: Prisma.payment_methodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_methodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          findMany: {
            args: Prisma.payment_methodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>[]
          }
          create: {
            args: Prisma.payment_methodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          createMany: {
            args: Prisma.payment_methodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payment_methodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>[]
          }
          delete: {
            args: Prisma.payment_methodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          update: {
            args: Prisma.payment_methodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          deleteMany: {
            args: Prisma.payment_methodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_methodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.payment_methodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>[]
          }
          upsert: {
            args: Prisma.payment_methodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodPayload>
          }
          aggregate: {
            args: Prisma.Payment_methodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_method>
          }
          groupBy: {
            args: Prisma.payment_methodGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_methodGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_methodCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_methodCountAggregateOutputType> | number
          }
        }
      }
      product: {
        payload: Prisma.$productPayload<ExtArgs>
        fields: Prisma.productFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findFirst: {
            args: Prisma.productFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findMany: {
            args: Prisma.productFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          create: {
            args: Prisma.productCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          createMany: {
            args: Prisma.productCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.productCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          delete: {
            args: Prisma.productDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          update: {
            args: Prisma.productUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          deleteMany: {
            args: Prisma.productDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.productUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          upsert: {
            args: Prisma.productUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.productGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.productCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      sales_history: {
        payload: Prisma.$sales_historyPayload<ExtArgs>
        fields: Prisma.sales_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sales_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sales_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload>
          }
          findFirst: {
            args: Prisma.sales_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sales_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload>
          }
          findMany: {
            args: Prisma.sales_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload>[]
          }
          create: {
            args: Prisma.sales_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload>
          }
          createMany: {
            args: Prisma.sales_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sales_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload>[]
          }
          delete: {
            args: Prisma.sales_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload>
          }
          update: {
            args: Prisma.sales_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload>
          }
          deleteMany: {
            args: Prisma.sales_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sales_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sales_historyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload>[]
          }
          upsert: {
            args: Prisma.sales_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload>
          }
          aggregate: {
            args: Prisma.Sales_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSales_history>
          }
          groupBy: {
            args: Prisma.sales_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sales_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.sales_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Sales_historyCountAggregateOutputType> | number
          }
        }
      }
      supplier: {
        payload: Prisma.$supplierPayload<ExtArgs>
        fields: Prisma.supplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.supplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.supplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          findFirst: {
            args: Prisma.supplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.supplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          findMany: {
            args: Prisma.supplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>[]
          }
          create: {
            args: Prisma.supplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          createMany: {
            args: Prisma.supplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.supplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>[]
          }
          delete: {
            args: Prisma.supplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          update: {
            args: Prisma.supplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          deleteMany: {
            args: Prisma.supplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.supplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.supplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>[]
          }
          upsert: {
            args: Prisma.supplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.supplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.supplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      user_credentials: {
        payload: Prisma.$user_credentialsPayload<ExtArgs>
        fields: Prisma.user_credentialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_credentialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_credentialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload>
          }
          findFirst: {
            args: Prisma.user_credentialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_credentialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload>
          }
          findMany: {
            args: Prisma.user_credentialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload>[]
          }
          create: {
            args: Prisma.user_credentialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload>
          }
          createMany: {
            args: Prisma.user_credentialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_credentialsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload>[]
          }
          delete: {
            args: Prisma.user_credentialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload>
          }
          update: {
            args: Prisma.user_credentialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload>
          }
          deleteMany: {
            args: Prisma.user_credentialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_credentialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_credentialsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload>[]
          }
          upsert: {
            args: Prisma.user_credentialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload>
          }
          aggregate: {
            args: Prisma.User_credentialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_credentials>
          }
          groupBy: {
            args: Prisma.user_credentialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_credentialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_credentialsCountArgs<ExtArgs>
            result: $Utils.Optional<User_credentialsCountAggregateOutputType> | number
          }
        }
      }
      user_role: {
        payload: Prisma.$user_rolePayload<ExtArgs>
        fields: Prisma.user_roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>
          }
          findFirst: {
            args: Prisma.user_roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>
          }
          findMany: {
            args: Prisma.user_roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>[]
          }
          create: {
            args: Prisma.user_roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>
          }
          createMany: {
            args: Prisma.user_roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_roleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>[]
          }
          delete: {
            args: Prisma.user_roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>
          }
          update: {
            args: Prisma.user_roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>
          }
          deleteMany: {
            args: Prisma.user_roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_roleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>[]
          }
          upsert: {
            args: Prisma.user_roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>
          }
          aggregate: {
            args: Prisma.User_roleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_role>
          }
          groupBy: {
            args: Prisma.user_roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_roleGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_roleCountArgs<ExtArgs>
            result: $Utils.Optional<User_roleCountAggregateOutputType> | number
          }
        }
      }
      variable_options: {
        payload: Prisma.$variable_optionsPayload<ExtArgs>
        fields: Prisma.variable_optionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.variable_optionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variable_optionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.variable_optionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variable_optionsPayload>
          }
          findFirst: {
            args: Prisma.variable_optionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variable_optionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.variable_optionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variable_optionsPayload>
          }
          findMany: {
            args: Prisma.variable_optionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variable_optionsPayload>[]
          }
          create: {
            args: Prisma.variable_optionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variable_optionsPayload>
          }
          createMany: {
            args: Prisma.variable_optionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.variable_optionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variable_optionsPayload>[]
          }
          delete: {
            args: Prisma.variable_optionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variable_optionsPayload>
          }
          update: {
            args: Prisma.variable_optionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variable_optionsPayload>
          }
          deleteMany: {
            args: Prisma.variable_optionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.variable_optionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.variable_optionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variable_optionsPayload>[]
          }
          upsert: {
            args: Prisma.variable_optionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variable_optionsPayload>
          }
          aggregate: {
            args: Prisma.Variable_optionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariable_options>
          }
          groupBy: {
            args: Prisma.variable_optionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Variable_optionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.variable_optionsCountArgs<ExtArgs>
            result: $Utils.Optional<Variable_optionsCountAggregateOutputType> | number
          }
        }
      }
      working_hour: {
        payload: Prisma.$working_hourPayload<ExtArgs>
        fields: Prisma.working_hourFieldRefs
        operations: {
          findUnique: {
            args: Prisma.working_hourFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$working_hourPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.working_hourFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$working_hourPayload>
          }
          findFirst: {
            args: Prisma.working_hourFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$working_hourPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.working_hourFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$working_hourPayload>
          }
          findMany: {
            args: Prisma.working_hourFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$working_hourPayload>[]
          }
          create: {
            args: Prisma.working_hourCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$working_hourPayload>
          }
          createMany: {
            args: Prisma.working_hourCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.working_hourCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$working_hourPayload>[]
          }
          delete: {
            args: Prisma.working_hourDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$working_hourPayload>
          }
          update: {
            args: Prisma.working_hourUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$working_hourPayload>
          }
          deleteMany: {
            args: Prisma.working_hourDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.working_hourUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.working_hourUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$working_hourPayload>[]
          }
          upsert: {
            args: Prisma.working_hourUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$working_hourPayload>
          }
          aggregate: {
            args: Prisma.Working_hourAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorking_hour>
          }
          groupBy: {
            args: Prisma.working_hourGroupByArgs<ExtArgs>
            result: $Utils.Optional<Working_hourGroupByOutputType>[]
          }
          count: {
            args: Prisma.working_hourCountArgs<ExtArgs>
            result: $Utils.Optional<Working_hourCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    access_type?: access_typeOmit
    branch?: branchOmit
    cart?: cartOmit
    category?: categoryOmit
    customer?: customerOmit
    discount?: discountOmit
    employee?: employeeOmit
    inventory?: inventoryOmit
    payment_method?: payment_methodOmit
    product?: productOmit
    sales_history?: sales_historyOmit
    supplier?: supplierOmit
    user_credentials?: user_credentialsOmit
    user_role?: user_roleOmit
    variable_options?: variable_optionsOmit
    working_hour?: working_hourOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    employee: number
    inventory: number
    sales_history: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | BranchCountOutputTypeCountEmployeeArgs
    inventory?: boolean | BranchCountOutputTypeCountInventoryArgs
    sales_history?: boolean | BranchCountOutputTypeCountSales_historyArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventoryWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountSales_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sales_historyWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    product: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | CategoryCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    sales_history: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales_history?: boolean | CustomerCountOutputTypeCountSales_historyArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSales_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sales_historyWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    sales_history: number
    working_hour: number
    working_hour_marked_by: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales_history?: boolean | EmployeeCountOutputTypeCountSales_historyArgs
    working_hour?: boolean | EmployeeCountOutputTypeCountWorking_hourArgs
    working_hour_marked_by?: boolean | EmployeeCountOutputTypeCountWorking_hour_marked_byArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountSales_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sales_historyWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountWorking_hourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: working_hourWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountWorking_hour_marked_byArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: working_hourWhereInput
  }


  /**
   * Count Type Payment_methodCountOutputType
   */

  export type Payment_methodCountOutputType = {
    sales_history: number
  }

  export type Payment_methodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales_history?: boolean | Payment_methodCountOutputTypeCountSales_historyArgs
  }

  // Custom InputTypes
  /**
   * Payment_methodCountOutputType without action
   */
  export type Payment_methodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment_methodCountOutputType
     */
    select?: Payment_methodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Payment_methodCountOutputType without action
   */
  export type Payment_methodCountOutputTypeCountSales_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sales_historyWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    cart: number
    inventory: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | ProductCountOutputTypeCountCartArgs
    inventory?: boolean | ProductCountOutputTypeCountInventoryArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cartWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventoryWhereInput
  }


  /**
   * Count Type Sales_historyCountOutputType
   */

  export type Sales_historyCountOutputType = {
    cart: number
  }

  export type Sales_historyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | Sales_historyCountOutputTypeCountCartArgs
  }

  // Custom InputTypes
  /**
   * Sales_historyCountOutputType without action
   */
  export type Sales_historyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sales_historyCountOutputType
     */
    select?: Sales_historyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Sales_historyCountOutputType without action
   */
  export type Sales_historyCountOutputTypeCountCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cartWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    product: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | SupplierCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
  }


  /**
   * Count Type User_roleCountOutputType
   */

  export type User_roleCountOutputType = {
    employee: number
  }

  export type User_roleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | User_roleCountOutputTypeCountEmployeeArgs
  }

  // Custom InputTypes
  /**
   * User_roleCountOutputType without action
   */
  export type User_roleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_roleCountOutputType
     */
    select?: User_roleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * User_roleCountOutputType without action
   */
  export type User_roleCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model access_type
   */

  export type AggregateAccess_type = {
    _count: Access_typeCountAggregateOutputType | null
    _avg: Access_typeAvgAggregateOutputType | null
    _sum: Access_typeSumAggregateOutputType | null
    _min: Access_typeMinAggregateOutputType | null
    _max: Access_typeMaxAggregateOutputType | null
  }

  export type Access_typeAvgAggregateOutputType = {
    access_type_id: number | null
  }

  export type Access_typeSumAggregateOutputType = {
    access_type_id: number | null
  }

  export type Access_typeMinAggregateOutputType = {
    access_type_id: number | null
    access_name: string | null
  }

  export type Access_typeMaxAggregateOutputType = {
    access_type_id: number | null
    access_name: string | null
  }

  export type Access_typeCountAggregateOutputType = {
    access_type_id: number
    access_name: number
    _all: number
  }


  export type Access_typeAvgAggregateInputType = {
    access_type_id?: true
  }

  export type Access_typeSumAggregateInputType = {
    access_type_id?: true
  }

  export type Access_typeMinAggregateInputType = {
    access_type_id?: true
    access_name?: true
  }

  export type Access_typeMaxAggregateInputType = {
    access_type_id?: true
    access_name?: true
  }

  export type Access_typeCountAggregateInputType = {
    access_type_id?: true
    access_name?: true
    _all?: true
  }

  export type Access_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which access_type to aggregate.
     */
    where?: access_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of access_types to fetch.
     */
    orderBy?: access_typeOrderByWithRelationInput | access_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: access_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` access_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` access_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned access_types
    **/
    _count?: true | Access_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Access_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Access_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Access_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Access_typeMaxAggregateInputType
  }

  export type GetAccess_typeAggregateType<T extends Access_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateAccess_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccess_type[P]>
      : GetScalarType<T[P], AggregateAccess_type[P]>
  }




  export type access_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: access_typeWhereInput
    orderBy?: access_typeOrderByWithAggregationInput | access_typeOrderByWithAggregationInput[]
    by: Access_typeScalarFieldEnum[] | Access_typeScalarFieldEnum
    having?: access_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Access_typeCountAggregateInputType | true
    _avg?: Access_typeAvgAggregateInputType
    _sum?: Access_typeSumAggregateInputType
    _min?: Access_typeMinAggregateInputType
    _max?: Access_typeMaxAggregateInputType
  }

  export type Access_typeGroupByOutputType = {
    access_type_id: number
    access_name: string
    _count: Access_typeCountAggregateOutputType | null
    _avg: Access_typeAvgAggregateOutputType | null
    _sum: Access_typeSumAggregateOutputType | null
    _min: Access_typeMinAggregateOutputType | null
    _max: Access_typeMaxAggregateOutputType | null
  }

  type GetAccess_typeGroupByPayload<T extends access_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Access_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Access_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Access_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Access_typeGroupByOutputType[P]>
        }
      >
    >


  export type access_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    access_type_id?: boolean
    access_name?: boolean
  }, ExtArgs["result"]["access_type"]>

  export type access_typeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    access_type_id?: boolean
    access_name?: boolean
  }, ExtArgs["result"]["access_type"]>

  export type access_typeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    access_type_id?: boolean
    access_name?: boolean
  }, ExtArgs["result"]["access_type"]>

  export type access_typeSelectScalar = {
    access_type_id?: boolean
    access_name?: boolean
  }

  export type access_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"access_type_id" | "access_name", ExtArgs["result"]["access_type"]>

  export type $access_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "access_type"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      access_type_id: number
      access_name: string
    }, ExtArgs["result"]["access_type"]>
    composites: {}
  }

  type access_typeGetPayload<S extends boolean | null | undefined | access_typeDefaultArgs> = $Result.GetResult<Prisma.$access_typePayload, S>

  type access_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<access_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Access_typeCountAggregateInputType | true
    }

  export interface access_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['access_type'], meta: { name: 'access_type' } }
    /**
     * Find zero or one Access_type that matches the filter.
     * @param {access_typeFindUniqueArgs} args - Arguments to find a Access_type
     * @example
     * // Get one Access_type
     * const access_type = await prisma.access_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends access_typeFindUniqueArgs>(args: SelectSubset<T, access_typeFindUniqueArgs<ExtArgs>>): Prisma__access_typeClient<$Result.GetResult<Prisma.$access_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Access_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {access_typeFindUniqueOrThrowArgs} args - Arguments to find a Access_type
     * @example
     * // Get one Access_type
     * const access_type = await prisma.access_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends access_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, access_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__access_typeClient<$Result.GetResult<Prisma.$access_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Access_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {access_typeFindFirstArgs} args - Arguments to find a Access_type
     * @example
     * // Get one Access_type
     * const access_type = await prisma.access_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends access_typeFindFirstArgs>(args?: SelectSubset<T, access_typeFindFirstArgs<ExtArgs>>): Prisma__access_typeClient<$Result.GetResult<Prisma.$access_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Access_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {access_typeFindFirstOrThrowArgs} args - Arguments to find a Access_type
     * @example
     * // Get one Access_type
     * const access_type = await prisma.access_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends access_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, access_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__access_typeClient<$Result.GetResult<Prisma.$access_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Access_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {access_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Access_types
     * const access_types = await prisma.access_type.findMany()
     * 
     * // Get first 10 Access_types
     * const access_types = await prisma.access_type.findMany({ take: 10 })
     * 
     * // Only select the `access_type_id`
     * const access_typeWithAccess_type_idOnly = await prisma.access_type.findMany({ select: { access_type_id: true } })
     * 
     */
    findMany<T extends access_typeFindManyArgs>(args?: SelectSubset<T, access_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$access_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Access_type.
     * @param {access_typeCreateArgs} args - Arguments to create a Access_type.
     * @example
     * // Create one Access_type
     * const Access_type = await prisma.access_type.create({
     *   data: {
     *     // ... data to create a Access_type
     *   }
     * })
     * 
     */
    create<T extends access_typeCreateArgs>(args: SelectSubset<T, access_typeCreateArgs<ExtArgs>>): Prisma__access_typeClient<$Result.GetResult<Prisma.$access_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Access_types.
     * @param {access_typeCreateManyArgs} args - Arguments to create many Access_types.
     * @example
     * // Create many Access_types
     * const access_type = await prisma.access_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends access_typeCreateManyArgs>(args?: SelectSubset<T, access_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Access_types and returns the data saved in the database.
     * @param {access_typeCreateManyAndReturnArgs} args - Arguments to create many Access_types.
     * @example
     * // Create many Access_types
     * const access_type = await prisma.access_type.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Access_types and only return the `access_type_id`
     * const access_typeWithAccess_type_idOnly = await prisma.access_type.createManyAndReturn({
     *   select: { access_type_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends access_typeCreateManyAndReturnArgs>(args?: SelectSubset<T, access_typeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$access_typePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Access_type.
     * @param {access_typeDeleteArgs} args - Arguments to delete one Access_type.
     * @example
     * // Delete one Access_type
     * const Access_type = await prisma.access_type.delete({
     *   where: {
     *     // ... filter to delete one Access_type
     *   }
     * })
     * 
     */
    delete<T extends access_typeDeleteArgs>(args: SelectSubset<T, access_typeDeleteArgs<ExtArgs>>): Prisma__access_typeClient<$Result.GetResult<Prisma.$access_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Access_type.
     * @param {access_typeUpdateArgs} args - Arguments to update one Access_type.
     * @example
     * // Update one Access_type
     * const access_type = await prisma.access_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends access_typeUpdateArgs>(args: SelectSubset<T, access_typeUpdateArgs<ExtArgs>>): Prisma__access_typeClient<$Result.GetResult<Prisma.$access_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Access_types.
     * @param {access_typeDeleteManyArgs} args - Arguments to filter Access_types to delete.
     * @example
     * // Delete a few Access_types
     * const { count } = await prisma.access_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends access_typeDeleteManyArgs>(args?: SelectSubset<T, access_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Access_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {access_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Access_types
     * const access_type = await prisma.access_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends access_typeUpdateManyArgs>(args: SelectSubset<T, access_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Access_types and returns the data updated in the database.
     * @param {access_typeUpdateManyAndReturnArgs} args - Arguments to update many Access_types.
     * @example
     * // Update many Access_types
     * const access_type = await prisma.access_type.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Access_types and only return the `access_type_id`
     * const access_typeWithAccess_type_idOnly = await prisma.access_type.updateManyAndReturn({
     *   select: { access_type_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends access_typeUpdateManyAndReturnArgs>(args: SelectSubset<T, access_typeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$access_typePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Access_type.
     * @param {access_typeUpsertArgs} args - Arguments to update or create a Access_type.
     * @example
     * // Update or create a Access_type
     * const access_type = await prisma.access_type.upsert({
     *   create: {
     *     // ... data to create a Access_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Access_type we want to update
     *   }
     * })
     */
    upsert<T extends access_typeUpsertArgs>(args: SelectSubset<T, access_typeUpsertArgs<ExtArgs>>): Prisma__access_typeClient<$Result.GetResult<Prisma.$access_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Access_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {access_typeCountArgs} args - Arguments to filter Access_types to count.
     * @example
     * // Count the number of Access_types
     * const count = await prisma.access_type.count({
     *   where: {
     *     // ... the filter for the Access_types we want to count
     *   }
     * })
    **/
    count<T extends access_typeCountArgs>(
      args?: Subset<T, access_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Access_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Access_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Access_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Access_typeAggregateArgs>(args: Subset<T, Access_typeAggregateArgs>): Prisma.PrismaPromise<GetAccess_typeAggregateType<T>>

    /**
     * Group by Access_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {access_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends access_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: access_typeGroupByArgs['orderBy'] }
        : { orderBy?: access_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, access_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccess_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the access_type model
   */
  readonly fields: access_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for access_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__access_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the access_type model
   */
  interface access_typeFieldRefs {
    readonly access_type_id: FieldRef<"access_type", 'Int'>
    readonly access_name: FieldRef<"access_type", 'String'>
  }
    

  // Custom InputTypes
  /**
   * access_type findUnique
   */
  export type access_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_type
     */
    select?: access_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_type
     */
    omit?: access_typeOmit<ExtArgs> | null
    /**
     * Filter, which access_type to fetch.
     */
    where: access_typeWhereUniqueInput
  }

  /**
   * access_type findUniqueOrThrow
   */
  export type access_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_type
     */
    select?: access_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_type
     */
    omit?: access_typeOmit<ExtArgs> | null
    /**
     * Filter, which access_type to fetch.
     */
    where: access_typeWhereUniqueInput
  }

  /**
   * access_type findFirst
   */
  export type access_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_type
     */
    select?: access_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_type
     */
    omit?: access_typeOmit<ExtArgs> | null
    /**
     * Filter, which access_type to fetch.
     */
    where?: access_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of access_types to fetch.
     */
    orderBy?: access_typeOrderByWithRelationInput | access_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for access_types.
     */
    cursor?: access_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` access_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` access_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of access_types.
     */
    distinct?: Access_typeScalarFieldEnum | Access_typeScalarFieldEnum[]
  }

  /**
   * access_type findFirstOrThrow
   */
  export type access_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_type
     */
    select?: access_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_type
     */
    omit?: access_typeOmit<ExtArgs> | null
    /**
     * Filter, which access_type to fetch.
     */
    where?: access_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of access_types to fetch.
     */
    orderBy?: access_typeOrderByWithRelationInput | access_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for access_types.
     */
    cursor?: access_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` access_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` access_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of access_types.
     */
    distinct?: Access_typeScalarFieldEnum | Access_typeScalarFieldEnum[]
  }

  /**
   * access_type findMany
   */
  export type access_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_type
     */
    select?: access_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_type
     */
    omit?: access_typeOmit<ExtArgs> | null
    /**
     * Filter, which access_types to fetch.
     */
    where?: access_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of access_types to fetch.
     */
    orderBy?: access_typeOrderByWithRelationInput | access_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing access_types.
     */
    cursor?: access_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` access_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` access_types.
     */
    skip?: number
    distinct?: Access_typeScalarFieldEnum | Access_typeScalarFieldEnum[]
  }

  /**
   * access_type create
   */
  export type access_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_type
     */
    select?: access_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_type
     */
    omit?: access_typeOmit<ExtArgs> | null
    /**
     * The data needed to create a access_type.
     */
    data: XOR<access_typeCreateInput, access_typeUncheckedCreateInput>
  }

  /**
   * access_type createMany
   */
  export type access_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many access_types.
     */
    data: access_typeCreateManyInput | access_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * access_type createManyAndReturn
   */
  export type access_typeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_type
     */
    select?: access_typeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the access_type
     */
    omit?: access_typeOmit<ExtArgs> | null
    /**
     * The data used to create many access_types.
     */
    data: access_typeCreateManyInput | access_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * access_type update
   */
  export type access_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_type
     */
    select?: access_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_type
     */
    omit?: access_typeOmit<ExtArgs> | null
    /**
     * The data needed to update a access_type.
     */
    data: XOR<access_typeUpdateInput, access_typeUncheckedUpdateInput>
    /**
     * Choose, which access_type to update.
     */
    where: access_typeWhereUniqueInput
  }

  /**
   * access_type updateMany
   */
  export type access_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update access_types.
     */
    data: XOR<access_typeUpdateManyMutationInput, access_typeUncheckedUpdateManyInput>
    /**
     * Filter which access_types to update
     */
    where?: access_typeWhereInput
    /**
     * Limit how many access_types to update.
     */
    limit?: number
  }

  /**
   * access_type updateManyAndReturn
   */
  export type access_typeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_type
     */
    select?: access_typeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the access_type
     */
    omit?: access_typeOmit<ExtArgs> | null
    /**
     * The data used to update access_types.
     */
    data: XOR<access_typeUpdateManyMutationInput, access_typeUncheckedUpdateManyInput>
    /**
     * Filter which access_types to update
     */
    where?: access_typeWhereInput
    /**
     * Limit how many access_types to update.
     */
    limit?: number
  }

  /**
   * access_type upsert
   */
  export type access_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_type
     */
    select?: access_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_type
     */
    omit?: access_typeOmit<ExtArgs> | null
    /**
     * The filter to search for the access_type to update in case it exists.
     */
    where: access_typeWhereUniqueInput
    /**
     * In case the access_type found by the `where` argument doesn't exist, create a new access_type with this data.
     */
    create: XOR<access_typeCreateInput, access_typeUncheckedCreateInput>
    /**
     * In case the access_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<access_typeUpdateInput, access_typeUncheckedUpdateInput>
  }

  /**
   * access_type delete
   */
  export type access_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_type
     */
    select?: access_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_type
     */
    omit?: access_typeOmit<ExtArgs> | null
    /**
     * Filter which access_type to delete.
     */
    where: access_typeWhereUniqueInput
  }

  /**
   * access_type deleteMany
   */
  export type access_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which access_types to delete
     */
    where?: access_typeWhereInput
    /**
     * Limit how many access_types to delete.
     */
    limit?: number
  }

  /**
   * access_type without action
   */
  export type access_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the access_type
     */
    select?: access_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the access_type
     */
    omit?: access_typeOmit<ExtArgs> | null
  }


  /**
   * Model branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchMinAggregateOutputType = {
    branch_id: string | null
    branch_city: string | null
    branch_address: string | null
    branch_phone: string | null
    branch_email: string | null
    created_at: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    branch_id: string | null
    branch_city: string | null
    branch_address: string | null
    branch_phone: string | null
    branch_email: string | null
    created_at: Date | null
  }

  export type BranchCountAggregateOutputType = {
    branch_id: number
    branch_city: number
    branch_address: number
    branch_phone: number
    branch_email: number
    created_at: number
    _all: number
  }


  export type BranchMinAggregateInputType = {
    branch_id?: true
    branch_city?: true
    branch_address?: true
    branch_phone?: true
    branch_email?: true
    created_at?: true
  }

  export type BranchMaxAggregateInputType = {
    branch_id?: true
    branch_city?: true
    branch_address?: true
    branch_phone?: true
    branch_email?: true
    created_at?: true
  }

  export type BranchCountAggregateInputType = {
    branch_id?: true
    branch_city?: true
    branch_address?: true
    branch_phone?: true
    branch_email?: true
    created_at?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which branch to aggregate.
     */
    where?: branchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branches to fetch.
     */
    orderBy?: branchOrderByWithRelationInput | branchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: branchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type branchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: branchWhereInput
    orderBy?: branchOrderByWithAggregationInput | branchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: branchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    branch_id: string
    branch_city: string
    branch_address: string
    branch_phone: string
    branch_email: string
    created_at: Date | null
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends branchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type branchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    branch_id?: boolean
    branch_city?: boolean
    branch_address?: boolean
    branch_phone?: boolean
    branch_email?: boolean
    created_at?: boolean
    employee?: boolean | branch$employeeArgs<ExtArgs>
    inventory?: boolean | branch$inventoryArgs<ExtArgs>
    sales_history?: boolean | branch$sales_historyArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type branchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    branch_id?: boolean
    branch_city?: boolean
    branch_address?: boolean
    branch_phone?: boolean
    branch_email?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["branch"]>

  export type branchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    branch_id?: boolean
    branch_city?: boolean
    branch_address?: boolean
    branch_phone?: boolean
    branch_email?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["branch"]>

  export type branchSelectScalar = {
    branch_id?: boolean
    branch_city?: boolean
    branch_address?: boolean
    branch_phone?: boolean
    branch_email?: boolean
    created_at?: boolean
  }

  export type branchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"branch_id" | "branch_city" | "branch_address" | "branch_phone" | "branch_email" | "created_at", ExtArgs["result"]["branch"]>
  export type branchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | branch$employeeArgs<ExtArgs>
    inventory?: boolean | branch$inventoryArgs<ExtArgs>
    sales_history?: boolean | branch$sales_historyArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type branchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type branchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $branchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "branch"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>[]
      inventory: Prisma.$inventoryPayload<ExtArgs>[]
      sales_history: Prisma.$sales_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      branch_id: string
      branch_city: string
      branch_address: string
      branch_phone: string
      branch_email: string
      created_at: Date | null
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type branchGetPayload<S extends boolean | null | undefined | branchDefaultArgs> = $Result.GetResult<Prisma.$branchPayload, S>

  type branchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<branchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface branchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['branch'], meta: { name: 'branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {branchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends branchFindUniqueArgs>(args: SelectSubset<T, branchFindUniqueArgs<ExtArgs>>): Prisma__branchClient<$Result.GetResult<Prisma.$branchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {branchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends branchFindUniqueOrThrowArgs>(args: SelectSubset<T, branchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__branchClient<$Result.GetResult<Prisma.$branchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends branchFindFirstArgs>(args?: SelectSubset<T, branchFindFirstArgs<ExtArgs>>): Prisma__branchClient<$Result.GetResult<Prisma.$branchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends branchFindFirstOrThrowArgs>(args?: SelectSubset<T, branchFindFirstOrThrowArgs<ExtArgs>>): Prisma__branchClient<$Result.GetResult<Prisma.$branchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `branch_id`
     * const branchWithBranch_idOnly = await prisma.branch.findMany({ select: { branch_id: true } })
     * 
     */
    findMany<T extends branchFindManyArgs>(args?: SelectSubset<T, branchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$branchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Branch.
     * @param {branchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends branchCreateArgs>(args: SelectSubset<T, branchCreateArgs<ExtArgs>>): Prisma__branchClient<$Result.GetResult<Prisma.$branchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Branches.
     * @param {branchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends branchCreateManyArgs>(args?: SelectSubset<T, branchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {branchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `branch_id`
     * const branchWithBranch_idOnly = await prisma.branch.createManyAndReturn({
     *   select: { branch_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends branchCreateManyAndReturnArgs>(args?: SelectSubset<T, branchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$branchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Branch.
     * @param {branchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends branchDeleteArgs>(args: SelectSubset<T, branchDeleteArgs<ExtArgs>>): Prisma__branchClient<$Result.GetResult<Prisma.$branchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Branch.
     * @param {branchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends branchUpdateArgs>(args: SelectSubset<T, branchUpdateArgs<ExtArgs>>): Prisma__branchClient<$Result.GetResult<Prisma.$branchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Branches.
     * @param {branchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends branchDeleteManyArgs>(args?: SelectSubset<T, branchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends branchUpdateManyArgs>(args: SelectSubset<T, branchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches and returns the data updated in the database.
     * @param {branchUpdateManyAndReturnArgs} args - Arguments to update many Branches.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Branches and only return the `branch_id`
     * const branchWithBranch_idOnly = await prisma.branch.updateManyAndReturn({
     *   select: { branch_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends branchUpdateManyAndReturnArgs>(args: SelectSubset<T, branchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$branchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Branch.
     * @param {branchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends branchUpsertArgs>(args: SelectSubset<T, branchUpsertArgs<ExtArgs>>): Prisma__branchClient<$Result.GetResult<Prisma.$branchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends branchCountArgs>(
      args?: Subset<T, branchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends branchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: branchGroupByArgs['orderBy'] }
        : { orderBy?: branchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, branchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the branch model
   */
  readonly fields: branchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__branchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends branch$employeeArgs<ExtArgs> = {}>(args?: Subset<T, branch$employeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventory<T extends branch$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, branch$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales_history<T extends branch$sales_historyArgs<ExtArgs> = {}>(args?: Subset<T, branch$sales_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the branch model
   */
  interface branchFieldRefs {
    readonly branch_id: FieldRef<"branch", 'String'>
    readonly branch_city: FieldRef<"branch", 'String'>
    readonly branch_address: FieldRef<"branch", 'String'>
    readonly branch_phone: FieldRef<"branch", 'String'>
    readonly branch_email: FieldRef<"branch", 'String'>
    readonly created_at: FieldRef<"branch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * branch findUnique
   */
  export type branchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branch
     */
    select?: branchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branch
     */
    omit?: branchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchInclude<ExtArgs> | null
    /**
     * Filter, which branch to fetch.
     */
    where: branchWhereUniqueInput
  }

  /**
   * branch findUniqueOrThrow
   */
  export type branchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branch
     */
    select?: branchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branch
     */
    omit?: branchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchInclude<ExtArgs> | null
    /**
     * Filter, which branch to fetch.
     */
    where: branchWhereUniqueInput
  }

  /**
   * branch findFirst
   */
  export type branchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branch
     */
    select?: branchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branch
     */
    omit?: branchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchInclude<ExtArgs> | null
    /**
     * Filter, which branch to fetch.
     */
    where?: branchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branches to fetch.
     */
    orderBy?: branchOrderByWithRelationInput | branchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for branches.
     */
    cursor?: branchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * branch findFirstOrThrow
   */
  export type branchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branch
     */
    select?: branchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branch
     */
    omit?: branchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchInclude<ExtArgs> | null
    /**
     * Filter, which branch to fetch.
     */
    where?: branchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branches to fetch.
     */
    orderBy?: branchOrderByWithRelationInput | branchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for branches.
     */
    cursor?: branchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * branch findMany
   */
  export type branchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branch
     */
    select?: branchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branch
     */
    omit?: branchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchInclude<ExtArgs> | null
    /**
     * Filter, which branches to fetch.
     */
    where?: branchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branches to fetch.
     */
    orderBy?: branchOrderByWithRelationInput | branchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing branches.
     */
    cursor?: branchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * branch create
   */
  export type branchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branch
     */
    select?: branchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branch
     */
    omit?: branchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchInclude<ExtArgs> | null
    /**
     * The data needed to create a branch.
     */
    data: XOR<branchCreateInput, branchUncheckedCreateInput>
  }

  /**
   * branch createMany
   */
  export type branchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many branches.
     */
    data: branchCreateManyInput | branchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * branch createManyAndReturn
   */
  export type branchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branch
     */
    select?: branchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the branch
     */
    omit?: branchOmit<ExtArgs> | null
    /**
     * The data used to create many branches.
     */
    data: branchCreateManyInput | branchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * branch update
   */
  export type branchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branch
     */
    select?: branchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branch
     */
    omit?: branchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchInclude<ExtArgs> | null
    /**
     * The data needed to update a branch.
     */
    data: XOR<branchUpdateInput, branchUncheckedUpdateInput>
    /**
     * Choose, which branch to update.
     */
    where: branchWhereUniqueInput
  }

  /**
   * branch updateMany
   */
  export type branchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update branches.
     */
    data: XOR<branchUpdateManyMutationInput, branchUncheckedUpdateManyInput>
    /**
     * Filter which branches to update
     */
    where?: branchWhereInput
    /**
     * Limit how many branches to update.
     */
    limit?: number
  }

  /**
   * branch updateManyAndReturn
   */
  export type branchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branch
     */
    select?: branchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the branch
     */
    omit?: branchOmit<ExtArgs> | null
    /**
     * The data used to update branches.
     */
    data: XOR<branchUpdateManyMutationInput, branchUncheckedUpdateManyInput>
    /**
     * Filter which branches to update
     */
    where?: branchWhereInput
    /**
     * Limit how many branches to update.
     */
    limit?: number
  }

  /**
   * branch upsert
   */
  export type branchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branch
     */
    select?: branchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branch
     */
    omit?: branchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchInclude<ExtArgs> | null
    /**
     * The filter to search for the branch to update in case it exists.
     */
    where: branchWhereUniqueInput
    /**
     * In case the branch found by the `where` argument doesn't exist, create a new branch with this data.
     */
    create: XOR<branchCreateInput, branchUncheckedCreateInput>
    /**
     * In case the branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<branchUpdateInput, branchUncheckedUpdateInput>
  }

  /**
   * branch delete
   */
  export type branchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branch
     */
    select?: branchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branch
     */
    omit?: branchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchInclude<ExtArgs> | null
    /**
     * Filter which branch to delete.
     */
    where: branchWhereUniqueInput
  }

  /**
   * branch deleteMany
   */
  export type branchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which branches to delete
     */
    where?: branchWhereInput
    /**
     * Limit how many branches to delete.
     */
    limit?: number
  }

  /**
   * branch.employee
   */
  export type branch$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    where?: employeeWhereInput
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    cursor?: employeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * branch.inventory
   */
  export type branch$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    where?: inventoryWhereInput
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    cursor?: inventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * branch.sales_history
   */
  export type branch$sales_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sales_historyInclude<ExtArgs> | null
    where?: sales_historyWhereInput
    orderBy?: sales_historyOrderByWithRelationInput | sales_historyOrderByWithRelationInput[]
    cursor?: sales_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sales_historyScalarFieldEnum | Sales_historyScalarFieldEnum[]
  }

  /**
   * branch without action
   */
  export type branchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branch
     */
    select?: branchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branch
     */
    omit?: branchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchInclude<ExtArgs> | null
  }


  /**
   * Model cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  export type CartAvgAggregateOutputType = {
    cart_id: number | null
    order_id: number | null
    quantity: number | null
    sub_total_amount: Decimal | null
  }

  export type CartSumAggregateOutputType = {
    cart_id: number | null
    order_id: number | null
    quantity: number | null
    sub_total_amount: Decimal | null
  }

  export type CartMinAggregateOutputType = {
    cart_id: number | null
    order_id: number | null
    product_id: string | null
    quantity: number | null
    sub_total_amount: Decimal | null
    created_at: Date | null
  }

  export type CartMaxAggregateOutputType = {
    cart_id: number | null
    order_id: number | null
    product_id: string | null
    quantity: number | null
    sub_total_amount: Decimal | null
    created_at: Date | null
  }

  export type CartCountAggregateOutputType = {
    cart_id: number
    order_id: number
    product_id: number
    quantity: number
    sub_total_amount: number
    created_at: number
    _all: number
  }


  export type CartAvgAggregateInputType = {
    cart_id?: true
    order_id?: true
    quantity?: true
    sub_total_amount?: true
  }

  export type CartSumAggregateInputType = {
    cart_id?: true
    order_id?: true
    quantity?: true
    sub_total_amount?: true
  }

  export type CartMinAggregateInputType = {
    cart_id?: true
    order_id?: true
    product_id?: true
    quantity?: true
    sub_total_amount?: true
    created_at?: true
  }

  export type CartMaxAggregateInputType = {
    cart_id?: true
    order_id?: true
    product_id?: true
    quantity?: true
    sub_total_amount?: true
    created_at?: true
  }

  export type CartCountAggregateInputType = {
    cart_id?: true
    order_id?: true
    product_id?: true
    quantity?: true
    sub_total_amount?: true
    created_at?: true
    _all?: true
  }

  export type CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cart to aggregate.
     */
    where?: cartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carts to fetch.
     */
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned carts
    **/
    _count?: true | CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartMaxAggregateInputType
  }

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
        [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>
  }




  export type cartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cartWhereInput
    orderBy?: cartOrderByWithAggregationInput | cartOrderByWithAggregationInput[]
    by: CartScalarFieldEnum[] | CartScalarFieldEnum
    having?: cartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartCountAggregateInputType | true
    _avg?: CartAvgAggregateInputType
    _sum?: CartSumAggregateInputType
    _min?: CartMinAggregateInputType
    _max?: CartMaxAggregateInputType
  }

  export type CartGroupByOutputType = {
    cart_id: number
    order_id: number | null
    product_id: string
    quantity: number
    sub_total_amount: Decimal | null
    created_at: Date | null
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  type GetCartGroupByPayload<T extends cartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartGroupByOutputType[P]>
            : GetScalarType<T[P], CartGroupByOutputType[P]>
        }
      >
    >


  export type cartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cart_id?: boolean
    order_id?: boolean
    product_id?: boolean
    quantity?: boolean
    sub_total_amount?: boolean
    created_at?: boolean
    product?: boolean | productDefaultArgs<ExtArgs>
    sales_history?: boolean | cart$sales_historyArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type cartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cart_id?: boolean
    order_id?: boolean
    product_id?: boolean
    quantity?: boolean
    sub_total_amount?: boolean
    created_at?: boolean
    product?: boolean | productDefaultArgs<ExtArgs>
    sales_history?: boolean | cart$sales_historyArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type cartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cart_id?: boolean
    order_id?: boolean
    product_id?: boolean
    quantity?: boolean
    sub_total_amount?: boolean
    created_at?: boolean
    product?: boolean | productDefaultArgs<ExtArgs>
    sales_history?: boolean | cart$sales_historyArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type cartSelectScalar = {
    cart_id?: boolean
    order_id?: boolean
    product_id?: boolean
    quantity?: boolean
    sub_total_amount?: boolean
    created_at?: boolean
  }

  export type cartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cart_id" | "order_id" | "product_id" | "quantity" | "sub_total_amount" | "created_at", ExtArgs["result"]["cart"]>
  export type cartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productDefaultArgs<ExtArgs>
    sales_history?: boolean | cart$sales_historyArgs<ExtArgs>
  }
  export type cartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productDefaultArgs<ExtArgs>
    sales_history?: boolean | cart$sales_historyArgs<ExtArgs>
  }
  export type cartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productDefaultArgs<ExtArgs>
    sales_history?: boolean | cart$sales_historyArgs<ExtArgs>
  }

  export type $cartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cart"
    objects: {
      product: Prisma.$productPayload<ExtArgs>
      sales_history: Prisma.$sales_historyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      cart_id: number
      order_id: number | null
      product_id: string
      quantity: number
      sub_total_amount: Prisma.Decimal | null
      created_at: Date | null
    }, ExtArgs["result"]["cart"]>
    composites: {}
  }

  type cartGetPayload<S extends boolean | null | undefined | cartDefaultArgs> = $Result.GetResult<Prisma.$cartPayload, S>

  type cartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartCountAggregateInputType | true
    }

  export interface cartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cart'], meta: { name: 'cart' } }
    /**
     * Find zero or one Cart that matches the filter.
     * @param {cartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cartFindUniqueArgs>(args: SelectSubset<T, cartFindUniqueArgs<ExtArgs>>): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cartFindUniqueOrThrowArgs>(args: SelectSubset<T, cartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cartFindFirstArgs>(args?: SelectSubset<T, cartFindFirstArgs<ExtArgs>>): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cartFindFirstOrThrowArgs>(args?: SelectSubset<T, cartFindFirstOrThrowArgs<ExtArgs>>): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     * 
     * // Only select the `cart_id`
     * const cartWithCart_idOnly = await prisma.cart.findMany({ select: { cart_id: true } })
     * 
     */
    findMany<T extends cartFindManyArgs>(args?: SelectSubset<T, cartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cart.
     * @param {cartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     * 
     */
    create<T extends cartCreateArgs>(args: SelectSubset<T, cartCreateArgs<ExtArgs>>): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carts.
     * @param {cartCreateManyArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cartCreateManyArgs>(args?: SelectSubset<T, cartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carts and returns the data saved in the database.
     * @param {cartCreateManyAndReturnArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carts and only return the `cart_id`
     * const cartWithCart_idOnly = await prisma.cart.createManyAndReturn({
     *   select: { cart_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cartCreateManyAndReturnArgs>(args?: SelectSubset<T, cartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cart.
     * @param {cartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     * 
     */
    delete<T extends cartDeleteArgs>(args: SelectSubset<T, cartDeleteArgs<ExtArgs>>): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cart.
     * @param {cartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cartUpdateArgs>(args: SelectSubset<T, cartUpdateArgs<ExtArgs>>): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carts.
     * @param {cartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cartDeleteManyArgs>(args?: SelectSubset<T, cartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cartUpdateManyArgs>(args: SelectSubset<T, cartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts and returns the data updated in the database.
     * @param {cartUpdateManyAndReturnArgs} args - Arguments to update many Carts.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carts and only return the `cart_id`
     * const cartWithCart_idOnly = await prisma.cart.updateManyAndReturn({
     *   select: { cart_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cartUpdateManyAndReturnArgs>(args: SelectSubset<T, cartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cart.
     * @param {cartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
     */
    upsert<T extends cartUpsertArgs>(args: SelectSubset<T, cartUpsertArgs<ExtArgs>>): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends cartCountArgs>(
      args?: Subset<T, cartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cartGroupByArgs['orderBy'] }
        : { orderBy?: cartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cart model
   */
  readonly fields: cartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sales_history<T extends cart$sales_historyArgs<ExtArgs> = {}>(args?: Subset<T, cart$sales_historyArgs<ExtArgs>>): Prisma__sales_historyClient<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cart model
   */
  interface cartFieldRefs {
    readonly cart_id: FieldRef<"cart", 'Int'>
    readonly order_id: FieldRef<"cart", 'Int'>
    readonly product_id: FieldRef<"cart", 'String'>
    readonly quantity: FieldRef<"cart", 'Int'>
    readonly sub_total_amount: FieldRef<"cart", 'Decimal'>
    readonly created_at: FieldRef<"cart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * cart findUnique
   */
  export type cartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart
     */
    omit?: cartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter, which cart to fetch.
     */
    where: cartWhereUniqueInput
  }

  /**
   * cart findUniqueOrThrow
   */
  export type cartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart
     */
    omit?: cartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter, which cart to fetch.
     */
    where: cartWhereUniqueInput
  }

  /**
   * cart findFirst
   */
  export type cartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart
     */
    omit?: cartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter, which cart to fetch.
     */
    where?: cartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carts to fetch.
     */
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for carts.
     */
    cursor?: cartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * cart findFirstOrThrow
   */
  export type cartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart
     */
    omit?: cartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter, which cart to fetch.
     */
    where?: cartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carts to fetch.
     */
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for carts.
     */
    cursor?: cartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * cart findMany
   */
  export type cartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart
     */
    omit?: cartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter, which carts to fetch.
     */
    where?: cartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carts to fetch.
     */
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing carts.
     */
    cursor?: cartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carts.
     */
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * cart create
   */
  export type cartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart
     */
    omit?: cartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * The data needed to create a cart.
     */
    data: XOR<cartCreateInput, cartUncheckedCreateInput>
  }

  /**
   * cart createMany
   */
  export type cartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many carts.
     */
    data: cartCreateManyInput | cartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cart createManyAndReturn
   */
  export type cartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cart
     */
    omit?: cartOmit<ExtArgs> | null
    /**
     * The data used to create many carts.
     */
    data: cartCreateManyInput | cartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * cart update
   */
  export type cartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart
     */
    omit?: cartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * The data needed to update a cart.
     */
    data: XOR<cartUpdateInput, cartUncheckedUpdateInput>
    /**
     * Choose, which cart to update.
     */
    where: cartWhereUniqueInput
  }

  /**
   * cart updateMany
   */
  export type cartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update carts.
     */
    data: XOR<cartUpdateManyMutationInput, cartUncheckedUpdateManyInput>
    /**
     * Filter which carts to update
     */
    where?: cartWhereInput
    /**
     * Limit how many carts to update.
     */
    limit?: number
  }

  /**
   * cart updateManyAndReturn
   */
  export type cartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cart
     */
    omit?: cartOmit<ExtArgs> | null
    /**
     * The data used to update carts.
     */
    data: XOR<cartUpdateManyMutationInput, cartUncheckedUpdateManyInput>
    /**
     * Filter which carts to update
     */
    where?: cartWhereInput
    /**
     * Limit how many carts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * cart upsert
   */
  export type cartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart
     */
    omit?: cartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * The filter to search for the cart to update in case it exists.
     */
    where: cartWhereUniqueInput
    /**
     * In case the cart found by the `where` argument doesn't exist, create a new cart with this data.
     */
    create: XOR<cartCreateInput, cartUncheckedCreateInput>
    /**
     * In case the cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cartUpdateInput, cartUncheckedUpdateInput>
  }

  /**
   * cart delete
   */
  export type cartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart
     */
    omit?: cartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter which cart to delete.
     */
    where: cartWhereUniqueInput
  }

  /**
   * cart deleteMany
   */
  export type cartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which carts to delete
     */
    where?: cartWhereInput
    /**
     * Limit how many carts to delete.
     */
    limit?: number
  }

  /**
   * cart.sales_history
   */
  export type cart$sales_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sales_historyInclude<ExtArgs> | null
    where?: sales_historyWhereInput
  }

  /**
   * cart without action
   */
  export type cartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart
     */
    omit?: cartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartInclude<ExtArgs> | null
  }


  /**
   * Model category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    category_id: number | null
  }

  export type CategorySumAggregateOutputType = {
    category_id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    category_id: number | null
    category_name: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    category_id: number | null
    category_name: string | null
  }

  export type CategoryCountAggregateOutputType = {
    category_id: number
    category_name: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    category_id?: true
  }

  export type CategorySumAggregateInputType = {
    category_id?: true
  }

  export type CategoryMinAggregateInputType = {
    category_id?: true
    category_name?: true
  }

  export type CategoryMaxAggregateInputType = {
    category_id?: true
    category_name?: true
  }

  export type CategoryCountAggregateInputType = {
    category_id?: true
    category_name?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category to aggregate.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoryWhereInput
    orderBy?: categoryOrderByWithAggregationInput | categoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    category_id: number
    category_name: string
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    category_id?: boolean
    category_name?: boolean
    product?: boolean | category$productArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type categorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    category_id?: boolean
    category_name?: boolean
  }, ExtArgs["result"]["category"]>

  export type categorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    category_id?: boolean
    category_name?: boolean
  }, ExtArgs["result"]["category"]>

  export type categorySelectScalar = {
    category_id?: boolean
    category_name?: boolean
  }

  export type categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"category_id" | "category_name", ExtArgs["result"]["category"]>
  export type categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | category$productArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type categoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type categoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "category"
    objects: {
      product: Prisma.$productPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      category_id: number
      category_name: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type categoryGetPayload<S extends boolean | null | undefined | categoryDefaultArgs> = $Result.GetResult<Prisma.$categoryPayload, S>

  type categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['category'], meta: { name: 'category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {categoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoryFindUniqueArgs>(args: SelectSubset<T, categoryFindUniqueArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoryFindFirstArgs>(args?: SelectSubset<T, categoryFindFirstArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `category_id`
     * const categoryWithCategory_idOnly = await prisma.category.findMany({ select: { category_id: true } })
     * 
     */
    findMany<T extends categoryFindManyArgs>(args?: SelectSubset<T, categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {categoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends categoryCreateArgs>(args: SelectSubset<T, categoryCreateArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {categoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoryCreateManyArgs>(args?: SelectSubset<T, categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {categoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `category_id`
     * const categoryWithCategory_idOnly = await prisma.category.createManyAndReturn({
     *   select: { category_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoryCreateManyAndReturnArgs>(args?: SelectSubset<T, categoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {categoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends categoryDeleteArgs>(args: SelectSubset<T, categoryDeleteArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {categoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoryUpdateArgs>(args: SelectSubset<T, categoryUpdateArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {categoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoryDeleteManyArgs>(args?: SelectSubset<T, categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoryUpdateManyArgs>(args: SelectSubset<T, categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {categoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `category_id`
     * const categoryWithCategory_idOnly = await prisma.category.updateManyAndReturn({
     *   select: { category_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends categoryUpdateManyAndReturnArgs>(args: SelectSubset<T, categoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {categoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends categoryUpsertArgs>(args: SelectSubset<T, categoryUpsertArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoryCountArgs>(
      args?: Subset<T, categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoryGroupByArgs['orderBy'] }
        : { orderBy?: categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the category model
   */
  readonly fields: categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends category$productArgs<ExtArgs> = {}>(args?: Subset<T, category$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the category model
   */
  interface categoryFieldRefs {
    readonly category_id: FieldRef<"category", 'Int'>
    readonly category_name: FieldRef<"category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * category findUnique
   */
  export type categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category findUniqueOrThrow
   */
  export type categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category findFirst
   */
  export type categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category findFirstOrThrow
   */
  export type categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category findMany
   */
  export type categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category create
   */
  export type categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a category.
     */
    data: XOR<categoryCreateInput, categoryUncheckedCreateInput>
  }

  /**
   * category createMany
   */
  export type categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoryCreateManyInput | categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * category createManyAndReturn
   */
  export type categoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * The data used to create many categories.
     */
    data: categoryCreateManyInput | categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * category update
   */
  export type categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a category.
     */
    data: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
    /**
     * Choose, which category to update.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category updateMany
   */
  export type categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoryWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * category updateManyAndReturn
   */
  export type categoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * The data used to update categories.
     */
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoryWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * category upsert
   */
  export type categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the category to update in case it exists.
     */
    where: categoryWhereUniqueInput
    /**
     * In case the category found by the `where` argument doesn't exist, create a new category with this data.
     */
    create: XOR<categoryCreateInput, categoryUncheckedCreateInput>
    /**
     * In case the category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
  }

  /**
   * category delete
   */
  export type categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter which category to delete.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category deleteMany
   */
  export type categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoryWhereInput
    /**
     * Limit how many categories to delete.
     */
    limit?: number
  }

  /**
   * category.product
   */
  export type category$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    where?: productWhereInput
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    cursor?: productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * category without action
   */
  export type categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
  }


  /**
   * Model customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    customer_id: number | null
    visit_count: number | null
    rewards_points: Decimal | null
  }

  export type CustomerSumAggregateOutputType = {
    customer_id: number | null
    visit_count: number | null
    rewards_points: Decimal | null
  }

  export type CustomerMinAggregateOutputType = {
    customer_id: number | null
    customer_name: string | null
    customer_email: string | null
    customer_phone: string | null
    customer_address: string | null
    visit_count: number | null
    rewards_points: Decimal | null
    created_at: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    customer_id: number | null
    customer_name: string | null
    customer_email: string | null
    customer_phone: string | null
    customer_address: string | null
    visit_count: number | null
    rewards_points: Decimal | null
    created_at: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    customer_id: number
    customer_name: number
    customer_email: number
    customer_phone: number
    customer_address: number
    visit_count: number
    rewards_points: number
    created_at: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    customer_id?: true
    visit_count?: true
    rewards_points?: true
  }

  export type CustomerSumAggregateInputType = {
    customer_id?: true
    visit_count?: true
    rewards_points?: true
  }

  export type CustomerMinAggregateInputType = {
    customer_id?: true
    customer_name?: true
    customer_email?: true
    customer_phone?: true
    customer_address?: true
    visit_count?: true
    rewards_points?: true
    created_at?: true
  }

  export type CustomerMaxAggregateInputType = {
    customer_id?: true
    customer_name?: true
    customer_email?: true
    customer_phone?: true
    customer_address?: true
    visit_count?: true
    rewards_points?: true
    created_at?: true
  }

  export type CustomerCountAggregateInputType = {
    customer_id?: true
    customer_name?: true
    customer_email?: true
    customer_phone?: true
    customer_address?: true
    visit_count?: true
    rewards_points?: true
    created_at?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer to aggregate.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type customerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
    orderBy?: customerOrderByWithAggregationInput | customerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: customerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    customer_id: number
    customer_name: string
    customer_email: string | null
    customer_phone: string
    customer_address: string | null
    visit_count: number | null
    rewards_points: Decimal | null
    created_at: Date | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends customerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type customerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customer_id?: boolean
    customer_name?: boolean
    customer_email?: boolean
    customer_phone?: boolean
    customer_address?: boolean
    visit_count?: boolean
    rewards_points?: boolean
    created_at?: boolean
    sales_history?: boolean | customer$sales_historyArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type customerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customer_id?: boolean
    customer_name?: boolean
    customer_email?: boolean
    customer_phone?: boolean
    customer_address?: boolean
    visit_count?: boolean
    rewards_points?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["customer"]>

  export type customerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customer_id?: boolean
    customer_name?: boolean
    customer_email?: boolean
    customer_phone?: boolean
    customer_address?: boolean
    visit_count?: boolean
    rewards_points?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["customer"]>

  export type customerSelectScalar = {
    customer_id?: boolean
    customer_name?: boolean
    customer_email?: boolean
    customer_phone?: boolean
    customer_address?: boolean
    visit_count?: boolean
    rewards_points?: boolean
    created_at?: boolean
  }

  export type customerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"customer_id" | "customer_name" | "customer_email" | "customer_phone" | "customer_address" | "visit_count" | "rewards_points" | "created_at", ExtArgs["result"]["customer"]>
  export type customerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales_history?: boolean | customer$sales_historyArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type customerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type customerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $customerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customer"
    objects: {
      sales_history: Prisma.$sales_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      customer_id: number
      customer_name: string
      customer_email: string | null
      customer_phone: string
      customer_address: string | null
      visit_count: number | null
      rewards_points: Prisma.Decimal | null
      created_at: Date | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type customerGetPayload<S extends boolean | null | undefined | customerDefaultArgs> = $Result.GetResult<Prisma.$customerPayload, S>

  type customerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface customerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customer'], meta: { name: 'customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {customerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customerFindUniqueArgs>(args: SelectSubset<T, customerFindUniqueArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customerFindUniqueOrThrowArgs>(args: SelectSubset<T, customerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customerFindFirstArgs>(args?: SelectSubset<T, customerFindFirstArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customerFindFirstOrThrowArgs>(args?: SelectSubset<T, customerFindFirstOrThrowArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `customer_id`
     * const customerWithCustomer_idOnly = await prisma.customer.findMany({ select: { customer_id: true } })
     * 
     */
    findMany<T extends customerFindManyArgs>(args?: SelectSubset<T, customerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {customerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends customerCreateArgs>(args: SelectSubset<T, customerCreateArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {customerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customerCreateManyArgs>(args?: SelectSubset<T, customerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {customerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `customer_id`
     * const customerWithCustomer_idOnly = await prisma.customer.createManyAndReturn({
     *   select: { customer_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends customerCreateManyAndReturnArgs>(args?: SelectSubset<T, customerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {customerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends customerDeleteArgs>(args: SelectSubset<T, customerDeleteArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {customerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customerUpdateArgs>(args: SelectSubset<T, customerUpdateArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {customerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customerDeleteManyArgs>(args?: SelectSubset<T, customerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customerUpdateManyArgs>(args: SelectSubset<T, customerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {customerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `customer_id`
     * const customerWithCustomer_idOnly = await prisma.customer.updateManyAndReturn({
     *   select: { customer_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends customerUpdateManyAndReturnArgs>(args: SelectSubset<T, customerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {customerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends customerUpsertArgs>(args: SelectSubset<T, customerUpsertArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends customerCountArgs>(
      args?: Subset<T, customerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customerGroupByArgs['orderBy'] }
        : { orderBy?: customerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customer model
   */
  readonly fields: customerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sales_history<T extends customer$sales_historyArgs<ExtArgs> = {}>(args?: Subset<T, customer$sales_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customer model
   */
  interface customerFieldRefs {
    readonly customer_id: FieldRef<"customer", 'Int'>
    readonly customer_name: FieldRef<"customer", 'String'>
    readonly customer_email: FieldRef<"customer", 'String'>
    readonly customer_phone: FieldRef<"customer", 'String'>
    readonly customer_address: FieldRef<"customer", 'String'>
    readonly visit_count: FieldRef<"customer", 'Int'>
    readonly rewards_points: FieldRef<"customer", 'Decimal'>
    readonly created_at: FieldRef<"customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customer findUnique
   */
  export type customerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findUniqueOrThrow
   */
  export type customerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findFirst
   */
  export type customerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findFirstOrThrow
   */
  export type customerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findMany
   */
  export type customerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer create
   */
  export type customerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to create a customer.
     */
    data: XOR<customerCreateInput, customerUncheckedCreateInput>
  }

  /**
   * customer createMany
   */
  export type customerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customers.
     */
    data: customerCreateManyInput | customerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customer createManyAndReturn
   */
  export type customerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * The data used to create many customers.
     */
    data: customerCreateManyInput | customerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customer update
   */
  export type customerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to update a customer.
     */
    data: XOR<customerUpdateInput, customerUncheckedUpdateInput>
    /**
     * Choose, which customer to update.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer updateMany
   */
  export type customerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customers.
     */
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
  }

  /**
   * customer updateManyAndReturn
   */
  export type customerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * The data used to update customers.
     */
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
  }

  /**
   * customer upsert
   */
  export type customerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The filter to search for the customer to update in case it exists.
     */
    where: customerWhereUniqueInput
    /**
     * In case the customer found by the `where` argument doesn't exist, create a new customer with this data.
     */
    create: XOR<customerCreateInput, customerUncheckedCreateInput>
    /**
     * In case the customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customerUpdateInput, customerUncheckedUpdateInput>
  }

  /**
   * customer delete
   */
  export type customerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter which customer to delete.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer deleteMany
   */
  export type customerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to delete
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to delete.
     */
    limit?: number
  }

  /**
   * customer.sales_history
   */
  export type customer$sales_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sales_historyInclude<ExtArgs> | null
    where?: sales_historyWhereInput
    orderBy?: sales_historyOrderByWithRelationInput | sales_historyOrderByWithRelationInput[]
    cursor?: sales_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sales_historyScalarFieldEnum | Sales_historyScalarFieldEnum[]
  }

  /**
   * customer without action
   */
  export type customerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
  }


  /**
   * Model discount
   */

  export type AggregateDiscount = {
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  export type DiscountAvgAggregateOutputType = {
    discount_id: number | null
    discount_percentage: Decimal | null
  }

  export type DiscountSumAggregateOutputType = {
    discount_id: number | null
    discount_percentage: Decimal | null
  }

  export type DiscountMinAggregateOutputType = {
    discount_id: number | null
    discount_name: string | null
    discount_desc: string | null
    discount_percentage: Decimal | null
  }

  export type DiscountMaxAggregateOutputType = {
    discount_id: number | null
    discount_name: string | null
    discount_desc: string | null
    discount_percentage: Decimal | null
  }

  export type DiscountCountAggregateOutputType = {
    discount_id: number
    discount_name: number
    discount_desc: number
    discount_percentage: number
    _all: number
  }


  export type DiscountAvgAggregateInputType = {
    discount_id?: true
    discount_percentage?: true
  }

  export type DiscountSumAggregateInputType = {
    discount_id?: true
    discount_percentage?: true
  }

  export type DiscountMinAggregateInputType = {
    discount_id?: true
    discount_name?: true
    discount_desc?: true
    discount_percentage?: true
  }

  export type DiscountMaxAggregateInputType = {
    discount_id?: true
    discount_name?: true
    discount_desc?: true
    discount_percentage?: true
  }

  export type DiscountCountAggregateInputType = {
    discount_id?: true
    discount_name?: true
    discount_desc?: true
    discount_percentage?: true
    _all?: true
  }

  export type DiscountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which discount to aggregate.
     */
    where?: discountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of discounts to fetch.
     */
    orderBy?: discountOrderByWithRelationInput | discountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: discountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned discounts
    **/
    _count?: true | DiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountMaxAggregateInputType
  }

  export type GetDiscountAggregateType<T extends DiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscount[P]>
      : GetScalarType<T[P], AggregateDiscount[P]>
  }




  export type discountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: discountWhereInput
    orderBy?: discountOrderByWithAggregationInput | discountOrderByWithAggregationInput[]
    by: DiscountScalarFieldEnum[] | DiscountScalarFieldEnum
    having?: discountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountCountAggregateInputType | true
    _avg?: DiscountAvgAggregateInputType
    _sum?: DiscountSumAggregateInputType
    _min?: DiscountMinAggregateInputType
    _max?: DiscountMaxAggregateInputType
  }

  export type DiscountGroupByOutputType = {
    discount_id: number
    discount_name: string
    discount_desc: string | null
    discount_percentage: Decimal
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  type GetDiscountGroupByPayload<T extends discountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountGroupByOutputType[P]>
        }
      >
    >


  export type discountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    discount_id?: boolean
    discount_name?: boolean
    discount_desc?: boolean
    discount_percentage?: boolean
  }, ExtArgs["result"]["discount"]>

  export type discountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    discount_id?: boolean
    discount_name?: boolean
    discount_desc?: boolean
    discount_percentage?: boolean
  }, ExtArgs["result"]["discount"]>

  export type discountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    discount_id?: boolean
    discount_name?: boolean
    discount_desc?: boolean
    discount_percentage?: boolean
  }, ExtArgs["result"]["discount"]>

  export type discountSelectScalar = {
    discount_id?: boolean
    discount_name?: boolean
    discount_desc?: boolean
    discount_percentage?: boolean
  }

  export type discountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"discount_id" | "discount_name" | "discount_desc" | "discount_percentage", ExtArgs["result"]["discount"]>

  export type $discountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "discount"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      discount_id: number
      discount_name: string
      discount_desc: string | null
      discount_percentage: Prisma.Decimal
    }, ExtArgs["result"]["discount"]>
    composites: {}
  }

  type discountGetPayload<S extends boolean | null | undefined | discountDefaultArgs> = $Result.GetResult<Prisma.$discountPayload, S>

  type discountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<discountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscountCountAggregateInputType | true
    }

  export interface discountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['discount'], meta: { name: 'discount' } }
    /**
     * Find zero or one Discount that matches the filter.
     * @param {discountFindUniqueArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends discountFindUniqueArgs>(args: SelectSubset<T, discountFindUniqueArgs<ExtArgs>>): Prisma__discountClient<$Result.GetResult<Prisma.$discountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Discount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {discountFindUniqueOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends discountFindUniqueOrThrowArgs>(args: SelectSubset<T, discountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__discountClient<$Result.GetResult<Prisma.$discountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discountFindFirstArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends discountFindFirstArgs>(args?: SelectSubset<T, discountFindFirstArgs<ExtArgs>>): Prisma__discountClient<$Result.GetResult<Prisma.$discountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discountFindFirstOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends discountFindFirstOrThrowArgs>(args?: SelectSubset<T, discountFindFirstOrThrowArgs<ExtArgs>>): Prisma__discountClient<$Result.GetResult<Prisma.$discountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Discounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Discounts
     * const discounts = await prisma.discount.findMany()
     * 
     * // Get first 10 Discounts
     * const discounts = await prisma.discount.findMany({ take: 10 })
     * 
     * // Only select the `discount_id`
     * const discountWithDiscount_idOnly = await prisma.discount.findMany({ select: { discount_id: true } })
     * 
     */
    findMany<T extends discountFindManyArgs>(args?: SelectSubset<T, discountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$discountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Discount.
     * @param {discountCreateArgs} args - Arguments to create a Discount.
     * @example
     * // Create one Discount
     * const Discount = await prisma.discount.create({
     *   data: {
     *     // ... data to create a Discount
     *   }
     * })
     * 
     */
    create<T extends discountCreateArgs>(args: SelectSubset<T, discountCreateArgs<ExtArgs>>): Prisma__discountClient<$Result.GetResult<Prisma.$discountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Discounts.
     * @param {discountCreateManyArgs} args - Arguments to create many Discounts.
     * @example
     * // Create many Discounts
     * const discount = await prisma.discount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends discountCreateManyArgs>(args?: SelectSubset<T, discountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Discounts and returns the data saved in the database.
     * @param {discountCreateManyAndReturnArgs} args - Arguments to create many Discounts.
     * @example
     * // Create many Discounts
     * const discount = await prisma.discount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Discounts and only return the `discount_id`
     * const discountWithDiscount_idOnly = await prisma.discount.createManyAndReturn({
     *   select: { discount_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends discountCreateManyAndReturnArgs>(args?: SelectSubset<T, discountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$discountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Discount.
     * @param {discountDeleteArgs} args - Arguments to delete one Discount.
     * @example
     * // Delete one Discount
     * const Discount = await prisma.discount.delete({
     *   where: {
     *     // ... filter to delete one Discount
     *   }
     * })
     * 
     */
    delete<T extends discountDeleteArgs>(args: SelectSubset<T, discountDeleteArgs<ExtArgs>>): Prisma__discountClient<$Result.GetResult<Prisma.$discountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Discount.
     * @param {discountUpdateArgs} args - Arguments to update one Discount.
     * @example
     * // Update one Discount
     * const discount = await prisma.discount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends discountUpdateArgs>(args: SelectSubset<T, discountUpdateArgs<ExtArgs>>): Prisma__discountClient<$Result.GetResult<Prisma.$discountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Discounts.
     * @param {discountDeleteManyArgs} args - Arguments to filter Discounts to delete.
     * @example
     * // Delete a few Discounts
     * const { count } = await prisma.discount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends discountDeleteManyArgs>(args?: SelectSubset<T, discountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends discountUpdateManyArgs>(args: SelectSubset<T, discountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts and returns the data updated in the database.
     * @param {discountUpdateManyAndReturnArgs} args - Arguments to update many Discounts.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Discounts and only return the `discount_id`
     * const discountWithDiscount_idOnly = await prisma.discount.updateManyAndReturn({
     *   select: { discount_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends discountUpdateManyAndReturnArgs>(args: SelectSubset<T, discountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$discountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Discount.
     * @param {discountUpsertArgs} args - Arguments to update or create a Discount.
     * @example
     * // Update or create a Discount
     * const discount = await prisma.discount.upsert({
     *   create: {
     *     // ... data to create a Discount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Discount we want to update
     *   }
     * })
     */
    upsert<T extends discountUpsertArgs>(args: SelectSubset<T, discountUpsertArgs<ExtArgs>>): Prisma__discountClient<$Result.GetResult<Prisma.$discountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discountCountArgs} args - Arguments to filter Discounts to count.
     * @example
     * // Count the number of Discounts
     * const count = await prisma.discount.count({
     *   where: {
     *     // ... the filter for the Discounts we want to count
     *   }
     * })
    **/
    count<T extends discountCountArgs>(
      args?: Subset<T, discountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountAggregateArgs>(args: Subset<T, DiscountAggregateArgs>): Prisma.PrismaPromise<GetDiscountAggregateType<T>>

    /**
     * Group by Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends discountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: discountGroupByArgs['orderBy'] }
        : { orderBy?: discountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, discountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the discount model
   */
  readonly fields: discountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for discount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__discountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the discount model
   */
  interface discountFieldRefs {
    readonly discount_id: FieldRef<"discount", 'Int'>
    readonly discount_name: FieldRef<"discount", 'String'>
    readonly discount_desc: FieldRef<"discount", 'String'>
    readonly discount_percentage: FieldRef<"discount", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * discount findUnique
   */
  export type discountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discount
     */
    select?: discountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discount
     */
    omit?: discountOmit<ExtArgs> | null
    /**
     * Filter, which discount to fetch.
     */
    where: discountWhereUniqueInput
  }

  /**
   * discount findUniqueOrThrow
   */
  export type discountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discount
     */
    select?: discountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discount
     */
    omit?: discountOmit<ExtArgs> | null
    /**
     * Filter, which discount to fetch.
     */
    where: discountWhereUniqueInput
  }

  /**
   * discount findFirst
   */
  export type discountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discount
     */
    select?: discountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discount
     */
    omit?: discountOmit<ExtArgs> | null
    /**
     * Filter, which discount to fetch.
     */
    where?: discountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of discounts to fetch.
     */
    orderBy?: discountOrderByWithRelationInput | discountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for discounts.
     */
    cursor?: discountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * discount findFirstOrThrow
   */
  export type discountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discount
     */
    select?: discountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discount
     */
    omit?: discountOmit<ExtArgs> | null
    /**
     * Filter, which discount to fetch.
     */
    where?: discountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of discounts to fetch.
     */
    orderBy?: discountOrderByWithRelationInput | discountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for discounts.
     */
    cursor?: discountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * discount findMany
   */
  export type discountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discount
     */
    select?: discountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discount
     */
    omit?: discountOmit<ExtArgs> | null
    /**
     * Filter, which discounts to fetch.
     */
    where?: discountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of discounts to fetch.
     */
    orderBy?: discountOrderByWithRelationInput | discountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing discounts.
     */
    cursor?: discountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` discounts.
     */
    skip?: number
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * discount create
   */
  export type discountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discount
     */
    select?: discountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discount
     */
    omit?: discountOmit<ExtArgs> | null
    /**
     * The data needed to create a discount.
     */
    data: XOR<discountCreateInput, discountUncheckedCreateInput>
  }

  /**
   * discount createMany
   */
  export type discountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many discounts.
     */
    data: discountCreateManyInput | discountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * discount createManyAndReturn
   */
  export type discountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discount
     */
    select?: discountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the discount
     */
    omit?: discountOmit<ExtArgs> | null
    /**
     * The data used to create many discounts.
     */
    data: discountCreateManyInput | discountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * discount update
   */
  export type discountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discount
     */
    select?: discountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discount
     */
    omit?: discountOmit<ExtArgs> | null
    /**
     * The data needed to update a discount.
     */
    data: XOR<discountUpdateInput, discountUncheckedUpdateInput>
    /**
     * Choose, which discount to update.
     */
    where: discountWhereUniqueInput
  }

  /**
   * discount updateMany
   */
  export type discountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update discounts.
     */
    data: XOR<discountUpdateManyMutationInput, discountUncheckedUpdateManyInput>
    /**
     * Filter which discounts to update
     */
    where?: discountWhereInput
    /**
     * Limit how many discounts to update.
     */
    limit?: number
  }

  /**
   * discount updateManyAndReturn
   */
  export type discountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discount
     */
    select?: discountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the discount
     */
    omit?: discountOmit<ExtArgs> | null
    /**
     * The data used to update discounts.
     */
    data: XOR<discountUpdateManyMutationInput, discountUncheckedUpdateManyInput>
    /**
     * Filter which discounts to update
     */
    where?: discountWhereInput
    /**
     * Limit how many discounts to update.
     */
    limit?: number
  }

  /**
   * discount upsert
   */
  export type discountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discount
     */
    select?: discountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discount
     */
    omit?: discountOmit<ExtArgs> | null
    /**
     * The filter to search for the discount to update in case it exists.
     */
    where: discountWhereUniqueInput
    /**
     * In case the discount found by the `where` argument doesn't exist, create a new discount with this data.
     */
    create: XOR<discountCreateInput, discountUncheckedCreateInput>
    /**
     * In case the discount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<discountUpdateInput, discountUncheckedUpdateInput>
  }

  /**
   * discount delete
   */
  export type discountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discount
     */
    select?: discountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discount
     */
    omit?: discountOmit<ExtArgs> | null
    /**
     * Filter which discount to delete.
     */
    where: discountWhereUniqueInput
  }

  /**
   * discount deleteMany
   */
  export type discountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which discounts to delete
     */
    where?: discountWhereInput
    /**
     * Limit how many discounts to delete.
     */
    limit?: number
  }

  /**
   * discount without action
   */
  export type discountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discount
     */
    select?: discountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discount
     */
    omit?: discountOmit<ExtArgs> | null
  }


  /**
   * Model employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    employee_id: number | null
    role_id: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    employee_id: number | null
    role_id: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    employee_id: number | null
    employee_name: string | null
    role_id: number | null
    hired_date: Date | null
    employee_email: string | null
    employee_phone: string | null
    branch_id: string | null
    employee_image: string | null
    branch_updated_on: Date | null
    role_updated_on: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    employee_id: number | null
    employee_name: string | null
    role_id: number | null
    hired_date: Date | null
    employee_email: string | null
    employee_phone: string | null
    branch_id: string | null
    employee_image: string | null
    branch_updated_on: Date | null
    role_updated_on: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    employee_id: number
    employee_name: number
    role_id: number
    hired_date: number
    employee_email: number
    employee_phone: number
    branch_id: number
    employee_image: number
    branch_updated_on: number
    role_updated_on: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    employee_id?: true
    role_id?: true
  }

  export type EmployeeSumAggregateInputType = {
    employee_id?: true
    role_id?: true
  }

  export type EmployeeMinAggregateInputType = {
    employee_id?: true
    employee_name?: true
    role_id?: true
    hired_date?: true
    employee_email?: true
    employee_phone?: true
    branch_id?: true
    employee_image?: true
    branch_updated_on?: true
    role_updated_on?: true
  }

  export type EmployeeMaxAggregateInputType = {
    employee_id?: true
    employee_name?: true
    role_id?: true
    hired_date?: true
    employee_email?: true
    employee_phone?: true
    branch_id?: true
    employee_image?: true
    branch_updated_on?: true
    role_updated_on?: true
  }

  export type EmployeeCountAggregateInputType = {
    employee_id?: true
    employee_name?: true
    role_id?: true
    hired_date?: true
    employee_email?: true
    employee_phone?: true
    branch_id?: true
    employee_image?: true
    branch_updated_on?: true
    role_updated_on?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employee to aggregate.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type employeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeWhereInput
    orderBy?: employeeOrderByWithAggregationInput | employeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: employeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    employee_id: number
    employee_name: string
    role_id: number
    hired_date: Date | null
    employee_email: string | null
    employee_phone: string
    branch_id: string
    employee_image: string | null
    branch_updated_on: Date | null
    role_updated_on: Date | null
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends employeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type employeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employee_id?: boolean
    employee_name?: boolean
    role_id?: boolean
    hired_date?: boolean
    employee_email?: boolean
    employee_phone?: boolean
    branch_id?: boolean
    employee_image?: boolean
    branch_updated_on?: boolean
    role_updated_on?: boolean
    branch?: boolean | branchDefaultArgs<ExtArgs>
    user_role?: boolean | user_roleDefaultArgs<ExtArgs>
    sales_history?: boolean | employee$sales_historyArgs<ExtArgs>
    user_credentials?: boolean | employee$user_credentialsArgs<ExtArgs>
    working_hour?: boolean | employee$working_hourArgs<ExtArgs>
    working_hour_marked_by?: boolean | employee$working_hour_marked_byArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type employeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employee_id?: boolean
    employee_name?: boolean
    role_id?: boolean
    hired_date?: boolean
    employee_email?: boolean
    employee_phone?: boolean
    branch_id?: boolean
    employee_image?: boolean
    branch_updated_on?: boolean
    role_updated_on?: boolean
    branch?: boolean | branchDefaultArgs<ExtArgs>
    user_role?: boolean | user_roleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type employeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employee_id?: boolean
    employee_name?: boolean
    role_id?: boolean
    hired_date?: boolean
    employee_email?: boolean
    employee_phone?: boolean
    branch_id?: boolean
    employee_image?: boolean
    branch_updated_on?: boolean
    role_updated_on?: boolean
    branch?: boolean | branchDefaultArgs<ExtArgs>
    user_role?: boolean | user_roleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type employeeSelectScalar = {
    employee_id?: boolean
    employee_name?: boolean
    role_id?: boolean
    hired_date?: boolean
    employee_email?: boolean
    employee_phone?: boolean
    branch_id?: boolean
    employee_image?: boolean
    branch_updated_on?: boolean
    role_updated_on?: boolean
  }

  export type employeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"employee_id" | "employee_name" | "role_id" | "hired_date" | "employee_email" | "employee_phone" | "branch_id" | "employee_image" | "branch_updated_on" | "role_updated_on", ExtArgs["result"]["employee"]>
  export type employeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | branchDefaultArgs<ExtArgs>
    user_role?: boolean | user_roleDefaultArgs<ExtArgs>
    sales_history?: boolean | employee$sales_historyArgs<ExtArgs>
    user_credentials?: boolean | employee$user_credentialsArgs<ExtArgs>
    working_hour?: boolean | employee$working_hourArgs<ExtArgs>
    working_hour_marked_by?: boolean | employee$working_hour_marked_byArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type employeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | branchDefaultArgs<ExtArgs>
    user_role?: boolean | user_roleDefaultArgs<ExtArgs>
  }
  export type employeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | branchDefaultArgs<ExtArgs>
    user_role?: boolean | user_roleDefaultArgs<ExtArgs>
  }

  export type $employeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employee"
    objects: {
      branch: Prisma.$branchPayload<ExtArgs>
      user_role: Prisma.$user_rolePayload<ExtArgs>
      sales_history: Prisma.$sales_historyPayload<ExtArgs>[]
      user_credentials: Prisma.$user_credentialsPayload<ExtArgs> | null
      working_hour: Prisma.$working_hourPayload<ExtArgs>[]
      working_hour_marked_by: Prisma.$working_hourPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      employee_id: number
      employee_name: string
      role_id: number
      hired_date: Date | null
      employee_email: string | null
      employee_phone: string
      branch_id: string
      employee_image: string | null
      branch_updated_on: Date | null
      role_updated_on: Date | null
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type employeeGetPayload<S extends boolean | null | undefined | employeeDefaultArgs> = $Result.GetResult<Prisma.$employeePayload, S>

  type employeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<employeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface employeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employee'], meta: { name: 'employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {employeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employeeFindUniqueArgs>(args: SelectSubset<T, employeeFindUniqueArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {employeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employeeFindUniqueOrThrowArgs>(args: SelectSubset<T, employeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employeeFindFirstArgs>(args?: SelectSubset<T, employeeFindFirstArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employeeFindFirstOrThrowArgs>(args?: SelectSubset<T, employeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `employee_id`
     * const employeeWithEmployee_idOnly = await prisma.employee.findMany({ select: { employee_id: true } })
     * 
     */
    findMany<T extends employeeFindManyArgs>(args?: SelectSubset<T, employeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {employeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends employeeCreateArgs>(args: SelectSubset<T, employeeCreateArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {employeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employeeCreateManyArgs>(args?: SelectSubset<T, employeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {employeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `employee_id`
     * const employeeWithEmployee_idOnly = await prisma.employee.createManyAndReturn({
     *   select: { employee_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends employeeCreateManyAndReturnArgs>(args?: SelectSubset<T, employeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {employeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends employeeDeleteArgs>(args: SelectSubset<T, employeeDeleteArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {employeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employeeUpdateArgs>(args: SelectSubset<T, employeeUpdateArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {employeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employeeDeleteManyArgs>(args?: SelectSubset<T, employeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employeeUpdateManyArgs>(args: SelectSubset<T, employeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {employeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `employee_id`
     * const employeeWithEmployee_idOnly = await prisma.employee.updateManyAndReturn({
     *   select: { employee_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends employeeUpdateManyAndReturnArgs>(args: SelectSubset<T, employeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {employeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends employeeUpsertArgs>(args: SelectSubset<T, employeeUpsertArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends employeeCountArgs>(
      args?: Subset<T, employeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employeeGroupByArgs['orderBy'] }
        : { orderBy?: employeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employee model
   */
  readonly fields: employeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends branchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, branchDefaultArgs<ExtArgs>>): Prisma__branchClient<$Result.GetResult<Prisma.$branchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user_role<T extends user_roleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, user_roleDefaultArgs<ExtArgs>>): Prisma__user_roleClient<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sales_history<T extends employee$sales_historyArgs<ExtArgs> = {}>(args?: Subset<T, employee$sales_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_credentials<T extends employee$user_credentialsArgs<ExtArgs> = {}>(args?: Subset<T, employee$user_credentialsArgs<ExtArgs>>): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    working_hour<T extends employee$working_hourArgs<ExtArgs> = {}>(args?: Subset<T, employee$working_hourArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$working_hourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    working_hour_marked_by<T extends employee$working_hour_marked_byArgs<ExtArgs> = {}>(args?: Subset<T, employee$working_hour_marked_byArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$working_hourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employee model
   */
  interface employeeFieldRefs {
    readonly employee_id: FieldRef<"employee", 'Int'>
    readonly employee_name: FieldRef<"employee", 'String'>
    readonly role_id: FieldRef<"employee", 'Int'>
    readonly hired_date: FieldRef<"employee", 'DateTime'>
    readonly employee_email: FieldRef<"employee", 'String'>
    readonly employee_phone: FieldRef<"employee", 'String'>
    readonly branch_id: FieldRef<"employee", 'String'>
    readonly employee_image: FieldRef<"employee", 'String'>
    readonly branch_updated_on: FieldRef<"employee", 'DateTime'>
    readonly role_updated_on: FieldRef<"employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * employee findUnique
   */
  export type employeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee findUniqueOrThrow
   */
  export type employeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee findFirst
   */
  export type employeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee findFirstOrThrow
   */
  export type employeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee findMany
   */
  export type employeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee create
   */
  export type employeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The data needed to create a employee.
     */
    data: XOR<employeeCreateInput, employeeUncheckedCreateInput>
  }

  /**
   * employee createMany
   */
  export type employeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employees.
     */
    data: employeeCreateManyInput | employeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employee createManyAndReturn
   */
  export type employeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * The data used to create many employees.
     */
    data: employeeCreateManyInput | employeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * employee update
   */
  export type employeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The data needed to update a employee.
     */
    data: XOR<employeeUpdateInput, employeeUncheckedUpdateInput>
    /**
     * Choose, which employee to update.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee updateMany
   */
  export type employeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employees.
     */
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyInput>
    /**
     * Filter which employees to update
     */
    where?: employeeWhereInput
    /**
     * Limit how many employees to update.
     */
    limit?: number
  }

  /**
   * employee updateManyAndReturn
   */
  export type employeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * The data used to update employees.
     */
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyInput>
    /**
     * Filter which employees to update
     */
    where?: employeeWhereInput
    /**
     * Limit how many employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * employee upsert
   */
  export type employeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The filter to search for the employee to update in case it exists.
     */
    where: employeeWhereUniqueInput
    /**
     * In case the employee found by the `where` argument doesn't exist, create a new employee with this data.
     */
    create: XOR<employeeCreateInput, employeeUncheckedCreateInput>
    /**
     * In case the employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employeeUpdateInput, employeeUncheckedUpdateInput>
  }

  /**
   * employee delete
   */
  export type employeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter which employee to delete.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee deleteMany
   */
  export type employeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employees to delete
     */
    where?: employeeWhereInput
    /**
     * Limit how many employees to delete.
     */
    limit?: number
  }

  /**
   * employee.sales_history
   */
  export type employee$sales_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sales_historyInclude<ExtArgs> | null
    where?: sales_historyWhereInput
    orderBy?: sales_historyOrderByWithRelationInput | sales_historyOrderByWithRelationInput[]
    cursor?: sales_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sales_historyScalarFieldEnum | Sales_historyScalarFieldEnum[]
  }

  /**
   * employee.user_credentials
   */
  export type employee$user_credentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_credentials
     */
    omit?: user_credentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_credentialsInclude<ExtArgs> | null
    where?: user_credentialsWhereInput
  }

  /**
   * employee.working_hour
   */
  export type employee$working_hourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the working_hour
     */
    select?: working_hourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the working_hour
     */
    omit?: working_hourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: working_hourInclude<ExtArgs> | null
    where?: working_hourWhereInput
    orderBy?: working_hourOrderByWithRelationInput | working_hourOrderByWithRelationInput[]
    cursor?: working_hourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Working_hourScalarFieldEnum | Working_hourScalarFieldEnum[]
  }

  /**
   * employee.working_hour_marked_by
   */
  export type employee$working_hour_marked_byArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the working_hour
     */
    select?: working_hourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the working_hour
     */
    omit?: working_hourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: working_hourInclude<ExtArgs> | null
    where?: working_hourWhereInput
    orderBy?: working_hourOrderByWithRelationInput | working_hourOrderByWithRelationInput[]
    cursor?: working_hourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Working_hourScalarFieldEnum | Working_hourScalarFieldEnum[]
  }

  /**
   * employee without action
   */
  export type employeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
  }


  /**
   * Model inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    quantity: number | null
    reorder_level: number | null
  }

  export type InventorySumAggregateOutputType = {
    quantity: number | null
    reorder_level: number | null
  }

  export type InventoryMinAggregateOutputType = {
    product_id: string | null
    branch_id: string | null
    quantity: number | null
    reorder_level: number | null
    updated_on: Date | null
  }

  export type InventoryMaxAggregateOutputType = {
    product_id: string | null
    branch_id: string | null
    quantity: number | null
    reorder_level: number | null
    updated_on: Date | null
  }

  export type InventoryCountAggregateOutputType = {
    product_id: number
    branch_id: number
    quantity: number
    reorder_level: number
    updated_on: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    quantity?: true
    reorder_level?: true
  }

  export type InventorySumAggregateInputType = {
    quantity?: true
    reorder_level?: true
  }

  export type InventoryMinAggregateInputType = {
    product_id?: true
    branch_id?: true
    quantity?: true
    reorder_level?: true
    updated_on?: true
  }

  export type InventoryMaxAggregateInputType = {
    product_id?: true
    branch_id?: true
    quantity?: true
    reorder_level?: true
    updated_on?: true
  }

  export type InventoryCountAggregateInputType = {
    product_id?: true
    branch_id?: true
    quantity?: true
    reorder_level?: true
    updated_on?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventory to aggregate.
     */
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type inventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventoryWhereInput
    orderBy?: inventoryOrderByWithAggregationInput | inventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: inventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    product_id: string
    branch_id: string
    quantity: number | null
    reorder_level: number | null
    updated_on: Date | null
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends inventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type inventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    product_id?: boolean
    branch_id?: boolean
    quantity?: boolean
    reorder_level?: boolean
    updated_on?: boolean
    branch?: boolean | branchDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type inventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    product_id?: boolean
    branch_id?: boolean
    quantity?: boolean
    reorder_level?: boolean
    updated_on?: boolean
    branch?: boolean | branchDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type inventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    product_id?: boolean
    branch_id?: boolean
    quantity?: boolean
    reorder_level?: boolean
    updated_on?: boolean
    branch?: boolean | branchDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type inventorySelectScalar = {
    product_id?: boolean
    branch_id?: boolean
    quantity?: boolean
    reorder_level?: boolean
    updated_on?: boolean
  }

  export type inventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"product_id" | "branch_id" | "quantity" | "reorder_level" | "updated_on", ExtArgs["result"]["inventory"]>
  export type inventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | branchDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }
  export type inventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | branchDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }
  export type inventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | branchDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }

  export type $inventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inventory"
    objects: {
      branch: Prisma.$branchPayload<ExtArgs>
      product: Prisma.$productPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      product_id: string
      branch_id: string
      quantity: number | null
      reorder_level: number | null
      updated_on: Date | null
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type inventoryGetPayload<S extends boolean | null | undefined | inventoryDefaultArgs> = $Result.GetResult<Prisma.$inventoryPayload, S>

  type inventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<inventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface inventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inventory'], meta: { name: 'inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {inventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends inventoryFindUniqueArgs>(args: SelectSubset<T, inventoryFindUniqueArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {inventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends inventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, inventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends inventoryFindFirstArgs>(args?: SelectSubset<T, inventoryFindFirstArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends inventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, inventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `product_id`
     * const inventoryWithProduct_idOnly = await prisma.inventory.findMany({ select: { product_id: true } })
     * 
     */
    findMany<T extends inventoryFindManyArgs>(args?: SelectSubset<T, inventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory.
     * @param {inventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends inventoryCreateArgs>(args: SelectSubset<T, inventoryCreateArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventories.
     * @param {inventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends inventoryCreateManyArgs>(args?: SelectSubset<T, inventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventories and returns the data saved in the database.
     * @param {inventoryCreateManyAndReturnArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventories and only return the `product_id`
     * const inventoryWithProduct_idOnly = await prisma.inventory.createManyAndReturn({
     *   select: { product_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends inventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, inventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inventory.
     * @param {inventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends inventoryDeleteArgs>(args: SelectSubset<T, inventoryDeleteArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory.
     * @param {inventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends inventoryUpdateArgs>(args: SelectSubset<T, inventoryUpdateArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventories.
     * @param {inventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends inventoryDeleteManyArgs>(args?: SelectSubset<T, inventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends inventoryUpdateManyArgs>(args: SelectSubset<T, inventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories and returns the data updated in the database.
     * @param {inventoryUpdateManyAndReturnArgs} args - Arguments to update many Inventories.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inventories and only return the `product_id`
     * const inventoryWithProduct_idOnly = await prisma.inventory.updateManyAndReturn({
     *   select: { product_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends inventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, inventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inventory.
     * @param {inventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends inventoryUpsertArgs>(args: SelectSubset<T, inventoryUpsertArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends inventoryCountArgs>(
      args?: Subset<T, inventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inventoryGroupByArgs['orderBy'] }
        : { orderBy?: inventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inventory model
   */
  readonly fields: inventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends branchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, branchDefaultArgs<ExtArgs>>): Prisma__branchClient<$Result.GetResult<Prisma.$branchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the inventory model
   */
  interface inventoryFieldRefs {
    readonly product_id: FieldRef<"inventory", 'String'>
    readonly branch_id: FieldRef<"inventory", 'String'>
    readonly quantity: FieldRef<"inventory", 'Int'>
    readonly reorder_level: FieldRef<"inventory", 'Int'>
    readonly updated_on: FieldRef<"inventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * inventory findUnique
   */
  export type inventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter, which inventory to fetch.
     */
    where: inventoryWhereUniqueInput
  }

  /**
   * inventory findUniqueOrThrow
   */
  export type inventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter, which inventory to fetch.
     */
    where: inventoryWhereUniqueInput
  }

  /**
   * inventory findFirst
   */
  export type inventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter, which inventory to fetch.
     */
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventories.
     */
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * inventory findFirstOrThrow
   */
  export type inventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter, which inventory to fetch.
     */
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventories.
     */
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * inventory findMany
   */
  export type inventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter, which inventories to fetch.
     */
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inventories.
     */
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * inventory create
   */
  export type inventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a inventory.
     */
    data: XOR<inventoryCreateInput, inventoryUncheckedCreateInput>
  }

  /**
   * inventory createMany
   */
  export type inventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inventories.
     */
    data: inventoryCreateManyInput | inventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * inventory createManyAndReturn
   */
  export type inventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * The data used to create many inventories.
     */
    data: inventoryCreateManyInput | inventoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * inventory update
   */
  export type inventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a inventory.
     */
    data: XOR<inventoryUpdateInput, inventoryUncheckedUpdateInput>
    /**
     * Choose, which inventory to update.
     */
    where: inventoryWhereUniqueInput
  }

  /**
   * inventory updateMany
   */
  export type inventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inventories.
     */
    data: XOR<inventoryUpdateManyMutationInput, inventoryUncheckedUpdateManyInput>
    /**
     * Filter which inventories to update
     */
    where?: inventoryWhereInput
    /**
     * Limit how many inventories to update.
     */
    limit?: number
  }

  /**
   * inventory updateManyAndReturn
   */
  export type inventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * The data used to update inventories.
     */
    data: XOR<inventoryUpdateManyMutationInput, inventoryUncheckedUpdateManyInput>
    /**
     * Filter which inventories to update
     */
    where?: inventoryWhereInput
    /**
     * Limit how many inventories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * inventory upsert
   */
  export type inventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the inventory to update in case it exists.
     */
    where: inventoryWhereUniqueInput
    /**
     * In case the inventory found by the `where` argument doesn't exist, create a new inventory with this data.
     */
    create: XOR<inventoryCreateInput, inventoryUncheckedCreateInput>
    /**
     * In case the inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inventoryUpdateInput, inventoryUncheckedUpdateInput>
  }

  /**
   * inventory delete
   */
  export type inventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter which inventory to delete.
     */
    where: inventoryWhereUniqueInput
  }

  /**
   * inventory deleteMany
   */
  export type inventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventories to delete
     */
    where?: inventoryWhereInput
    /**
     * Limit how many inventories to delete.
     */
    limit?: number
  }

  /**
   * inventory without action
   */
  export type inventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
  }


  /**
   * Model payment_method
   */

  export type AggregatePayment_method = {
    _count: Payment_methodCountAggregateOutputType | null
    _avg: Payment_methodAvgAggregateOutputType | null
    _sum: Payment_methodSumAggregateOutputType | null
    _min: Payment_methodMinAggregateOutputType | null
    _max: Payment_methodMaxAggregateOutputType | null
  }

  export type Payment_methodAvgAggregateOutputType = {
    payment_method_id: number | null
  }

  export type Payment_methodSumAggregateOutputType = {
    payment_method_id: number | null
  }

  export type Payment_methodMinAggregateOutputType = {
    payment_method_id: number | null
    payment_method_name: string | null
  }

  export type Payment_methodMaxAggregateOutputType = {
    payment_method_id: number | null
    payment_method_name: string | null
  }

  export type Payment_methodCountAggregateOutputType = {
    payment_method_id: number
    payment_method_name: number
    _all: number
  }


  export type Payment_methodAvgAggregateInputType = {
    payment_method_id?: true
  }

  export type Payment_methodSumAggregateInputType = {
    payment_method_id?: true
  }

  export type Payment_methodMinAggregateInputType = {
    payment_method_id?: true
    payment_method_name?: true
  }

  export type Payment_methodMaxAggregateInputType = {
    payment_method_id?: true
    payment_method_name?: true
  }

  export type Payment_methodCountAggregateInputType = {
    payment_method_id?: true
    payment_method_name?: true
    _all?: true
  }

  export type Payment_methodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_method to aggregate.
     */
    where?: payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodOrderByWithRelationInput | payment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_methods
    **/
    _count?: true | Payment_methodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payment_methodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payment_methodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_methodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_methodMaxAggregateInputType
  }

  export type GetPayment_methodAggregateType<T extends Payment_methodAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_method]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_method[P]>
      : GetScalarType<T[P], AggregatePayment_method[P]>
  }




  export type payment_methodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_methodWhereInput
    orderBy?: payment_methodOrderByWithAggregationInput | payment_methodOrderByWithAggregationInput[]
    by: Payment_methodScalarFieldEnum[] | Payment_methodScalarFieldEnum
    having?: payment_methodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_methodCountAggregateInputType | true
    _avg?: Payment_methodAvgAggregateInputType
    _sum?: Payment_methodSumAggregateInputType
    _min?: Payment_methodMinAggregateInputType
    _max?: Payment_methodMaxAggregateInputType
  }

  export type Payment_methodGroupByOutputType = {
    payment_method_id: number
    payment_method_name: string
    _count: Payment_methodCountAggregateOutputType | null
    _avg: Payment_methodAvgAggregateOutputType | null
    _sum: Payment_methodSumAggregateOutputType | null
    _min: Payment_methodMinAggregateOutputType | null
    _max: Payment_methodMaxAggregateOutputType | null
  }

  type GetPayment_methodGroupByPayload<T extends payment_methodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_methodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_methodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_methodGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_methodGroupByOutputType[P]>
        }
      >
    >


  export type payment_methodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_method_id?: boolean
    payment_method_name?: boolean
    sales_history?: boolean | payment_method$sales_historyArgs<ExtArgs>
    _count?: boolean | Payment_methodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_method"]>

  export type payment_methodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_method_id?: boolean
    payment_method_name?: boolean
  }, ExtArgs["result"]["payment_method"]>

  export type payment_methodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_method_id?: boolean
    payment_method_name?: boolean
  }, ExtArgs["result"]["payment_method"]>

  export type payment_methodSelectScalar = {
    payment_method_id?: boolean
    payment_method_name?: boolean
  }

  export type payment_methodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"payment_method_id" | "payment_method_name", ExtArgs["result"]["payment_method"]>
  export type payment_methodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales_history?: boolean | payment_method$sales_historyArgs<ExtArgs>
    _count?: boolean | Payment_methodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type payment_methodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type payment_methodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $payment_methodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_method"
    objects: {
      sales_history: Prisma.$sales_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      payment_method_id: number
      payment_method_name: string
    }, ExtArgs["result"]["payment_method"]>
    composites: {}
  }

  type payment_methodGetPayload<S extends boolean | null | undefined | payment_methodDefaultArgs> = $Result.GetResult<Prisma.$payment_methodPayload, S>

  type payment_methodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payment_methodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Payment_methodCountAggregateInputType | true
    }

  export interface payment_methodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_method'], meta: { name: 'payment_method' } }
    /**
     * Find zero or one Payment_method that matches the filter.
     * @param {payment_methodFindUniqueArgs} args - Arguments to find a Payment_method
     * @example
     * // Get one Payment_method
     * const payment_method = await prisma.payment_method.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_methodFindUniqueArgs>(args: SelectSubset<T, payment_methodFindUniqueArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment_method that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_methodFindUniqueOrThrowArgs} args - Arguments to find a Payment_method
     * @example
     * // Get one Payment_method
     * const payment_method = await prisma.payment_method.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_methodFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_methodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_method that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodFindFirstArgs} args - Arguments to find a Payment_method
     * @example
     * // Get one Payment_method
     * const payment_method = await prisma.payment_method.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_methodFindFirstArgs>(args?: SelectSubset<T, payment_methodFindFirstArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_method that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodFindFirstOrThrowArgs} args - Arguments to find a Payment_method
     * @example
     * // Get one Payment_method
     * const payment_method = await prisma.payment_method.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_methodFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_methodFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_methods
     * const payment_methods = await prisma.payment_method.findMany()
     * 
     * // Get first 10 Payment_methods
     * const payment_methods = await prisma.payment_method.findMany({ take: 10 })
     * 
     * // Only select the `payment_method_id`
     * const payment_methodWithPayment_method_idOnly = await prisma.payment_method.findMany({ select: { payment_method_id: true } })
     * 
     */
    findMany<T extends payment_methodFindManyArgs>(args?: SelectSubset<T, payment_methodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment_method.
     * @param {payment_methodCreateArgs} args - Arguments to create a Payment_method.
     * @example
     * // Create one Payment_method
     * const Payment_method = await prisma.payment_method.create({
     *   data: {
     *     // ... data to create a Payment_method
     *   }
     * })
     * 
     */
    create<T extends payment_methodCreateArgs>(args: SelectSubset<T, payment_methodCreateArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payment_methods.
     * @param {payment_methodCreateManyArgs} args - Arguments to create many Payment_methods.
     * @example
     * // Create many Payment_methods
     * const payment_method = await prisma.payment_method.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_methodCreateManyArgs>(args?: SelectSubset<T, payment_methodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payment_methods and returns the data saved in the database.
     * @param {payment_methodCreateManyAndReturnArgs} args - Arguments to create many Payment_methods.
     * @example
     * // Create many Payment_methods
     * const payment_method = await prisma.payment_method.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payment_methods and only return the `payment_method_id`
     * const payment_methodWithPayment_method_idOnly = await prisma.payment_method.createManyAndReturn({
     *   select: { payment_method_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payment_methodCreateManyAndReturnArgs>(args?: SelectSubset<T, payment_methodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment_method.
     * @param {payment_methodDeleteArgs} args - Arguments to delete one Payment_method.
     * @example
     * // Delete one Payment_method
     * const Payment_method = await prisma.payment_method.delete({
     *   where: {
     *     // ... filter to delete one Payment_method
     *   }
     * })
     * 
     */
    delete<T extends payment_methodDeleteArgs>(args: SelectSubset<T, payment_methodDeleteArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment_method.
     * @param {payment_methodUpdateArgs} args - Arguments to update one Payment_method.
     * @example
     * // Update one Payment_method
     * const payment_method = await prisma.payment_method.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_methodUpdateArgs>(args: SelectSubset<T, payment_methodUpdateArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payment_methods.
     * @param {payment_methodDeleteManyArgs} args - Arguments to filter Payment_methods to delete.
     * @example
     * // Delete a few Payment_methods
     * const { count } = await prisma.payment_method.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_methodDeleteManyArgs>(args?: SelectSubset<T, payment_methodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_methods
     * const payment_method = await prisma.payment_method.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_methodUpdateManyArgs>(args: SelectSubset<T, payment_methodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_methods and returns the data updated in the database.
     * @param {payment_methodUpdateManyAndReturnArgs} args - Arguments to update many Payment_methods.
     * @example
     * // Update many Payment_methods
     * const payment_method = await prisma.payment_method.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payment_methods and only return the `payment_method_id`
     * const payment_methodWithPayment_method_idOnly = await prisma.payment_method.updateManyAndReturn({
     *   select: { payment_method_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends payment_methodUpdateManyAndReturnArgs>(args: SelectSubset<T, payment_methodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment_method.
     * @param {payment_methodUpsertArgs} args - Arguments to update or create a Payment_method.
     * @example
     * // Update or create a Payment_method
     * const payment_method = await prisma.payment_method.upsert({
     *   create: {
     *     // ... data to create a Payment_method
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_method we want to update
     *   }
     * })
     */
    upsert<T extends payment_methodUpsertArgs>(args: SelectSubset<T, payment_methodUpsertArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodCountArgs} args - Arguments to filter Payment_methods to count.
     * @example
     * // Count the number of Payment_methods
     * const count = await prisma.payment_method.count({
     *   where: {
     *     // ... the filter for the Payment_methods we want to count
     *   }
     * })
    **/
    count<T extends payment_methodCountArgs>(
      args?: Subset<T, payment_methodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_methodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_methodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_methodAggregateArgs>(args: Subset<T, Payment_methodAggregateArgs>): Prisma.PrismaPromise<GetPayment_methodAggregateType<T>>

    /**
     * Group by Payment_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_methodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_methodGroupByArgs['orderBy'] }
        : { orderBy?: payment_methodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_methodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_methodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_method model
   */
  readonly fields: payment_methodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_method.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_methodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sales_history<T extends payment_method$sales_historyArgs<ExtArgs> = {}>(args?: Subset<T, payment_method$sales_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_method model
   */
  interface payment_methodFieldRefs {
    readonly payment_method_id: FieldRef<"payment_method", 'Int'>
    readonly payment_method_name: FieldRef<"payment_method", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payment_method findUnique
   */
  export type payment_methodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which payment_method to fetch.
     */
    where: payment_methodWhereUniqueInput
  }

  /**
   * payment_method findUniqueOrThrow
   */
  export type payment_methodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which payment_method to fetch.
     */
    where: payment_methodWhereUniqueInput
  }

  /**
   * payment_method findFirst
   */
  export type payment_methodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which payment_method to fetch.
     */
    where?: payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodOrderByWithRelationInput | payment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_methods.
     */
    cursor?: payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_methods.
     */
    distinct?: Payment_methodScalarFieldEnum | Payment_methodScalarFieldEnum[]
  }

  /**
   * payment_method findFirstOrThrow
   */
  export type payment_methodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which payment_method to fetch.
     */
    where?: payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodOrderByWithRelationInput | payment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_methods.
     */
    cursor?: payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_methods.
     */
    distinct?: Payment_methodScalarFieldEnum | Payment_methodScalarFieldEnum[]
  }

  /**
   * payment_method findMany
   */
  export type payment_methodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter, which payment_methods to fetch.
     */
    where?: payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodOrderByWithRelationInput | payment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_methods.
     */
    cursor?: payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    distinct?: Payment_methodScalarFieldEnum | Payment_methodScalarFieldEnum[]
  }

  /**
   * payment_method create
   */
  export type payment_methodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * The data needed to create a payment_method.
     */
    data: XOR<payment_methodCreateInput, payment_methodUncheckedCreateInput>
  }

  /**
   * payment_method createMany
   */
  export type payment_methodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_methods.
     */
    data: payment_methodCreateManyInput | payment_methodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_method createManyAndReturn
   */
  export type payment_methodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * The data used to create many payment_methods.
     */
    data: payment_methodCreateManyInput | payment_methodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_method update
   */
  export type payment_methodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * The data needed to update a payment_method.
     */
    data: XOR<payment_methodUpdateInput, payment_methodUncheckedUpdateInput>
    /**
     * Choose, which payment_method to update.
     */
    where: payment_methodWhereUniqueInput
  }

  /**
   * payment_method updateMany
   */
  export type payment_methodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_methods.
     */
    data: XOR<payment_methodUpdateManyMutationInput, payment_methodUncheckedUpdateManyInput>
    /**
     * Filter which payment_methods to update
     */
    where?: payment_methodWhereInput
    /**
     * Limit how many payment_methods to update.
     */
    limit?: number
  }

  /**
   * payment_method updateManyAndReturn
   */
  export type payment_methodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * The data used to update payment_methods.
     */
    data: XOR<payment_methodUpdateManyMutationInput, payment_methodUncheckedUpdateManyInput>
    /**
     * Filter which payment_methods to update
     */
    where?: payment_methodWhereInput
    /**
     * Limit how many payment_methods to update.
     */
    limit?: number
  }

  /**
   * payment_method upsert
   */
  export type payment_methodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * The filter to search for the payment_method to update in case it exists.
     */
    where: payment_methodWhereUniqueInput
    /**
     * In case the payment_method found by the `where` argument doesn't exist, create a new payment_method with this data.
     */
    create: XOR<payment_methodCreateInput, payment_methodUncheckedCreateInput>
    /**
     * In case the payment_method was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_methodUpdateInput, payment_methodUncheckedUpdateInput>
  }

  /**
   * payment_method delete
   */
  export type payment_methodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    /**
     * Filter which payment_method to delete.
     */
    where: payment_methodWhereUniqueInput
  }

  /**
   * payment_method deleteMany
   */
  export type payment_methodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_methods to delete
     */
    where?: payment_methodWhereInput
    /**
     * Limit how many payment_methods to delete.
     */
    limit?: number
  }

  /**
   * payment_method.sales_history
   */
  export type payment_method$sales_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sales_historyInclude<ExtArgs> | null
    where?: sales_historyWhereInput
    orderBy?: sales_historyOrderByWithRelationInput | sales_historyOrderByWithRelationInput[]
    cursor?: sales_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sales_historyScalarFieldEnum | Sales_historyScalarFieldEnum[]
  }

  /**
   * payment_method without action
   */
  export type payment_methodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
  }


  /**
   * Model product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    category_id: number | null
    buying_price: Decimal | null
    retail_price: Decimal | null
    discount: Decimal | null
    supplier_id: number | null
  }

  export type ProductSumAggregateOutputType = {
    category_id: number | null
    buying_price: Decimal | null
    retail_price: Decimal | null
    discount: Decimal | null
    supplier_id: number | null
  }

  export type ProductMinAggregateOutputType = {
    product_id: string | null
    product_name: string | null
    product_desc: string | null
    category_id: number | null
    buying_price: Decimal | null
    retail_price: Decimal | null
    discount: Decimal | null
    supplier_id: number | null
    product_barcode: string | null
    removed: boolean | null
    created_at: Date | null
    updated_on: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    product_id: string | null
    product_name: string | null
    product_desc: string | null
    category_id: number | null
    buying_price: Decimal | null
    retail_price: Decimal | null
    discount: Decimal | null
    supplier_id: number | null
    product_barcode: string | null
    removed: boolean | null
    created_at: Date | null
    updated_on: Date | null
  }

  export type ProductCountAggregateOutputType = {
    product_id: number
    product_name: number
    product_desc: number
    category_id: number
    product_image: number
    buying_price: number
    retail_price: number
    discount: number
    supplier_id: number
    product_barcode: number
    removed: number
    created_at: number
    updated_on: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    category_id?: true
    buying_price?: true
    retail_price?: true
    discount?: true
    supplier_id?: true
  }

  export type ProductSumAggregateInputType = {
    category_id?: true
    buying_price?: true
    retail_price?: true
    discount?: true
    supplier_id?: true
  }

  export type ProductMinAggregateInputType = {
    product_id?: true
    product_name?: true
    product_desc?: true
    category_id?: true
    buying_price?: true
    retail_price?: true
    discount?: true
    supplier_id?: true
    product_barcode?: true
    removed?: true
    created_at?: true
    updated_on?: true
  }

  export type ProductMaxAggregateInputType = {
    product_id?: true
    product_name?: true
    product_desc?: true
    category_id?: true
    buying_price?: true
    retail_price?: true
    discount?: true
    supplier_id?: true
    product_barcode?: true
    removed?: true
    created_at?: true
    updated_on?: true
  }

  export type ProductCountAggregateInputType = {
    product_id?: true
    product_name?: true
    product_desc?: true
    category_id?: true
    product_image?: true
    buying_price?: true
    retail_price?: true
    discount?: true
    supplier_id?: true
    product_barcode?: true
    removed?: true
    created_at?: true
    updated_on?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product to aggregate.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type productGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
    orderBy?: productOrderByWithAggregationInput | productOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    product_id: string
    product_name: string
    product_desc: string | null
    category_id: number
    product_image: string[]
    buying_price: Decimal
    retail_price: Decimal
    discount: Decimal | null
    supplier_id: number
    product_barcode: string
    removed: boolean | null
    created_at: Date | null
    updated_on: Date | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends productGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type productSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    product_id?: boolean
    product_name?: boolean
    product_desc?: boolean
    category_id?: boolean
    product_image?: boolean
    buying_price?: boolean
    retail_price?: boolean
    discount?: boolean
    supplier_id?: boolean
    product_barcode?: boolean
    removed?: boolean
    created_at?: boolean
    updated_on?: boolean
    cart?: boolean | product$cartArgs<ExtArgs>
    inventory?: boolean | product$inventoryArgs<ExtArgs>
    category?: boolean | categoryDefaultArgs<ExtArgs>
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type productSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    product_id?: boolean
    product_name?: boolean
    product_desc?: boolean
    category_id?: boolean
    product_image?: boolean
    buying_price?: boolean
    retail_price?: boolean
    discount?: boolean
    supplier_id?: boolean
    product_barcode?: boolean
    removed?: boolean
    created_at?: boolean
    updated_on?: boolean
    category?: boolean | categoryDefaultArgs<ExtArgs>
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type productSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    product_id?: boolean
    product_name?: boolean
    product_desc?: boolean
    category_id?: boolean
    product_image?: boolean
    buying_price?: boolean
    retail_price?: boolean
    discount?: boolean
    supplier_id?: boolean
    product_barcode?: boolean
    removed?: boolean
    created_at?: boolean
    updated_on?: boolean
    category?: boolean | categoryDefaultArgs<ExtArgs>
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type productSelectScalar = {
    product_id?: boolean
    product_name?: boolean
    product_desc?: boolean
    category_id?: boolean
    product_image?: boolean
    buying_price?: boolean
    retail_price?: boolean
    discount?: boolean
    supplier_id?: boolean
    product_barcode?: boolean
    removed?: boolean
    created_at?: boolean
    updated_on?: boolean
  }

  export type productOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"product_id" | "product_name" | "product_desc" | "category_id" | "product_image" | "buying_price" | "retail_price" | "discount" | "supplier_id" | "product_barcode" | "removed" | "created_at" | "updated_on", ExtArgs["result"]["product"]>
  export type productInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | product$cartArgs<ExtArgs>
    inventory?: boolean | product$inventoryArgs<ExtArgs>
    category?: boolean | categoryDefaultArgs<ExtArgs>
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type productIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | categoryDefaultArgs<ExtArgs>
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
  }
  export type productIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | categoryDefaultArgs<ExtArgs>
    supplier?: boolean | supplierDefaultArgs<ExtArgs>
  }

  export type $productPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product"
    objects: {
      cart: Prisma.$cartPayload<ExtArgs>[]
      inventory: Prisma.$inventoryPayload<ExtArgs>[]
      category: Prisma.$categoryPayload<ExtArgs>
      supplier: Prisma.$supplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      product_id: string
      product_name: string
      product_desc: string | null
      category_id: number
      product_image: string[]
      buying_price: Prisma.Decimal
      retail_price: Prisma.Decimal
      discount: Prisma.Decimal | null
      supplier_id: number
      product_barcode: string
      removed: boolean | null
      created_at: Date | null
      updated_on: Date | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type productGetPayload<S extends boolean | null | undefined | productDefaultArgs> = $Result.GetResult<Prisma.$productPayload, S>

  type productCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<productFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface productDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product'], meta: { name: 'product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {productFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productFindUniqueArgs>(args: SelectSubset<T, productFindUniqueArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {productFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productFindUniqueOrThrowArgs>(args: SelectSubset<T, productFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productFindFirstArgs>(args?: SelectSubset<T, productFindFirstArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productFindFirstOrThrowArgs>(args?: SelectSubset<T, productFindFirstOrThrowArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `product_id`
     * const productWithProduct_idOnly = await prisma.product.findMany({ select: { product_id: true } })
     * 
     */
    findMany<T extends productFindManyArgs>(args?: SelectSubset<T, productFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {productCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends productCreateArgs>(args: SelectSubset<T, productCreateArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {productCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productCreateManyArgs>(args?: SelectSubset<T, productCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {productCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `product_id`
     * const productWithProduct_idOnly = await prisma.product.createManyAndReturn({
     *   select: { product_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends productCreateManyAndReturnArgs>(args?: SelectSubset<T, productCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {productDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends productDeleteArgs>(args: SelectSubset<T, productDeleteArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {productUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productUpdateArgs>(args: SelectSubset<T, productUpdateArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {productDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productDeleteManyArgs>(args?: SelectSubset<T, productDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productUpdateManyArgs>(args: SelectSubset<T, productUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {productUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `product_id`
     * const productWithProduct_idOnly = await prisma.product.updateManyAndReturn({
     *   select: { product_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends productUpdateManyAndReturnArgs>(args: SelectSubset<T, productUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {productUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends productUpsertArgs>(args: SelectSubset<T, productUpsertArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productCountArgs>(
      args?: Subset<T, productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productGroupByArgs['orderBy'] }
        : { orderBy?: productGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product model
   */
  readonly fields: productFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cart<T extends product$cartArgs<ExtArgs> = {}>(args?: Subset<T, product$cartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventory<T extends product$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, product$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends categoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoryDefaultArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends supplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, supplierDefaultArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the product model
   */
  interface productFieldRefs {
    readonly product_id: FieldRef<"product", 'String'>
    readonly product_name: FieldRef<"product", 'String'>
    readonly product_desc: FieldRef<"product", 'String'>
    readonly category_id: FieldRef<"product", 'Int'>
    readonly product_image: FieldRef<"product", 'String[]'>
    readonly buying_price: FieldRef<"product", 'Decimal'>
    readonly retail_price: FieldRef<"product", 'Decimal'>
    readonly discount: FieldRef<"product", 'Decimal'>
    readonly supplier_id: FieldRef<"product", 'Int'>
    readonly product_barcode: FieldRef<"product", 'String'>
    readonly removed: FieldRef<"product", 'Boolean'>
    readonly created_at: FieldRef<"product", 'DateTime'>
    readonly updated_on: FieldRef<"product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * product findUnique
   */
  export type productFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }

  /**
   * product findUniqueOrThrow
   */
  export type productFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }

  /**
   * product findFirst
   */
  export type productFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * product findFirstOrThrow
   */
  export type productFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * product findMany
   */
  export type productFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * product create
   */
  export type productCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to create a product.
     */
    data: XOR<productCreateInput, productUncheckedCreateInput>
  }

  /**
   * product createMany
   */
  export type productCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productCreateManyInput | productCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * product createManyAndReturn
   */
  export type productCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * The data used to create many products.
     */
    data: productCreateManyInput | productCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * product update
   */
  export type productUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to update a product.
     */
    data: XOR<productUpdateInput, productUncheckedUpdateInput>
    /**
     * Choose, which product to update.
     */
    where: productWhereUniqueInput
  }

  /**
   * product updateMany
   */
  export type productUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
  }

  /**
   * product updateManyAndReturn
   */
  export type productUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * The data used to update products.
     */
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * product upsert
   */
  export type productUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The filter to search for the product to update in case it exists.
     */
    where: productWhereUniqueInput
    /**
     * In case the product found by the `where` argument doesn't exist, create a new product with this data.
     */
    create: XOR<productCreateInput, productUncheckedCreateInput>
    /**
     * In case the product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productUpdateInput, productUncheckedUpdateInput>
  }

  /**
   * product delete
   */
  export type productDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter which product to delete.
     */
    where: productWhereUniqueInput
  }

  /**
   * product deleteMany
   */
  export type productDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productWhereInput
    /**
     * Limit how many products to delete.
     */
    limit?: number
  }

  /**
   * product.cart
   */
  export type product$cartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart
     */
    omit?: cartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartInclude<ExtArgs> | null
    where?: cartWhereInput
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    cursor?: cartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * product.inventory
   */
  export type product$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    where?: inventoryWhereInput
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    cursor?: inventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * product without action
   */
  export type productDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
  }


  /**
   * Model sales_history
   */

  export type AggregateSales_history = {
    _count: Sales_historyCountAggregateOutputType | null
    _avg: Sales_historyAvgAggregateOutputType | null
    _sum: Sales_historySumAggregateOutputType | null
    _min: Sales_historyMinAggregateOutputType | null
    _max: Sales_historyMaxAggregateOutputType | null
  }

  export type Sales_historyAvgAggregateOutputType = {
    order_id: number | null
    customer_id: number | null
    cashier_id: number | null
    total_amount: Decimal | null
    profit: Decimal | null
    rewards_points: Decimal | null
    payment_method_id: number | null
    product_count: number | null
  }

  export type Sales_historySumAggregateOutputType = {
    order_id: number | null
    customer_id: number | null
    cashier_id: number | null
    total_amount: Decimal | null
    profit: Decimal | null
    rewards_points: Decimal | null
    payment_method_id: number | null
    product_count: number | null
  }

  export type Sales_historyMinAggregateOutputType = {
    order_id: number | null
    customer_id: number | null
    cashier_id: number | null
    branch_id: string | null
    created_at: Date | null
    total_amount: Decimal | null
    profit: Decimal | null
    rewards_points: Decimal | null
    payment_method_id: number | null
    reference_id: string | null
    product_count: number | null
  }

  export type Sales_historyMaxAggregateOutputType = {
    order_id: number | null
    customer_id: number | null
    cashier_id: number | null
    branch_id: string | null
    created_at: Date | null
    total_amount: Decimal | null
    profit: Decimal | null
    rewards_points: Decimal | null
    payment_method_id: number | null
    reference_id: string | null
    product_count: number | null
  }

  export type Sales_historyCountAggregateOutputType = {
    order_id: number
    customer_id: number
    cashier_id: number
    branch_id: number
    created_at: number
    total_amount: number
    profit: number
    rewards_points: number
    payment_method_id: number
    reference_id: number
    product_count: number
    _all: number
  }


  export type Sales_historyAvgAggregateInputType = {
    order_id?: true
    customer_id?: true
    cashier_id?: true
    total_amount?: true
    profit?: true
    rewards_points?: true
    payment_method_id?: true
    product_count?: true
  }

  export type Sales_historySumAggregateInputType = {
    order_id?: true
    customer_id?: true
    cashier_id?: true
    total_amount?: true
    profit?: true
    rewards_points?: true
    payment_method_id?: true
    product_count?: true
  }

  export type Sales_historyMinAggregateInputType = {
    order_id?: true
    customer_id?: true
    cashier_id?: true
    branch_id?: true
    created_at?: true
    total_amount?: true
    profit?: true
    rewards_points?: true
    payment_method_id?: true
    reference_id?: true
    product_count?: true
  }

  export type Sales_historyMaxAggregateInputType = {
    order_id?: true
    customer_id?: true
    cashier_id?: true
    branch_id?: true
    created_at?: true
    total_amount?: true
    profit?: true
    rewards_points?: true
    payment_method_id?: true
    reference_id?: true
    product_count?: true
  }

  export type Sales_historyCountAggregateInputType = {
    order_id?: true
    customer_id?: true
    cashier_id?: true
    branch_id?: true
    created_at?: true
    total_amount?: true
    profit?: true
    rewards_points?: true
    payment_method_id?: true
    reference_id?: true
    product_count?: true
    _all?: true
  }

  export type Sales_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sales_history to aggregate.
     */
    where?: sales_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales_histories to fetch.
     */
    orderBy?: sales_historyOrderByWithRelationInput | sales_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sales_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sales_histories
    **/
    _count?: true | Sales_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sales_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sales_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sales_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sales_historyMaxAggregateInputType
  }

  export type GetSales_historyAggregateType<T extends Sales_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateSales_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSales_history[P]>
      : GetScalarType<T[P], AggregateSales_history[P]>
  }




  export type sales_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sales_historyWhereInput
    orderBy?: sales_historyOrderByWithAggregationInput | sales_historyOrderByWithAggregationInput[]
    by: Sales_historyScalarFieldEnum[] | Sales_historyScalarFieldEnum
    having?: sales_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sales_historyCountAggregateInputType | true
    _avg?: Sales_historyAvgAggregateInputType
    _sum?: Sales_historySumAggregateInputType
    _min?: Sales_historyMinAggregateInputType
    _max?: Sales_historyMaxAggregateInputType
  }

  export type Sales_historyGroupByOutputType = {
    order_id: number
    customer_id: number | null
    cashier_id: number
    branch_id: string
    created_at: Date | null
    total_amount: Decimal | null
    profit: Decimal | null
    rewards_points: Decimal | null
    payment_method_id: number | null
    reference_id: string | null
    product_count: number | null
    _count: Sales_historyCountAggregateOutputType | null
    _avg: Sales_historyAvgAggregateOutputType | null
    _sum: Sales_historySumAggregateOutputType | null
    _min: Sales_historyMinAggregateOutputType | null
    _max: Sales_historyMaxAggregateOutputType | null
  }

  type GetSales_historyGroupByPayload<T extends sales_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sales_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sales_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sales_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Sales_historyGroupByOutputType[P]>
        }
      >
    >


  export type sales_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_id?: boolean
    customer_id?: boolean
    cashier_id?: boolean
    branch_id?: boolean
    created_at?: boolean
    total_amount?: boolean
    profit?: boolean
    rewards_points?: boolean
    payment_method_id?: boolean
    reference_id?: boolean
    product_count?: boolean
    cart?: boolean | sales_history$cartArgs<ExtArgs>
    branch?: boolean | branchDefaultArgs<ExtArgs>
    customer?: boolean | sales_history$customerArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    payment_method?: boolean | sales_history$payment_methodArgs<ExtArgs>
    _count?: boolean | Sales_historyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sales_history"]>

  export type sales_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_id?: boolean
    customer_id?: boolean
    cashier_id?: boolean
    branch_id?: boolean
    created_at?: boolean
    total_amount?: boolean
    profit?: boolean
    rewards_points?: boolean
    payment_method_id?: boolean
    reference_id?: boolean
    product_count?: boolean
    branch?: boolean | branchDefaultArgs<ExtArgs>
    customer?: boolean | sales_history$customerArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    payment_method?: boolean | sales_history$payment_methodArgs<ExtArgs>
  }, ExtArgs["result"]["sales_history"]>

  export type sales_historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_id?: boolean
    customer_id?: boolean
    cashier_id?: boolean
    branch_id?: boolean
    created_at?: boolean
    total_amount?: boolean
    profit?: boolean
    rewards_points?: boolean
    payment_method_id?: boolean
    reference_id?: boolean
    product_count?: boolean
    branch?: boolean | branchDefaultArgs<ExtArgs>
    customer?: boolean | sales_history$customerArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    payment_method?: boolean | sales_history$payment_methodArgs<ExtArgs>
  }, ExtArgs["result"]["sales_history"]>

  export type sales_historySelectScalar = {
    order_id?: boolean
    customer_id?: boolean
    cashier_id?: boolean
    branch_id?: boolean
    created_at?: boolean
    total_amount?: boolean
    profit?: boolean
    rewards_points?: boolean
    payment_method_id?: boolean
    reference_id?: boolean
    product_count?: boolean
  }

  export type sales_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"order_id" | "customer_id" | "cashier_id" | "branch_id" | "created_at" | "total_amount" | "profit" | "rewards_points" | "payment_method_id" | "reference_id" | "product_count", ExtArgs["result"]["sales_history"]>
  export type sales_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | sales_history$cartArgs<ExtArgs>
    branch?: boolean | branchDefaultArgs<ExtArgs>
    customer?: boolean | sales_history$customerArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    payment_method?: boolean | sales_history$payment_methodArgs<ExtArgs>
    _count?: boolean | Sales_historyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type sales_historyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | branchDefaultArgs<ExtArgs>
    customer?: boolean | sales_history$customerArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    payment_method?: boolean | sales_history$payment_methodArgs<ExtArgs>
  }
  export type sales_historyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | branchDefaultArgs<ExtArgs>
    customer?: boolean | sales_history$customerArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    payment_method?: boolean | sales_history$payment_methodArgs<ExtArgs>
  }

  export type $sales_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sales_history"
    objects: {
      cart: Prisma.$cartPayload<ExtArgs>[]
      branch: Prisma.$branchPayload<ExtArgs>
      customer: Prisma.$customerPayload<ExtArgs> | null
      employee: Prisma.$employeePayload<ExtArgs>
      payment_method: Prisma.$payment_methodPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      order_id: number
      customer_id: number | null
      cashier_id: number
      branch_id: string
      created_at: Date | null
      total_amount: Prisma.Decimal | null
      profit: Prisma.Decimal | null
      rewards_points: Prisma.Decimal | null
      payment_method_id: number | null
      reference_id: string | null
      product_count: number | null
    }, ExtArgs["result"]["sales_history"]>
    composites: {}
  }

  type sales_historyGetPayload<S extends boolean | null | undefined | sales_historyDefaultArgs> = $Result.GetResult<Prisma.$sales_historyPayload, S>

  type sales_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sales_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sales_historyCountAggregateInputType | true
    }

  export interface sales_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sales_history'], meta: { name: 'sales_history' } }
    /**
     * Find zero or one Sales_history that matches the filter.
     * @param {sales_historyFindUniqueArgs} args - Arguments to find a Sales_history
     * @example
     * // Get one Sales_history
     * const sales_history = await prisma.sales_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sales_historyFindUniqueArgs>(args: SelectSubset<T, sales_historyFindUniqueArgs<ExtArgs>>): Prisma__sales_historyClient<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sales_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sales_historyFindUniqueOrThrowArgs} args - Arguments to find a Sales_history
     * @example
     * // Get one Sales_history
     * const sales_history = await prisma.sales_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sales_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, sales_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sales_historyClient<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sales_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sales_historyFindFirstArgs} args - Arguments to find a Sales_history
     * @example
     * // Get one Sales_history
     * const sales_history = await prisma.sales_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sales_historyFindFirstArgs>(args?: SelectSubset<T, sales_historyFindFirstArgs<ExtArgs>>): Prisma__sales_historyClient<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sales_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sales_historyFindFirstOrThrowArgs} args - Arguments to find a Sales_history
     * @example
     * // Get one Sales_history
     * const sales_history = await prisma.sales_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sales_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, sales_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__sales_historyClient<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sales_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sales_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales_histories
     * const sales_histories = await prisma.sales_history.findMany()
     * 
     * // Get first 10 Sales_histories
     * const sales_histories = await prisma.sales_history.findMany({ take: 10 })
     * 
     * // Only select the `order_id`
     * const sales_historyWithOrder_idOnly = await prisma.sales_history.findMany({ select: { order_id: true } })
     * 
     */
    findMany<T extends sales_historyFindManyArgs>(args?: SelectSubset<T, sales_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sales_history.
     * @param {sales_historyCreateArgs} args - Arguments to create a Sales_history.
     * @example
     * // Create one Sales_history
     * const Sales_history = await prisma.sales_history.create({
     *   data: {
     *     // ... data to create a Sales_history
     *   }
     * })
     * 
     */
    create<T extends sales_historyCreateArgs>(args: SelectSubset<T, sales_historyCreateArgs<ExtArgs>>): Prisma__sales_historyClient<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sales_histories.
     * @param {sales_historyCreateManyArgs} args - Arguments to create many Sales_histories.
     * @example
     * // Create many Sales_histories
     * const sales_history = await prisma.sales_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sales_historyCreateManyArgs>(args?: SelectSubset<T, sales_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sales_histories and returns the data saved in the database.
     * @param {sales_historyCreateManyAndReturnArgs} args - Arguments to create many Sales_histories.
     * @example
     * // Create many Sales_histories
     * const sales_history = await prisma.sales_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sales_histories and only return the `order_id`
     * const sales_historyWithOrder_idOnly = await prisma.sales_history.createManyAndReturn({
     *   select: { order_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sales_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, sales_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sales_history.
     * @param {sales_historyDeleteArgs} args - Arguments to delete one Sales_history.
     * @example
     * // Delete one Sales_history
     * const Sales_history = await prisma.sales_history.delete({
     *   where: {
     *     // ... filter to delete one Sales_history
     *   }
     * })
     * 
     */
    delete<T extends sales_historyDeleteArgs>(args: SelectSubset<T, sales_historyDeleteArgs<ExtArgs>>): Prisma__sales_historyClient<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sales_history.
     * @param {sales_historyUpdateArgs} args - Arguments to update one Sales_history.
     * @example
     * // Update one Sales_history
     * const sales_history = await prisma.sales_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sales_historyUpdateArgs>(args: SelectSubset<T, sales_historyUpdateArgs<ExtArgs>>): Prisma__sales_historyClient<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sales_histories.
     * @param {sales_historyDeleteManyArgs} args - Arguments to filter Sales_histories to delete.
     * @example
     * // Delete a few Sales_histories
     * const { count } = await prisma.sales_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sales_historyDeleteManyArgs>(args?: SelectSubset<T, sales_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sales_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales_histories
     * const sales_history = await prisma.sales_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sales_historyUpdateManyArgs>(args: SelectSubset<T, sales_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales_histories and returns the data updated in the database.
     * @param {sales_historyUpdateManyAndReturnArgs} args - Arguments to update many Sales_histories.
     * @example
     * // Update many Sales_histories
     * const sales_history = await prisma.sales_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sales_histories and only return the `order_id`
     * const sales_historyWithOrder_idOnly = await prisma.sales_history.updateManyAndReturn({
     *   select: { order_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sales_historyUpdateManyAndReturnArgs>(args: SelectSubset<T, sales_historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sales_history.
     * @param {sales_historyUpsertArgs} args - Arguments to update or create a Sales_history.
     * @example
     * // Update or create a Sales_history
     * const sales_history = await prisma.sales_history.upsert({
     *   create: {
     *     // ... data to create a Sales_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sales_history we want to update
     *   }
     * })
     */
    upsert<T extends sales_historyUpsertArgs>(args: SelectSubset<T, sales_historyUpsertArgs<ExtArgs>>): Prisma__sales_historyClient<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sales_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sales_historyCountArgs} args - Arguments to filter Sales_histories to count.
     * @example
     * // Count the number of Sales_histories
     * const count = await prisma.sales_history.count({
     *   where: {
     *     // ... the filter for the Sales_histories we want to count
     *   }
     * })
    **/
    count<T extends sales_historyCountArgs>(
      args?: Subset<T, sales_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sales_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sales_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sales_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sales_historyAggregateArgs>(args: Subset<T, Sales_historyAggregateArgs>): Prisma.PrismaPromise<GetSales_historyAggregateType<T>>

    /**
     * Group by Sales_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sales_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sales_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sales_historyGroupByArgs['orderBy'] }
        : { orderBy?: sales_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sales_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSales_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sales_history model
   */
  readonly fields: sales_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sales_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sales_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cart<T extends sales_history$cartArgs<ExtArgs> = {}>(args?: Subset<T, sales_history$cartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    branch<T extends branchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, branchDefaultArgs<ExtArgs>>): Prisma__branchClient<$Result.GetResult<Prisma.$branchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends sales_history$customerArgs<ExtArgs> = {}>(args?: Subset<T, sales_history$customerArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payment_method<T extends sales_history$payment_methodArgs<ExtArgs> = {}>(args?: Subset<T, sales_history$payment_methodArgs<ExtArgs>>): Prisma__payment_methodClient<$Result.GetResult<Prisma.$payment_methodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sales_history model
   */
  interface sales_historyFieldRefs {
    readonly order_id: FieldRef<"sales_history", 'Int'>
    readonly customer_id: FieldRef<"sales_history", 'Int'>
    readonly cashier_id: FieldRef<"sales_history", 'Int'>
    readonly branch_id: FieldRef<"sales_history", 'String'>
    readonly created_at: FieldRef<"sales_history", 'DateTime'>
    readonly total_amount: FieldRef<"sales_history", 'Decimal'>
    readonly profit: FieldRef<"sales_history", 'Decimal'>
    readonly rewards_points: FieldRef<"sales_history", 'Decimal'>
    readonly payment_method_id: FieldRef<"sales_history", 'Int'>
    readonly reference_id: FieldRef<"sales_history", 'String'>
    readonly product_count: FieldRef<"sales_history", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * sales_history findUnique
   */
  export type sales_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sales_historyInclude<ExtArgs> | null
    /**
     * Filter, which sales_history to fetch.
     */
    where: sales_historyWhereUniqueInput
  }

  /**
   * sales_history findUniqueOrThrow
   */
  export type sales_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sales_historyInclude<ExtArgs> | null
    /**
     * Filter, which sales_history to fetch.
     */
    where: sales_historyWhereUniqueInput
  }

  /**
   * sales_history findFirst
   */
  export type sales_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sales_historyInclude<ExtArgs> | null
    /**
     * Filter, which sales_history to fetch.
     */
    where?: sales_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales_histories to fetch.
     */
    orderBy?: sales_historyOrderByWithRelationInput | sales_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sales_histories.
     */
    cursor?: sales_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sales_histories.
     */
    distinct?: Sales_historyScalarFieldEnum | Sales_historyScalarFieldEnum[]
  }

  /**
   * sales_history findFirstOrThrow
   */
  export type sales_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sales_historyInclude<ExtArgs> | null
    /**
     * Filter, which sales_history to fetch.
     */
    where?: sales_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales_histories to fetch.
     */
    orderBy?: sales_historyOrderByWithRelationInput | sales_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sales_histories.
     */
    cursor?: sales_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sales_histories.
     */
    distinct?: Sales_historyScalarFieldEnum | Sales_historyScalarFieldEnum[]
  }

  /**
   * sales_history findMany
   */
  export type sales_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sales_historyInclude<ExtArgs> | null
    /**
     * Filter, which sales_histories to fetch.
     */
    where?: sales_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales_histories to fetch.
     */
    orderBy?: sales_historyOrderByWithRelationInput | sales_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sales_histories.
     */
    cursor?: sales_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales_histories.
     */
    skip?: number
    distinct?: Sales_historyScalarFieldEnum | Sales_historyScalarFieldEnum[]
  }

  /**
   * sales_history create
   */
  export type sales_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sales_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a sales_history.
     */
    data: XOR<sales_historyCreateInput, sales_historyUncheckedCreateInput>
  }

  /**
   * sales_history createMany
   */
  export type sales_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sales_histories.
     */
    data: sales_historyCreateManyInput | sales_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sales_history createManyAndReturn
   */
  export type sales_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * The data used to create many sales_histories.
     */
    data: sales_historyCreateManyInput | sales_historyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sales_historyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * sales_history update
   */
  export type sales_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sales_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a sales_history.
     */
    data: XOR<sales_historyUpdateInput, sales_historyUncheckedUpdateInput>
    /**
     * Choose, which sales_history to update.
     */
    where: sales_historyWhereUniqueInput
  }

  /**
   * sales_history updateMany
   */
  export type sales_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sales_histories.
     */
    data: XOR<sales_historyUpdateManyMutationInput, sales_historyUncheckedUpdateManyInput>
    /**
     * Filter which sales_histories to update
     */
    where?: sales_historyWhereInput
    /**
     * Limit how many sales_histories to update.
     */
    limit?: number
  }

  /**
   * sales_history updateManyAndReturn
   */
  export type sales_historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * The data used to update sales_histories.
     */
    data: XOR<sales_historyUpdateManyMutationInput, sales_historyUncheckedUpdateManyInput>
    /**
     * Filter which sales_histories to update
     */
    where?: sales_historyWhereInput
    /**
     * Limit how many sales_histories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sales_historyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * sales_history upsert
   */
  export type sales_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sales_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the sales_history to update in case it exists.
     */
    where: sales_historyWhereUniqueInput
    /**
     * In case the sales_history found by the `where` argument doesn't exist, create a new sales_history with this data.
     */
    create: XOR<sales_historyCreateInput, sales_historyUncheckedCreateInput>
    /**
     * In case the sales_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sales_historyUpdateInput, sales_historyUncheckedUpdateInput>
  }

  /**
   * sales_history delete
   */
  export type sales_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sales_historyInclude<ExtArgs> | null
    /**
     * Filter which sales_history to delete.
     */
    where: sales_historyWhereUniqueInput
  }

  /**
   * sales_history deleteMany
   */
  export type sales_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sales_histories to delete
     */
    where?: sales_historyWhereInput
    /**
     * Limit how many sales_histories to delete.
     */
    limit?: number
  }

  /**
   * sales_history.cart
   */
  export type sales_history$cartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart
     */
    omit?: cartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartInclude<ExtArgs> | null
    where?: cartWhereInput
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    cursor?: cartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * sales_history.customer
   */
  export type sales_history$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    where?: customerWhereInput
  }

  /**
   * sales_history.payment_method
   */
  export type sales_history$payment_methodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_method
     */
    omit?: payment_methodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodInclude<ExtArgs> | null
    where?: payment_methodWhereInput
  }

  /**
   * sales_history without action
   */
  export type sales_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sales_historyInclude<ExtArgs> | null
  }


  /**
   * Model supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    supplier_id: number | null
  }

  export type SupplierSumAggregateOutputType = {
    supplier_id: number | null
  }

  export type SupplierMinAggregateOutputType = {
    supplier_id: number | null
    supplier_name: string | null
    supplier_email: string | null
    supplier_phone: string | null
    supplier_address: string | null
  }

  export type SupplierMaxAggregateOutputType = {
    supplier_id: number | null
    supplier_name: string | null
    supplier_email: string | null
    supplier_phone: string | null
    supplier_address: string | null
  }

  export type SupplierCountAggregateOutputType = {
    supplier_id: number
    supplier_name: number
    supplier_email: number
    supplier_phone: number
    supplier_address: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    supplier_id?: true
  }

  export type SupplierSumAggregateInputType = {
    supplier_id?: true
  }

  export type SupplierMinAggregateInputType = {
    supplier_id?: true
    supplier_name?: true
    supplier_email?: true
    supplier_phone?: true
    supplier_address?: true
  }

  export type SupplierMaxAggregateInputType = {
    supplier_id?: true
    supplier_name?: true
    supplier_email?: true
    supplier_phone?: true
    supplier_address?: true
  }

  export type SupplierCountAggregateInputType = {
    supplier_id?: true
    supplier_name?: true
    supplier_email?: true
    supplier_phone?: true
    supplier_address?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which supplier to aggregate.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type supplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: supplierWhereInput
    orderBy?: supplierOrderByWithAggregationInput | supplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: supplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    supplier_id: number
    supplier_name: string
    supplier_email: string | null
    supplier_phone: string
    supplier_address: string
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends supplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type supplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    supplier_id?: boolean
    supplier_name?: boolean
    supplier_email?: boolean
    supplier_phone?: boolean
    supplier_address?: boolean
    product?: boolean | supplier$productArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type supplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    supplier_id?: boolean
    supplier_name?: boolean
    supplier_email?: boolean
    supplier_phone?: boolean
    supplier_address?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type supplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    supplier_id?: boolean
    supplier_name?: boolean
    supplier_email?: boolean
    supplier_phone?: boolean
    supplier_address?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type supplierSelectScalar = {
    supplier_id?: boolean
    supplier_name?: boolean
    supplier_email?: boolean
    supplier_phone?: boolean
    supplier_address?: boolean
  }

  export type supplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"supplier_id" | "supplier_name" | "supplier_email" | "supplier_phone" | "supplier_address", ExtArgs["result"]["supplier"]>
  export type supplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | supplier$productArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type supplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type supplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $supplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "supplier"
    objects: {
      product: Prisma.$productPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      supplier_id: number
      supplier_name: string
      supplier_email: string | null
      supplier_phone: string
      supplier_address: string
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type supplierGetPayload<S extends boolean | null | undefined | supplierDefaultArgs> = $Result.GetResult<Prisma.$supplierPayload, S>

  type supplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<supplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface supplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['supplier'], meta: { name: 'supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {supplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends supplierFindUniqueArgs>(args: SelectSubset<T, supplierFindUniqueArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {supplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends supplierFindUniqueOrThrowArgs>(args: SelectSubset<T, supplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends supplierFindFirstArgs>(args?: SelectSubset<T, supplierFindFirstArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends supplierFindFirstOrThrowArgs>(args?: SelectSubset<T, supplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `supplier_id`
     * const supplierWithSupplier_idOnly = await prisma.supplier.findMany({ select: { supplier_id: true } })
     * 
     */
    findMany<T extends supplierFindManyArgs>(args?: SelectSubset<T, supplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supplier.
     * @param {supplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends supplierCreateArgs>(args: SelectSubset<T, supplierCreateArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {supplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends supplierCreateManyArgs>(args?: SelectSubset<T, supplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {supplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `supplier_id`
     * const supplierWithSupplier_idOnly = await prisma.supplier.createManyAndReturn({
     *   select: { supplier_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends supplierCreateManyAndReturnArgs>(args?: SelectSubset<T, supplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supplier.
     * @param {supplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends supplierDeleteArgs>(args: SelectSubset<T, supplierDeleteArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supplier.
     * @param {supplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends supplierUpdateArgs>(args: SelectSubset<T, supplierUpdateArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {supplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends supplierDeleteManyArgs>(args?: SelectSubset<T, supplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends supplierUpdateManyArgs>(args: SelectSubset<T, supplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {supplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suppliers and only return the `supplier_id`
     * const supplierWithSupplier_idOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { supplier_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends supplierUpdateManyAndReturnArgs>(args: SelectSubset<T, supplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supplier.
     * @param {supplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends supplierUpsertArgs>(args: SelectSubset<T, supplierUpsertArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends supplierCountArgs>(
      args?: Subset<T, supplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends supplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: supplierGroupByArgs['orderBy'] }
        : { orderBy?: supplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, supplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the supplier model
   */
  readonly fields: supplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__supplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends supplier$productArgs<ExtArgs> = {}>(args?: Subset<T, supplier$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the supplier model
   */
  interface supplierFieldRefs {
    readonly supplier_id: FieldRef<"supplier", 'Int'>
    readonly supplier_name: FieldRef<"supplier", 'String'>
    readonly supplier_email: FieldRef<"supplier", 'String'>
    readonly supplier_phone: FieldRef<"supplier", 'String'>
    readonly supplier_address: FieldRef<"supplier", 'String'>
  }
    

  // Custom InputTypes
  /**
   * supplier findUnique
   */
  export type supplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supplier
     */
    omit?: supplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where: supplierWhereUniqueInput
  }

  /**
   * supplier findUniqueOrThrow
   */
  export type supplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supplier
     */
    omit?: supplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where: supplierWhereUniqueInput
  }

  /**
   * supplier findFirst
   */
  export type supplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supplier
     */
    omit?: supplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suppliers.
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * supplier findFirstOrThrow
   */
  export type supplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supplier
     */
    omit?: supplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suppliers.
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * supplier findMany
   */
  export type supplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supplier
     */
    omit?: supplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter, which suppliers to fetch.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing suppliers.
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * supplier create
   */
  export type supplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supplier
     */
    omit?: supplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * The data needed to create a supplier.
     */
    data: XOR<supplierCreateInput, supplierUncheckedCreateInput>
  }

  /**
   * supplier createMany
   */
  export type supplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many suppliers.
     */
    data: supplierCreateManyInput | supplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * supplier createManyAndReturn
   */
  export type supplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the supplier
     */
    omit?: supplierOmit<ExtArgs> | null
    /**
     * The data used to create many suppliers.
     */
    data: supplierCreateManyInput | supplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * supplier update
   */
  export type supplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supplier
     */
    omit?: supplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * The data needed to update a supplier.
     */
    data: XOR<supplierUpdateInput, supplierUncheckedUpdateInput>
    /**
     * Choose, which supplier to update.
     */
    where: supplierWhereUniqueInput
  }

  /**
   * supplier updateMany
   */
  export type supplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update suppliers.
     */
    data: XOR<supplierUpdateManyMutationInput, supplierUncheckedUpdateManyInput>
    /**
     * Filter which suppliers to update
     */
    where?: supplierWhereInput
    /**
     * Limit how many suppliers to update.
     */
    limit?: number
  }

  /**
   * supplier updateManyAndReturn
   */
  export type supplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the supplier
     */
    omit?: supplierOmit<ExtArgs> | null
    /**
     * The data used to update suppliers.
     */
    data: XOR<supplierUpdateManyMutationInput, supplierUncheckedUpdateManyInput>
    /**
     * Filter which suppliers to update
     */
    where?: supplierWhereInput
    /**
     * Limit how many suppliers to update.
     */
    limit?: number
  }

  /**
   * supplier upsert
   */
  export type supplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supplier
     */
    omit?: supplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * The filter to search for the supplier to update in case it exists.
     */
    where: supplierWhereUniqueInput
    /**
     * In case the supplier found by the `where` argument doesn't exist, create a new supplier with this data.
     */
    create: XOR<supplierCreateInput, supplierUncheckedCreateInput>
    /**
     * In case the supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<supplierUpdateInput, supplierUncheckedUpdateInput>
  }

  /**
   * supplier delete
   */
  export type supplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supplier
     */
    omit?: supplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
    /**
     * Filter which supplier to delete.
     */
    where: supplierWhereUniqueInput
  }

  /**
   * supplier deleteMany
   */
  export type supplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which suppliers to delete
     */
    where?: supplierWhereInput
    /**
     * Limit how many suppliers to delete.
     */
    limit?: number
  }

  /**
   * supplier.product
   */
  export type supplier$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    where?: productWhereInput
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    cursor?: productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * supplier without action
   */
  export type supplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supplier
     */
    omit?: supplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supplierInclude<ExtArgs> | null
  }


  /**
   * Model user_credentials
   */

  export type AggregateUser_credentials = {
    _count: User_credentialsCountAggregateOutputType | null
    _avg: User_credentialsAvgAggregateOutputType | null
    _sum: User_credentialsSumAggregateOutputType | null
    _min: User_credentialsMinAggregateOutputType | null
    _max: User_credentialsMaxAggregateOutputType | null
  }

  export type User_credentialsAvgAggregateOutputType = {
    user_id: number | null
  }

  export type User_credentialsSumAggregateOutputType = {
    user_id: number | null
  }

  export type User_credentialsMinAggregateOutputType = {
    user_id: number | null
    username: string | null
    password: string | null
    updated_on: Date | null
  }

  export type User_credentialsMaxAggregateOutputType = {
    user_id: number | null
    username: string | null
    password: string | null
    updated_on: Date | null
  }

  export type User_credentialsCountAggregateOutputType = {
    user_id: number
    username: number
    password: number
    updated_on: number
    _all: number
  }


  export type User_credentialsAvgAggregateInputType = {
    user_id?: true
  }

  export type User_credentialsSumAggregateInputType = {
    user_id?: true
  }

  export type User_credentialsMinAggregateInputType = {
    user_id?: true
    username?: true
    password?: true
    updated_on?: true
  }

  export type User_credentialsMaxAggregateInputType = {
    user_id?: true
    username?: true
    password?: true
    updated_on?: true
  }

  export type User_credentialsCountAggregateInputType = {
    user_id?: true
    username?: true
    password?: true
    updated_on?: true
    _all?: true
  }

  export type User_credentialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_credentials to aggregate.
     */
    where?: user_credentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_credentials to fetch.
     */
    orderBy?: user_credentialsOrderByWithRelationInput | user_credentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_credentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_credentials
    **/
    _count?: true | User_credentialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_credentialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_credentialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_credentialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_credentialsMaxAggregateInputType
  }

  export type GetUser_credentialsAggregateType<T extends User_credentialsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_credentials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_credentials[P]>
      : GetScalarType<T[P], AggregateUser_credentials[P]>
  }




  export type user_credentialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_credentialsWhereInput
    orderBy?: user_credentialsOrderByWithAggregationInput | user_credentialsOrderByWithAggregationInput[]
    by: User_credentialsScalarFieldEnum[] | User_credentialsScalarFieldEnum
    having?: user_credentialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_credentialsCountAggregateInputType | true
    _avg?: User_credentialsAvgAggregateInputType
    _sum?: User_credentialsSumAggregateInputType
    _min?: User_credentialsMinAggregateInputType
    _max?: User_credentialsMaxAggregateInputType
  }

  export type User_credentialsGroupByOutputType = {
    user_id: number
    username: string
    password: string
    updated_on: Date | null
    _count: User_credentialsCountAggregateOutputType | null
    _avg: User_credentialsAvgAggregateOutputType | null
    _sum: User_credentialsSumAggregateOutputType | null
    _min: User_credentialsMinAggregateOutputType | null
    _max: User_credentialsMaxAggregateOutputType | null
  }

  type GetUser_credentialsGroupByPayload<T extends user_credentialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_credentialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_credentialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_credentialsGroupByOutputType[P]>
            : GetScalarType<T[P], User_credentialsGroupByOutputType[P]>
        }
      >
    >


  export type user_credentialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    username?: boolean
    password?: boolean
    updated_on?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_credentials"]>

  export type user_credentialsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    username?: boolean
    password?: boolean
    updated_on?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_credentials"]>

  export type user_credentialsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    username?: boolean
    password?: boolean
    updated_on?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_credentials"]>

  export type user_credentialsSelectScalar = {
    user_id?: boolean
    username?: boolean
    password?: boolean
    updated_on?: boolean
  }

  export type user_credentialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "username" | "password" | "updated_on", ExtArgs["result"]["user_credentials"]>
  export type user_credentialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }
  export type user_credentialsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }
  export type user_credentialsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }

  export type $user_credentialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_credentials"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      username: string
      password: string
      updated_on: Date | null
    }, ExtArgs["result"]["user_credentials"]>
    composites: {}
  }

  type user_credentialsGetPayload<S extends boolean | null | undefined | user_credentialsDefaultArgs> = $Result.GetResult<Prisma.$user_credentialsPayload, S>

  type user_credentialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_credentialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_credentialsCountAggregateInputType | true
    }

  export interface user_credentialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_credentials'], meta: { name: 'user_credentials' } }
    /**
     * Find zero or one User_credentials that matches the filter.
     * @param {user_credentialsFindUniqueArgs} args - Arguments to find a User_credentials
     * @example
     * // Get one User_credentials
     * const user_credentials = await prisma.user_credentials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_credentialsFindUniqueArgs>(args: SelectSubset<T, user_credentialsFindUniqueArgs<ExtArgs>>): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_credentials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_credentialsFindUniqueOrThrowArgs} args - Arguments to find a User_credentials
     * @example
     * // Get one User_credentials
     * const user_credentials = await prisma.user_credentials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_credentialsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_credentialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_credentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credentialsFindFirstArgs} args - Arguments to find a User_credentials
     * @example
     * // Get one User_credentials
     * const user_credentials = await prisma.user_credentials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_credentialsFindFirstArgs>(args?: SelectSubset<T, user_credentialsFindFirstArgs<ExtArgs>>): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_credentials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credentialsFindFirstOrThrowArgs} args - Arguments to find a User_credentials
     * @example
     * // Get one User_credentials
     * const user_credentials = await prisma.user_credentials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_credentialsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_credentialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_credentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credentialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_credentials
     * const user_credentials = await prisma.user_credentials.findMany()
     * 
     * // Get first 10 User_credentials
     * const user_credentials = await prisma.user_credentials.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const user_credentialsWithUser_idOnly = await prisma.user_credentials.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends user_credentialsFindManyArgs>(args?: SelectSubset<T, user_credentialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_credentials.
     * @param {user_credentialsCreateArgs} args - Arguments to create a User_credentials.
     * @example
     * // Create one User_credentials
     * const User_credentials = await prisma.user_credentials.create({
     *   data: {
     *     // ... data to create a User_credentials
     *   }
     * })
     * 
     */
    create<T extends user_credentialsCreateArgs>(args: SelectSubset<T, user_credentialsCreateArgs<ExtArgs>>): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_credentials.
     * @param {user_credentialsCreateManyArgs} args - Arguments to create many User_credentials.
     * @example
     * // Create many User_credentials
     * const user_credentials = await prisma.user_credentials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_credentialsCreateManyArgs>(args?: SelectSubset<T, user_credentialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_credentials and returns the data saved in the database.
     * @param {user_credentialsCreateManyAndReturnArgs} args - Arguments to create many User_credentials.
     * @example
     * // Create many User_credentials
     * const user_credentials = await prisma.user_credentials.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_credentials and only return the `user_id`
     * const user_credentialsWithUser_idOnly = await prisma.user_credentials.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_credentialsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_credentialsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_credentials.
     * @param {user_credentialsDeleteArgs} args - Arguments to delete one User_credentials.
     * @example
     * // Delete one User_credentials
     * const User_credentials = await prisma.user_credentials.delete({
     *   where: {
     *     // ... filter to delete one User_credentials
     *   }
     * })
     * 
     */
    delete<T extends user_credentialsDeleteArgs>(args: SelectSubset<T, user_credentialsDeleteArgs<ExtArgs>>): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_credentials.
     * @param {user_credentialsUpdateArgs} args - Arguments to update one User_credentials.
     * @example
     * // Update one User_credentials
     * const user_credentials = await prisma.user_credentials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_credentialsUpdateArgs>(args: SelectSubset<T, user_credentialsUpdateArgs<ExtArgs>>): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_credentials.
     * @param {user_credentialsDeleteManyArgs} args - Arguments to filter User_credentials to delete.
     * @example
     * // Delete a few User_credentials
     * const { count } = await prisma.user_credentials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_credentialsDeleteManyArgs>(args?: SelectSubset<T, user_credentialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credentialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_credentials
     * const user_credentials = await prisma.user_credentials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_credentialsUpdateManyArgs>(args: SelectSubset<T, user_credentialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_credentials and returns the data updated in the database.
     * @param {user_credentialsUpdateManyAndReturnArgs} args - Arguments to update many User_credentials.
     * @example
     * // Update many User_credentials
     * const user_credentials = await prisma.user_credentials.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_credentials and only return the `user_id`
     * const user_credentialsWithUser_idOnly = await prisma.user_credentials.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_credentialsUpdateManyAndReturnArgs>(args: SelectSubset<T, user_credentialsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_credentials.
     * @param {user_credentialsUpsertArgs} args - Arguments to update or create a User_credentials.
     * @example
     * // Update or create a User_credentials
     * const user_credentials = await prisma.user_credentials.upsert({
     *   create: {
     *     // ... data to create a User_credentials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_credentials we want to update
     *   }
     * })
     */
    upsert<T extends user_credentialsUpsertArgs>(args: SelectSubset<T, user_credentialsUpsertArgs<ExtArgs>>): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credentialsCountArgs} args - Arguments to filter User_credentials to count.
     * @example
     * // Count the number of User_credentials
     * const count = await prisma.user_credentials.count({
     *   where: {
     *     // ... the filter for the User_credentials we want to count
     *   }
     * })
    **/
    count<T extends user_credentialsCountArgs>(
      args?: Subset<T, user_credentialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_credentialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_credentialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_credentialsAggregateArgs>(args: Subset<T, User_credentialsAggregateArgs>): Prisma.PrismaPromise<GetUser_credentialsAggregateType<T>>

    /**
     * Group by User_credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credentialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_credentialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_credentialsGroupByArgs['orderBy'] }
        : { orderBy?: user_credentialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_credentialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_credentialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_credentials model
   */
  readonly fields: user_credentialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_credentials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_credentialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_credentials model
   */
  interface user_credentialsFieldRefs {
    readonly user_id: FieldRef<"user_credentials", 'Int'>
    readonly username: FieldRef<"user_credentials", 'String'>
    readonly password: FieldRef<"user_credentials", 'String'>
    readonly updated_on: FieldRef<"user_credentials", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_credentials findUnique
   */
  export type user_credentialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_credentials
     */
    omit?: user_credentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * Filter, which user_credentials to fetch.
     */
    where: user_credentialsWhereUniqueInput
  }

  /**
   * user_credentials findUniqueOrThrow
   */
  export type user_credentialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_credentials
     */
    omit?: user_credentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * Filter, which user_credentials to fetch.
     */
    where: user_credentialsWhereUniqueInput
  }

  /**
   * user_credentials findFirst
   */
  export type user_credentialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_credentials
     */
    omit?: user_credentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * Filter, which user_credentials to fetch.
     */
    where?: user_credentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_credentials to fetch.
     */
    orderBy?: user_credentialsOrderByWithRelationInput | user_credentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_credentials.
     */
    cursor?: user_credentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_credentials.
     */
    distinct?: User_credentialsScalarFieldEnum | User_credentialsScalarFieldEnum[]
  }

  /**
   * user_credentials findFirstOrThrow
   */
  export type user_credentialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_credentials
     */
    omit?: user_credentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * Filter, which user_credentials to fetch.
     */
    where?: user_credentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_credentials to fetch.
     */
    orderBy?: user_credentialsOrderByWithRelationInput | user_credentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_credentials.
     */
    cursor?: user_credentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_credentials.
     */
    distinct?: User_credentialsScalarFieldEnum | User_credentialsScalarFieldEnum[]
  }

  /**
   * user_credentials findMany
   */
  export type user_credentialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_credentials
     */
    omit?: user_credentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * Filter, which user_credentials to fetch.
     */
    where?: user_credentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_credentials to fetch.
     */
    orderBy?: user_credentialsOrderByWithRelationInput | user_credentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_credentials.
     */
    cursor?: user_credentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_credentials.
     */
    skip?: number
    distinct?: User_credentialsScalarFieldEnum | User_credentialsScalarFieldEnum[]
  }

  /**
   * user_credentials create
   */
  export type user_credentialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_credentials
     */
    omit?: user_credentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_credentials.
     */
    data: XOR<user_credentialsCreateInput, user_credentialsUncheckedCreateInput>
  }

  /**
   * user_credentials createMany
   */
  export type user_credentialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_credentials.
     */
    data: user_credentialsCreateManyInput | user_credentialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_credentials createManyAndReturn
   */
  export type user_credentialsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_credentials
     */
    omit?: user_credentialsOmit<ExtArgs> | null
    /**
     * The data used to create many user_credentials.
     */
    data: user_credentialsCreateManyInput | user_credentialsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_credentialsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_credentials update
   */
  export type user_credentialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_credentials
     */
    omit?: user_credentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_credentials.
     */
    data: XOR<user_credentialsUpdateInput, user_credentialsUncheckedUpdateInput>
    /**
     * Choose, which user_credentials to update.
     */
    where: user_credentialsWhereUniqueInput
  }

  /**
   * user_credentials updateMany
   */
  export type user_credentialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_credentials.
     */
    data: XOR<user_credentialsUpdateManyMutationInput, user_credentialsUncheckedUpdateManyInput>
    /**
     * Filter which user_credentials to update
     */
    where?: user_credentialsWhereInput
    /**
     * Limit how many user_credentials to update.
     */
    limit?: number
  }

  /**
   * user_credentials updateManyAndReturn
   */
  export type user_credentialsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_credentials
     */
    omit?: user_credentialsOmit<ExtArgs> | null
    /**
     * The data used to update user_credentials.
     */
    data: XOR<user_credentialsUpdateManyMutationInput, user_credentialsUncheckedUpdateManyInput>
    /**
     * Filter which user_credentials to update
     */
    where?: user_credentialsWhereInput
    /**
     * Limit how many user_credentials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_credentialsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_credentials upsert
   */
  export type user_credentialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_credentials
     */
    omit?: user_credentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_credentials to update in case it exists.
     */
    where: user_credentialsWhereUniqueInput
    /**
     * In case the user_credentials found by the `where` argument doesn't exist, create a new user_credentials with this data.
     */
    create: XOR<user_credentialsCreateInput, user_credentialsUncheckedCreateInput>
    /**
     * In case the user_credentials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_credentialsUpdateInput, user_credentialsUncheckedUpdateInput>
  }

  /**
   * user_credentials delete
   */
  export type user_credentialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_credentials
     */
    omit?: user_credentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * Filter which user_credentials to delete.
     */
    where: user_credentialsWhereUniqueInput
  }

  /**
   * user_credentials deleteMany
   */
  export type user_credentialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_credentials to delete
     */
    where?: user_credentialsWhereInput
    /**
     * Limit how many user_credentials to delete.
     */
    limit?: number
  }

  /**
   * user_credentials without action
   */
  export type user_credentialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_credentials
     */
    omit?: user_credentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_credentialsInclude<ExtArgs> | null
  }


  /**
   * Model user_role
   */

  export type AggregateUser_role = {
    _count: User_roleCountAggregateOutputType | null
    _avg: User_roleAvgAggregateOutputType | null
    _sum: User_roleSumAggregateOutputType | null
    _min: User_roleMinAggregateOutputType | null
    _max: User_roleMaxAggregateOutputType | null
  }

  export type User_roleAvgAggregateOutputType = {
    role_id: number | null
    user_access: number | null
  }

  export type User_roleSumAggregateOutputType = {
    role_id: number | null
    user_access: number[]
  }

  export type User_roleMinAggregateOutputType = {
    role_id: number | null
    role_name: string | null
    role_desc: string | null
  }

  export type User_roleMaxAggregateOutputType = {
    role_id: number | null
    role_name: string | null
    role_desc: string | null
  }

  export type User_roleCountAggregateOutputType = {
    role_id: number
    role_name: number
    role_desc: number
    user_access: number
    _all: number
  }


  export type User_roleAvgAggregateInputType = {
    role_id?: true
    user_access?: true
  }

  export type User_roleSumAggregateInputType = {
    role_id?: true
    user_access?: true
  }

  export type User_roleMinAggregateInputType = {
    role_id?: true
    role_name?: true
    role_desc?: true
  }

  export type User_roleMaxAggregateInputType = {
    role_id?: true
    role_name?: true
    role_desc?: true
  }

  export type User_roleCountAggregateInputType = {
    role_id?: true
    role_name?: true
    role_desc?: true
    user_access?: true
    _all?: true
  }

  export type User_roleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_role to aggregate.
     */
    where?: user_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_roleOrderByWithRelationInput | user_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_roles
    **/
    _count?: true | User_roleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_roleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_roleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_roleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_roleMaxAggregateInputType
  }

  export type GetUser_roleAggregateType<T extends User_roleAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_role]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_role[P]>
      : GetScalarType<T[P], AggregateUser_role[P]>
  }




  export type user_roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_roleWhereInput
    orderBy?: user_roleOrderByWithAggregationInput | user_roleOrderByWithAggregationInput[]
    by: User_roleScalarFieldEnum[] | User_roleScalarFieldEnum
    having?: user_roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_roleCountAggregateInputType | true
    _avg?: User_roleAvgAggregateInputType
    _sum?: User_roleSumAggregateInputType
    _min?: User_roleMinAggregateInputType
    _max?: User_roleMaxAggregateInputType
  }

  export type User_roleGroupByOutputType = {
    role_id: number
    role_name: string
    role_desc: string
    user_access: number[]
    _count: User_roleCountAggregateOutputType | null
    _avg: User_roleAvgAggregateOutputType | null
    _sum: User_roleSumAggregateOutputType | null
    _min: User_roleMinAggregateOutputType | null
    _max: User_roleMaxAggregateOutputType | null
  }

  type GetUser_roleGroupByPayload<T extends user_roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_roleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_roleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_roleGroupByOutputType[P]>
            : GetScalarType<T[P], User_roleGroupByOutputType[P]>
        }
      >
    >


  export type user_roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    role_name?: boolean
    role_desc?: boolean
    user_access?: boolean
    employee?: boolean | user_role$employeeArgs<ExtArgs>
    _count?: boolean | User_roleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_role"]>

  export type user_roleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    role_name?: boolean
    role_desc?: boolean
    user_access?: boolean
  }, ExtArgs["result"]["user_role"]>

  export type user_roleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    role_name?: boolean
    role_desc?: boolean
    user_access?: boolean
  }, ExtArgs["result"]["user_role"]>

  export type user_roleSelectScalar = {
    role_id?: boolean
    role_name?: boolean
    role_desc?: boolean
    user_access?: boolean
  }

  export type user_roleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"role_id" | "role_name" | "role_desc" | "user_access", ExtArgs["result"]["user_role"]>
  export type user_roleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | user_role$employeeArgs<ExtArgs>
    _count?: boolean | User_roleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type user_roleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type user_roleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $user_rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_role"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      role_id: number
      role_name: string
      role_desc: string
      user_access: number[]
    }, ExtArgs["result"]["user_role"]>
    composites: {}
  }

  type user_roleGetPayload<S extends boolean | null | undefined | user_roleDefaultArgs> = $Result.GetResult<Prisma.$user_rolePayload, S>

  type user_roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_roleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_roleCountAggregateInputType | true
    }

  export interface user_roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_role'], meta: { name: 'user_role' } }
    /**
     * Find zero or one User_role that matches the filter.
     * @param {user_roleFindUniqueArgs} args - Arguments to find a User_role
     * @example
     * // Get one User_role
     * const user_role = await prisma.user_role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_roleFindUniqueArgs>(args: SelectSubset<T, user_roleFindUniqueArgs<ExtArgs>>): Prisma__user_roleClient<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_roleFindUniqueOrThrowArgs} args - Arguments to find a User_role
     * @example
     * // Get one User_role
     * const user_role = await prisma.user_role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_roleFindUniqueOrThrowArgs>(args: SelectSubset<T, user_roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_roleClient<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_roleFindFirstArgs} args - Arguments to find a User_role
     * @example
     * // Get one User_role
     * const user_role = await prisma.user_role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_roleFindFirstArgs>(args?: SelectSubset<T, user_roleFindFirstArgs<ExtArgs>>): Prisma__user_roleClient<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_roleFindFirstOrThrowArgs} args - Arguments to find a User_role
     * @example
     * // Get one User_role
     * const user_role = await prisma.user_role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_roleFindFirstOrThrowArgs>(args?: SelectSubset<T, user_roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_roleClient<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_roles
     * const user_roles = await prisma.user_role.findMany()
     * 
     * // Get first 10 User_roles
     * const user_roles = await prisma.user_role.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const user_roleWithRole_idOnly = await prisma.user_role.findMany({ select: { role_id: true } })
     * 
     */
    findMany<T extends user_roleFindManyArgs>(args?: SelectSubset<T, user_roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_role.
     * @param {user_roleCreateArgs} args - Arguments to create a User_role.
     * @example
     * // Create one User_role
     * const User_role = await prisma.user_role.create({
     *   data: {
     *     // ... data to create a User_role
     *   }
     * })
     * 
     */
    create<T extends user_roleCreateArgs>(args: SelectSubset<T, user_roleCreateArgs<ExtArgs>>): Prisma__user_roleClient<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_roles.
     * @param {user_roleCreateManyArgs} args - Arguments to create many User_roles.
     * @example
     * // Create many User_roles
     * const user_role = await prisma.user_role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_roleCreateManyArgs>(args?: SelectSubset<T, user_roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_roles and returns the data saved in the database.
     * @param {user_roleCreateManyAndReturnArgs} args - Arguments to create many User_roles.
     * @example
     * // Create many User_roles
     * const user_role = await prisma.user_role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_roles and only return the `role_id`
     * const user_roleWithRole_idOnly = await prisma.user_role.createManyAndReturn({
     *   select: { role_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_roleCreateManyAndReturnArgs>(args?: SelectSubset<T, user_roleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_role.
     * @param {user_roleDeleteArgs} args - Arguments to delete one User_role.
     * @example
     * // Delete one User_role
     * const User_role = await prisma.user_role.delete({
     *   where: {
     *     // ... filter to delete one User_role
     *   }
     * })
     * 
     */
    delete<T extends user_roleDeleteArgs>(args: SelectSubset<T, user_roleDeleteArgs<ExtArgs>>): Prisma__user_roleClient<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_role.
     * @param {user_roleUpdateArgs} args - Arguments to update one User_role.
     * @example
     * // Update one User_role
     * const user_role = await prisma.user_role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_roleUpdateArgs>(args: SelectSubset<T, user_roleUpdateArgs<ExtArgs>>): Prisma__user_roleClient<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_roles.
     * @param {user_roleDeleteManyArgs} args - Arguments to filter User_roles to delete.
     * @example
     * // Delete a few User_roles
     * const { count } = await prisma.user_role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_roleDeleteManyArgs>(args?: SelectSubset<T, user_roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_roles
     * const user_role = await prisma.user_role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_roleUpdateManyArgs>(args: SelectSubset<T, user_roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_roles and returns the data updated in the database.
     * @param {user_roleUpdateManyAndReturnArgs} args - Arguments to update many User_roles.
     * @example
     * // Update many User_roles
     * const user_role = await prisma.user_role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_roles and only return the `role_id`
     * const user_roleWithRole_idOnly = await prisma.user_role.updateManyAndReturn({
     *   select: { role_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_roleUpdateManyAndReturnArgs>(args: SelectSubset<T, user_roleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_role.
     * @param {user_roleUpsertArgs} args - Arguments to update or create a User_role.
     * @example
     * // Update or create a User_role
     * const user_role = await prisma.user_role.upsert({
     *   create: {
     *     // ... data to create a User_role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_role we want to update
     *   }
     * })
     */
    upsert<T extends user_roleUpsertArgs>(args: SelectSubset<T, user_roleUpsertArgs<ExtArgs>>): Prisma__user_roleClient<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_roleCountArgs} args - Arguments to filter User_roles to count.
     * @example
     * // Count the number of User_roles
     * const count = await prisma.user_role.count({
     *   where: {
     *     // ... the filter for the User_roles we want to count
     *   }
     * })
    **/
    count<T extends user_roleCountArgs>(
      args?: Subset<T, user_roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_roleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_roleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_roleAggregateArgs>(args: Subset<T, User_roleAggregateArgs>): Prisma.PrismaPromise<GetUser_roleAggregateType<T>>

    /**
     * Group by User_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_roleGroupByArgs['orderBy'] }
        : { orderBy?: user_roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_roleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_role model
   */
  readonly fields: user_roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends user_role$employeeArgs<ExtArgs> = {}>(args?: Subset<T, user_role$employeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_role model
   */
  interface user_roleFieldRefs {
    readonly role_id: FieldRef<"user_role", 'Int'>
    readonly role_name: FieldRef<"user_role", 'String'>
    readonly role_desc: FieldRef<"user_role", 'String'>
    readonly user_access: FieldRef<"user_role", 'Int[]'>
  }
    

  // Custom InputTypes
  /**
   * user_role findUnique
   */
  export type user_roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_roleInclude<ExtArgs> | null
    /**
     * Filter, which user_role to fetch.
     */
    where: user_roleWhereUniqueInput
  }

  /**
   * user_role findUniqueOrThrow
   */
  export type user_roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_roleInclude<ExtArgs> | null
    /**
     * Filter, which user_role to fetch.
     */
    where: user_roleWhereUniqueInput
  }

  /**
   * user_role findFirst
   */
  export type user_roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_roleInclude<ExtArgs> | null
    /**
     * Filter, which user_role to fetch.
     */
    where?: user_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_roleOrderByWithRelationInput | user_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_roles.
     */
    cursor?: user_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_roles.
     */
    distinct?: User_roleScalarFieldEnum | User_roleScalarFieldEnum[]
  }

  /**
   * user_role findFirstOrThrow
   */
  export type user_roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_roleInclude<ExtArgs> | null
    /**
     * Filter, which user_role to fetch.
     */
    where?: user_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_roleOrderByWithRelationInput | user_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_roles.
     */
    cursor?: user_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_roles.
     */
    distinct?: User_roleScalarFieldEnum | User_roleScalarFieldEnum[]
  }

  /**
   * user_role findMany
   */
  export type user_roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_roleInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_roleOrderByWithRelationInput | user_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_roles.
     */
    cursor?: user_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    distinct?: User_roleScalarFieldEnum | User_roleScalarFieldEnum[]
  }

  /**
   * user_role create
   */
  export type user_roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_roleInclude<ExtArgs> | null
    /**
     * The data needed to create a user_role.
     */
    data: XOR<user_roleCreateInput, user_roleUncheckedCreateInput>
  }

  /**
   * user_role createMany
   */
  export type user_roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_roles.
     */
    data: user_roleCreateManyInput | user_roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_role createManyAndReturn
   */
  export type user_roleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * The data used to create many user_roles.
     */
    data: user_roleCreateManyInput | user_roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_role update
   */
  export type user_roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_roleInclude<ExtArgs> | null
    /**
     * The data needed to update a user_role.
     */
    data: XOR<user_roleUpdateInput, user_roleUncheckedUpdateInput>
    /**
     * Choose, which user_role to update.
     */
    where: user_roleWhereUniqueInput
  }

  /**
   * user_role updateMany
   */
  export type user_roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_roles.
     */
    data: XOR<user_roleUpdateManyMutationInput, user_roleUncheckedUpdateManyInput>
    /**
     * Filter which user_roles to update
     */
    where?: user_roleWhereInput
    /**
     * Limit how many user_roles to update.
     */
    limit?: number
  }

  /**
   * user_role updateManyAndReturn
   */
  export type user_roleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * The data used to update user_roles.
     */
    data: XOR<user_roleUpdateManyMutationInput, user_roleUncheckedUpdateManyInput>
    /**
     * Filter which user_roles to update
     */
    where?: user_roleWhereInput
    /**
     * Limit how many user_roles to update.
     */
    limit?: number
  }

  /**
   * user_role upsert
   */
  export type user_roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_roleInclude<ExtArgs> | null
    /**
     * The filter to search for the user_role to update in case it exists.
     */
    where: user_roleWhereUniqueInput
    /**
     * In case the user_role found by the `where` argument doesn't exist, create a new user_role with this data.
     */
    create: XOR<user_roleCreateInput, user_roleUncheckedCreateInput>
    /**
     * In case the user_role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_roleUpdateInput, user_roleUncheckedUpdateInput>
  }

  /**
   * user_role delete
   */
  export type user_roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_roleInclude<ExtArgs> | null
    /**
     * Filter which user_role to delete.
     */
    where: user_roleWhereUniqueInput
  }

  /**
   * user_role deleteMany
   */
  export type user_roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_roles to delete
     */
    where?: user_roleWhereInput
    /**
     * Limit how many user_roles to delete.
     */
    limit?: number
  }

  /**
   * user_role.employee
   */
  export type user_role$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    where?: employeeWhereInput
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    cursor?: employeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * user_role without action
   */
  export type user_roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_roleInclude<ExtArgs> | null
  }


  /**
   * Model variable_options
   */

  export type AggregateVariable_options = {
    _count: Variable_optionsCountAggregateOutputType | null
    _avg: Variable_optionsAvgAggregateOutputType | null
    _sum: Variable_optionsSumAggregateOutputType | null
    _min: Variable_optionsMinAggregateOutputType | null
    _max: Variable_optionsMaxAggregateOutputType | null
  }

  export type Variable_optionsAvgAggregateOutputType = {
    variable_id: number | null
    variable_value: Decimal | null
  }

  export type Variable_optionsSumAggregateOutputType = {
    variable_id: number | null
    variable_value: Decimal | null
  }

  export type Variable_optionsMinAggregateOutputType = {
    variable_id: number | null
    variable_name: string | null
    created_at: Date | null
    variable_value: Decimal | null
    updated_on: Date | null
  }

  export type Variable_optionsMaxAggregateOutputType = {
    variable_id: number | null
    variable_name: string | null
    created_at: Date | null
    variable_value: Decimal | null
    updated_on: Date | null
  }

  export type Variable_optionsCountAggregateOutputType = {
    variable_id: number
    variable_name: number
    created_at: number
    variable_value: number
    updated_on: number
    _all: number
  }


  export type Variable_optionsAvgAggregateInputType = {
    variable_id?: true
    variable_value?: true
  }

  export type Variable_optionsSumAggregateInputType = {
    variable_id?: true
    variable_value?: true
  }

  export type Variable_optionsMinAggregateInputType = {
    variable_id?: true
    variable_name?: true
    created_at?: true
    variable_value?: true
    updated_on?: true
  }

  export type Variable_optionsMaxAggregateInputType = {
    variable_id?: true
    variable_name?: true
    created_at?: true
    variable_value?: true
    updated_on?: true
  }

  export type Variable_optionsCountAggregateInputType = {
    variable_id?: true
    variable_name?: true
    created_at?: true
    variable_value?: true
    updated_on?: true
    _all?: true
  }

  export type Variable_optionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which variable_options to aggregate.
     */
    where?: variable_optionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of variable_options to fetch.
     */
    orderBy?: variable_optionsOrderByWithRelationInput | variable_optionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: variable_optionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` variable_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` variable_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned variable_options
    **/
    _count?: true | Variable_optionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Variable_optionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Variable_optionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Variable_optionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Variable_optionsMaxAggregateInputType
  }

  export type GetVariable_optionsAggregateType<T extends Variable_optionsAggregateArgs> = {
        [P in keyof T & keyof AggregateVariable_options]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariable_options[P]>
      : GetScalarType<T[P], AggregateVariable_options[P]>
  }




  export type variable_optionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: variable_optionsWhereInput
    orderBy?: variable_optionsOrderByWithAggregationInput | variable_optionsOrderByWithAggregationInput[]
    by: Variable_optionsScalarFieldEnum[] | Variable_optionsScalarFieldEnum
    having?: variable_optionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Variable_optionsCountAggregateInputType | true
    _avg?: Variable_optionsAvgAggregateInputType
    _sum?: Variable_optionsSumAggregateInputType
    _min?: Variable_optionsMinAggregateInputType
    _max?: Variable_optionsMaxAggregateInputType
  }

  export type Variable_optionsGroupByOutputType = {
    variable_id: number
    variable_name: string
    created_at: Date | null
    variable_value: Decimal | null
    updated_on: Date | null
    _count: Variable_optionsCountAggregateOutputType | null
    _avg: Variable_optionsAvgAggregateOutputType | null
    _sum: Variable_optionsSumAggregateOutputType | null
    _min: Variable_optionsMinAggregateOutputType | null
    _max: Variable_optionsMaxAggregateOutputType | null
  }

  type GetVariable_optionsGroupByPayload<T extends variable_optionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Variable_optionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Variable_optionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Variable_optionsGroupByOutputType[P]>
            : GetScalarType<T[P], Variable_optionsGroupByOutputType[P]>
        }
      >
    >


  export type variable_optionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    variable_id?: boolean
    variable_name?: boolean
    created_at?: boolean
    variable_value?: boolean
    updated_on?: boolean
  }, ExtArgs["result"]["variable_options"]>

  export type variable_optionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    variable_id?: boolean
    variable_name?: boolean
    created_at?: boolean
    variable_value?: boolean
    updated_on?: boolean
  }, ExtArgs["result"]["variable_options"]>

  export type variable_optionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    variable_id?: boolean
    variable_name?: boolean
    created_at?: boolean
    variable_value?: boolean
    updated_on?: boolean
  }, ExtArgs["result"]["variable_options"]>

  export type variable_optionsSelectScalar = {
    variable_id?: boolean
    variable_name?: boolean
    created_at?: boolean
    variable_value?: boolean
    updated_on?: boolean
  }

  export type variable_optionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"variable_id" | "variable_name" | "created_at" | "variable_value" | "updated_on", ExtArgs["result"]["variable_options"]>

  export type $variable_optionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "variable_options"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      variable_id: number
      variable_name: string
      created_at: Date | null
      variable_value: Prisma.Decimal | null
      updated_on: Date | null
    }, ExtArgs["result"]["variable_options"]>
    composites: {}
  }

  type variable_optionsGetPayload<S extends boolean | null | undefined | variable_optionsDefaultArgs> = $Result.GetResult<Prisma.$variable_optionsPayload, S>

  type variable_optionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<variable_optionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Variable_optionsCountAggregateInputType | true
    }

  export interface variable_optionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['variable_options'], meta: { name: 'variable_options' } }
    /**
     * Find zero or one Variable_options that matches the filter.
     * @param {variable_optionsFindUniqueArgs} args - Arguments to find a Variable_options
     * @example
     * // Get one Variable_options
     * const variable_options = await prisma.variable_options.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends variable_optionsFindUniqueArgs>(args: SelectSubset<T, variable_optionsFindUniqueArgs<ExtArgs>>): Prisma__variable_optionsClient<$Result.GetResult<Prisma.$variable_optionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Variable_options that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {variable_optionsFindUniqueOrThrowArgs} args - Arguments to find a Variable_options
     * @example
     * // Get one Variable_options
     * const variable_options = await prisma.variable_options.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends variable_optionsFindUniqueOrThrowArgs>(args: SelectSubset<T, variable_optionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__variable_optionsClient<$Result.GetResult<Prisma.$variable_optionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Variable_options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variable_optionsFindFirstArgs} args - Arguments to find a Variable_options
     * @example
     * // Get one Variable_options
     * const variable_options = await prisma.variable_options.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends variable_optionsFindFirstArgs>(args?: SelectSubset<T, variable_optionsFindFirstArgs<ExtArgs>>): Prisma__variable_optionsClient<$Result.GetResult<Prisma.$variable_optionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Variable_options that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variable_optionsFindFirstOrThrowArgs} args - Arguments to find a Variable_options
     * @example
     * // Get one Variable_options
     * const variable_options = await prisma.variable_options.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends variable_optionsFindFirstOrThrowArgs>(args?: SelectSubset<T, variable_optionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__variable_optionsClient<$Result.GetResult<Prisma.$variable_optionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Variable_options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variable_optionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Variable_options
     * const variable_options = await prisma.variable_options.findMany()
     * 
     * // Get first 10 Variable_options
     * const variable_options = await prisma.variable_options.findMany({ take: 10 })
     * 
     * // Only select the `variable_id`
     * const variable_optionsWithVariable_idOnly = await prisma.variable_options.findMany({ select: { variable_id: true } })
     * 
     */
    findMany<T extends variable_optionsFindManyArgs>(args?: SelectSubset<T, variable_optionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$variable_optionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Variable_options.
     * @param {variable_optionsCreateArgs} args - Arguments to create a Variable_options.
     * @example
     * // Create one Variable_options
     * const Variable_options = await prisma.variable_options.create({
     *   data: {
     *     // ... data to create a Variable_options
     *   }
     * })
     * 
     */
    create<T extends variable_optionsCreateArgs>(args: SelectSubset<T, variable_optionsCreateArgs<ExtArgs>>): Prisma__variable_optionsClient<$Result.GetResult<Prisma.$variable_optionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Variable_options.
     * @param {variable_optionsCreateManyArgs} args - Arguments to create many Variable_options.
     * @example
     * // Create many Variable_options
     * const variable_options = await prisma.variable_options.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends variable_optionsCreateManyArgs>(args?: SelectSubset<T, variable_optionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Variable_options and returns the data saved in the database.
     * @param {variable_optionsCreateManyAndReturnArgs} args - Arguments to create many Variable_options.
     * @example
     * // Create many Variable_options
     * const variable_options = await prisma.variable_options.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Variable_options and only return the `variable_id`
     * const variable_optionsWithVariable_idOnly = await prisma.variable_options.createManyAndReturn({
     *   select: { variable_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends variable_optionsCreateManyAndReturnArgs>(args?: SelectSubset<T, variable_optionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$variable_optionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Variable_options.
     * @param {variable_optionsDeleteArgs} args - Arguments to delete one Variable_options.
     * @example
     * // Delete one Variable_options
     * const Variable_options = await prisma.variable_options.delete({
     *   where: {
     *     // ... filter to delete one Variable_options
     *   }
     * })
     * 
     */
    delete<T extends variable_optionsDeleteArgs>(args: SelectSubset<T, variable_optionsDeleteArgs<ExtArgs>>): Prisma__variable_optionsClient<$Result.GetResult<Prisma.$variable_optionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Variable_options.
     * @param {variable_optionsUpdateArgs} args - Arguments to update one Variable_options.
     * @example
     * // Update one Variable_options
     * const variable_options = await prisma.variable_options.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends variable_optionsUpdateArgs>(args: SelectSubset<T, variable_optionsUpdateArgs<ExtArgs>>): Prisma__variable_optionsClient<$Result.GetResult<Prisma.$variable_optionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Variable_options.
     * @param {variable_optionsDeleteManyArgs} args - Arguments to filter Variable_options to delete.
     * @example
     * // Delete a few Variable_options
     * const { count } = await prisma.variable_options.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends variable_optionsDeleteManyArgs>(args?: SelectSubset<T, variable_optionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variable_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variable_optionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Variable_options
     * const variable_options = await prisma.variable_options.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends variable_optionsUpdateManyArgs>(args: SelectSubset<T, variable_optionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variable_options and returns the data updated in the database.
     * @param {variable_optionsUpdateManyAndReturnArgs} args - Arguments to update many Variable_options.
     * @example
     * // Update many Variable_options
     * const variable_options = await prisma.variable_options.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Variable_options and only return the `variable_id`
     * const variable_optionsWithVariable_idOnly = await prisma.variable_options.updateManyAndReturn({
     *   select: { variable_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends variable_optionsUpdateManyAndReturnArgs>(args: SelectSubset<T, variable_optionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$variable_optionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Variable_options.
     * @param {variable_optionsUpsertArgs} args - Arguments to update or create a Variable_options.
     * @example
     * // Update or create a Variable_options
     * const variable_options = await prisma.variable_options.upsert({
     *   create: {
     *     // ... data to create a Variable_options
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Variable_options we want to update
     *   }
     * })
     */
    upsert<T extends variable_optionsUpsertArgs>(args: SelectSubset<T, variable_optionsUpsertArgs<ExtArgs>>): Prisma__variable_optionsClient<$Result.GetResult<Prisma.$variable_optionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Variable_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variable_optionsCountArgs} args - Arguments to filter Variable_options to count.
     * @example
     * // Count the number of Variable_options
     * const count = await prisma.variable_options.count({
     *   where: {
     *     // ... the filter for the Variable_options we want to count
     *   }
     * })
    **/
    count<T extends variable_optionsCountArgs>(
      args?: Subset<T, variable_optionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Variable_optionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Variable_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Variable_optionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Variable_optionsAggregateArgs>(args: Subset<T, Variable_optionsAggregateArgs>): Prisma.PrismaPromise<GetVariable_optionsAggregateType<T>>

    /**
     * Group by Variable_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variable_optionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends variable_optionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: variable_optionsGroupByArgs['orderBy'] }
        : { orderBy?: variable_optionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, variable_optionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariable_optionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the variable_options model
   */
  readonly fields: variable_optionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for variable_options.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__variable_optionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the variable_options model
   */
  interface variable_optionsFieldRefs {
    readonly variable_id: FieldRef<"variable_options", 'Int'>
    readonly variable_name: FieldRef<"variable_options", 'String'>
    readonly created_at: FieldRef<"variable_options", 'DateTime'>
    readonly variable_value: FieldRef<"variable_options", 'Decimal'>
    readonly updated_on: FieldRef<"variable_options", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * variable_options findUnique
   */
  export type variable_optionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variable_options
     */
    select?: variable_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variable_options
     */
    omit?: variable_optionsOmit<ExtArgs> | null
    /**
     * Filter, which variable_options to fetch.
     */
    where: variable_optionsWhereUniqueInput
  }

  /**
   * variable_options findUniqueOrThrow
   */
  export type variable_optionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variable_options
     */
    select?: variable_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variable_options
     */
    omit?: variable_optionsOmit<ExtArgs> | null
    /**
     * Filter, which variable_options to fetch.
     */
    where: variable_optionsWhereUniqueInput
  }

  /**
   * variable_options findFirst
   */
  export type variable_optionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variable_options
     */
    select?: variable_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variable_options
     */
    omit?: variable_optionsOmit<ExtArgs> | null
    /**
     * Filter, which variable_options to fetch.
     */
    where?: variable_optionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of variable_options to fetch.
     */
    orderBy?: variable_optionsOrderByWithRelationInput | variable_optionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for variable_options.
     */
    cursor?: variable_optionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` variable_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` variable_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of variable_options.
     */
    distinct?: Variable_optionsScalarFieldEnum | Variable_optionsScalarFieldEnum[]
  }

  /**
   * variable_options findFirstOrThrow
   */
  export type variable_optionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variable_options
     */
    select?: variable_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variable_options
     */
    omit?: variable_optionsOmit<ExtArgs> | null
    /**
     * Filter, which variable_options to fetch.
     */
    where?: variable_optionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of variable_options to fetch.
     */
    orderBy?: variable_optionsOrderByWithRelationInput | variable_optionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for variable_options.
     */
    cursor?: variable_optionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` variable_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` variable_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of variable_options.
     */
    distinct?: Variable_optionsScalarFieldEnum | Variable_optionsScalarFieldEnum[]
  }

  /**
   * variable_options findMany
   */
  export type variable_optionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variable_options
     */
    select?: variable_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variable_options
     */
    omit?: variable_optionsOmit<ExtArgs> | null
    /**
     * Filter, which variable_options to fetch.
     */
    where?: variable_optionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of variable_options to fetch.
     */
    orderBy?: variable_optionsOrderByWithRelationInput | variable_optionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing variable_options.
     */
    cursor?: variable_optionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` variable_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` variable_options.
     */
    skip?: number
    distinct?: Variable_optionsScalarFieldEnum | Variable_optionsScalarFieldEnum[]
  }

  /**
   * variable_options create
   */
  export type variable_optionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variable_options
     */
    select?: variable_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variable_options
     */
    omit?: variable_optionsOmit<ExtArgs> | null
    /**
     * The data needed to create a variable_options.
     */
    data: XOR<variable_optionsCreateInput, variable_optionsUncheckedCreateInput>
  }

  /**
   * variable_options createMany
   */
  export type variable_optionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many variable_options.
     */
    data: variable_optionsCreateManyInput | variable_optionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * variable_options createManyAndReturn
   */
  export type variable_optionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variable_options
     */
    select?: variable_optionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the variable_options
     */
    omit?: variable_optionsOmit<ExtArgs> | null
    /**
     * The data used to create many variable_options.
     */
    data: variable_optionsCreateManyInput | variable_optionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * variable_options update
   */
  export type variable_optionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variable_options
     */
    select?: variable_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variable_options
     */
    omit?: variable_optionsOmit<ExtArgs> | null
    /**
     * The data needed to update a variable_options.
     */
    data: XOR<variable_optionsUpdateInput, variable_optionsUncheckedUpdateInput>
    /**
     * Choose, which variable_options to update.
     */
    where: variable_optionsWhereUniqueInput
  }

  /**
   * variable_options updateMany
   */
  export type variable_optionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update variable_options.
     */
    data: XOR<variable_optionsUpdateManyMutationInput, variable_optionsUncheckedUpdateManyInput>
    /**
     * Filter which variable_options to update
     */
    where?: variable_optionsWhereInput
    /**
     * Limit how many variable_options to update.
     */
    limit?: number
  }

  /**
   * variable_options updateManyAndReturn
   */
  export type variable_optionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variable_options
     */
    select?: variable_optionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the variable_options
     */
    omit?: variable_optionsOmit<ExtArgs> | null
    /**
     * The data used to update variable_options.
     */
    data: XOR<variable_optionsUpdateManyMutationInput, variable_optionsUncheckedUpdateManyInput>
    /**
     * Filter which variable_options to update
     */
    where?: variable_optionsWhereInput
    /**
     * Limit how many variable_options to update.
     */
    limit?: number
  }

  /**
   * variable_options upsert
   */
  export type variable_optionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variable_options
     */
    select?: variable_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variable_options
     */
    omit?: variable_optionsOmit<ExtArgs> | null
    /**
     * The filter to search for the variable_options to update in case it exists.
     */
    where: variable_optionsWhereUniqueInput
    /**
     * In case the variable_options found by the `where` argument doesn't exist, create a new variable_options with this data.
     */
    create: XOR<variable_optionsCreateInput, variable_optionsUncheckedCreateInput>
    /**
     * In case the variable_options was found with the provided `where` argument, update it with this data.
     */
    update: XOR<variable_optionsUpdateInput, variable_optionsUncheckedUpdateInput>
  }

  /**
   * variable_options delete
   */
  export type variable_optionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variable_options
     */
    select?: variable_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variable_options
     */
    omit?: variable_optionsOmit<ExtArgs> | null
    /**
     * Filter which variable_options to delete.
     */
    where: variable_optionsWhereUniqueInput
  }

  /**
   * variable_options deleteMany
   */
  export type variable_optionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which variable_options to delete
     */
    where?: variable_optionsWhereInput
    /**
     * Limit how many variable_options to delete.
     */
    limit?: number
  }

  /**
   * variable_options without action
   */
  export type variable_optionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variable_options
     */
    select?: variable_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variable_options
     */
    omit?: variable_optionsOmit<ExtArgs> | null
  }


  /**
   * Model working_hour
   */

  export type AggregateWorking_hour = {
    _count: Working_hourCountAggregateOutputType | null
    _avg: Working_hourAvgAggregateOutputType | null
    _sum: Working_hourSumAggregateOutputType | null
    _min: Working_hourMinAggregateOutputType | null
    _max: Working_hourMaxAggregateOutputType | null
  }

  export type Working_hourAvgAggregateOutputType = {
    employee_id: number | null
    updated_by: number | null
    total_hours: Decimal | null
  }

  export type Working_hourSumAggregateOutputType = {
    employee_id: number | null
    updated_by: number | null
    total_hours: Decimal | null
  }

  export type Working_hourMinAggregateOutputType = {
    employee_id: number | null
    branch_id: string | null
    date: string | null
    shift_on: string | null
    shift_off: string | null
    updated_by: number | null
    present: boolean | null
    total_hours: Decimal | null
  }

  export type Working_hourMaxAggregateOutputType = {
    employee_id: number | null
    branch_id: string | null
    date: string | null
    shift_on: string | null
    shift_off: string | null
    updated_by: number | null
    present: boolean | null
    total_hours: Decimal | null
  }

  export type Working_hourCountAggregateOutputType = {
    employee_id: number
    branch_id: number
    date: number
    shift_on: number
    shift_off: number
    updated_by: number
    present: number
    total_hours: number
    _all: number
  }


  export type Working_hourAvgAggregateInputType = {
    employee_id?: true
    updated_by?: true
    total_hours?: true
  }

  export type Working_hourSumAggregateInputType = {
    employee_id?: true
    updated_by?: true
    total_hours?: true
  }

  export type Working_hourMinAggregateInputType = {
    employee_id?: true
    branch_id?: true
    date?: true
    shift_on?: true
    shift_off?: true
    updated_by?: true
    present?: true
    total_hours?: true
  }

  export type Working_hourMaxAggregateInputType = {
    employee_id?: true
    branch_id?: true
    date?: true
    shift_on?: true
    shift_off?: true
    updated_by?: true
    present?: true
    total_hours?: true
  }

  export type Working_hourCountAggregateInputType = {
    employee_id?: true
    branch_id?: true
    date?: true
    shift_on?: true
    shift_off?: true
    updated_by?: true
    present?: true
    total_hours?: true
    _all?: true
  }

  export type Working_hourAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which working_hour to aggregate.
     */
    where?: working_hourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of working_hours to fetch.
     */
    orderBy?: working_hourOrderByWithRelationInput | working_hourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: working_hourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` working_hours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` working_hours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned working_hours
    **/
    _count?: true | Working_hourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Working_hourAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Working_hourSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Working_hourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Working_hourMaxAggregateInputType
  }

  export type GetWorking_hourAggregateType<T extends Working_hourAggregateArgs> = {
        [P in keyof T & keyof AggregateWorking_hour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorking_hour[P]>
      : GetScalarType<T[P], AggregateWorking_hour[P]>
  }




  export type working_hourGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: working_hourWhereInput
    orderBy?: working_hourOrderByWithAggregationInput | working_hourOrderByWithAggregationInput[]
    by: Working_hourScalarFieldEnum[] | Working_hourScalarFieldEnum
    having?: working_hourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Working_hourCountAggregateInputType | true
    _avg?: Working_hourAvgAggregateInputType
    _sum?: Working_hourSumAggregateInputType
    _min?: Working_hourMinAggregateInputType
    _max?: Working_hourMaxAggregateInputType
  }

  export type Working_hourGroupByOutputType = {
    employee_id: number
    branch_id: string
    date: string
    shift_on: string
    shift_off: string
    updated_by: number
    present: boolean
    total_hours: Decimal | null
    _count: Working_hourCountAggregateOutputType | null
    _avg: Working_hourAvgAggregateOutputType | null
    _sum: Working_hourSumAggregateOutputType | null
    _min: Working_hourMinAggregateOutputType | null
    _max: Working_hourMaxAggregateOutputType | null
  }

  type GetWorking_hourGroupByPayload<T extends working_hourGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Working_hourGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Working_hourGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Working_hourGroupByOutputType[P]>
            : GetScalarType<T[P], Working_hourGroupByOutputType[P]>
        }
      >
    >


  export type working_hourSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employee_id?: boolean
    branch_id?: boolean
    date?: boolean
    shift_on?: boolean
    shift_off?: boolean
    updated_by?: boolean
    present?: boolean
    total_hours?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    marked_by?: boolean | employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["working_hour"]>

  export type working_hourSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employee_id?: boolean
    branch_id?: boolean
    date?: boolean
    shift_on?: boolean
    shift_off?: boolean
    updated_by?: boolean
    present?: boolean
    total_hours?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    marked_by?: boolean | employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["working_hour"]>

  export type working_hourSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employee_id?: boolean
    branch_id?: boolean
    date?: boolean
    shift_on?: boolean
    shift_off?: boolean
    updated_by?: boolean
    present?: boolean
    total_hours?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    marked_by?: boolean | employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["working_hour"]>

  export type working_hourSelectScalar = {
    employee_id?: boolean
    branch_id?: boolean
    date?: boolean
    shift_on?: boolean
    shift_off?: boolean
    updated_by?: boolean
    present?: boolean
    total_hours?: boolean
  }

  export type working_hourOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"employee_id" | "branch_id" | "date" | "shift_on" | "shift_off" | "updated_by" | "present" | "total_hours", ExtArgs["result"]["working_hour"]>
  export type working_hourInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    marked_by?: boolean | employeeDefaultArgs<ExtArgs>
  }
  export type working_hourIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    marked_by?: boolean | employeeDefaultArgs<ExtArgs>
  }
  export type working_hourIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    marked_by?: boolean | employeeDefaultArgs<ExtArgs>
  }

  export type $working_hourPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "working_hour"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>
      marked_by: Prisma.$employeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      employee_id: number
      branch_id: string
      date: string
      shift_on: string
      shift_off: string
      updated_by: number
      present: boolean
      total_hours: Prisma.Decimal | null
    }, ExtArgs["result"]["working_hour"]>
    composites: {}
  }

  type working_hourGetPayload<S extends boolean | null | undefined | working_hourDefaultArgs> = $Result.GetResult<Prisma.$working_hourPayload, S>

  type working_hourCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<working_hourFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Working_hourCountAggregateInputType | true
    }

  export interface working_hourDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['working_hour'], meta: { name: 'working_hour' } }
    /**
     * Find zero or one Working_hour that matches the filter.
     * @param {working_hourFindUniqueArgs} args - Arguments to find a Working_hour
     * @example
     * // Get one Working_hour
     * const working_hour = await prisma.working_hour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends working_hourFindUniqueArgs>(args: SelectSubset<T, working_hourFindUniqueArgs<ExtArgs>>): Prisma__working_hourClient<$Result.GetResult<Prisma.$working_hourPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Working_hour that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {working_hourFindUniqueOrThrowArgs} args - Arguments to find a Working_hour
     * @example
     * // Get one Working_hour
     * const working_hour = await prisma.working_hour.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends working_hourFindUniqueOrThrowArgs>(args: SelectSubset<T, working_hourFindUniqueOrThrowArgs<ExtArgs>>): Prisma__working_hourClient<$Result.GetResult<Prisma.$working_hourPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Working_hour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {working_hourFindFirstArgs} args - Arguments to find a Working_hour
     * @example
     * // Get one Working_hour
     * const working_hour = await prisma.working_hour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends working_hourFindFirstArgs>(args?: SelectSubset<T, working_hourFindFirstArgs<ExtArgs>>): Prisma__working_hourClient<$Result.GetResult<Prisma.$working_hourPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Working_hour that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {working_hourFindFirstOrThrowArgs} args - Arguments to find a Working_hour
     * @example
     * // Get one Working_hour
     * const working_hour = await prisma.working_hour.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends working_hourFindFirstOrThrowArgs>(args?: SelectSubset<T, working_hourFindFirstOrThrowArgs<ExtArgs>>): Prisma__working_hourClient<$Result.GetResult<Prisma.$working_hourPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Working_hours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {working_hourFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Working_hours
     * const working_hours = await prisma.working_hour.findMany()
     * 
     * // Get first 10 Working_hours
     * const working_hours = await prisma.working_hour.findMany({ take: 10 })
     * 
     * // Only select the `employee_id`
     * const working_hourWithEmployee_idOnly = await prisma.working_hour.findMany({ select: { employee_id: true } })
     * 
     */
    findMany<T extends working_hourFindManyArgs>(args?: SelectSubset<T, working_hourFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$working_hourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Working_hour.
     * @param {working_hourCreateArgs} args - Arguments to create a Working_hour.
     * @example
     * // Create one Working_hour
     * const Working_hour = await prisma.working_hour.create({
     *   data: {
     *     // ... data to create a Working_hour
     *   }
     * })
     * 
     */
    create<T extends working_hourCreateArgs>(args: SelectSubset<T, working_hourCreateArgs<ExtArgs>>): Prisma__working_hourClient<$Result.GetResult<Prisma.$working_hourPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Working_hours.
     * @param {working_hourCreateManyArgs} args - Arguments to create many Working_hours.
     * @example
     * // Create many Working_hours
     * const working_hour = await prisma.working_hour.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends working_hourCreateManyArgs>(args?: SelectSubset<T, working_hourCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Working_hours and returns the data saved in the database.
     * @param {working_hourCreateManyAndReturnArgs} args - Arguments to create many Working_hours.
     * @example
     * // Create many Working_hours
     * const working_hour = await prisma.working_hour.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Working_hours and only return the `employee_id`
     * const working_hourWithEmployee_idOnly = await prisma.working_hour.createManyAndReturn({
     *   select: { employee_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends working_hourCreateManyAndReturnArgs>(args?: SelectSubset<T, working_hourCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$working_hourPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Working_hour.
     * @param {working_hourDeleteArgs} args - Arguments to delete one Working_hour.
     * @example
     * // Delete one Working_hour
     * const Working_hour = await prisma.working_hour.delete({
     *   where: {
     *     // ... filter to delete one Working_hour
     *   }
     * })
     * 
     */
    delete<T extends working_hourDeleteArgs>(args: SelectSubset<T, working_hourDeleteArgs<ExtArgs>>): Prisma__working_hourClient<$Result.GetResult<Prisma.$working_hourPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Working_hour.
     * @param {working_hourUpdateArgs} args - Arguments to update one Working_hour.
     * @example
     * // Update one Working_hour
     * const working_hour = await prisma.working_hour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends working_hourUpdateArgs>(args: SelectSubset<T, working_hourUpdateArgs<ExtArgs>>): Prisma__working_hourClient<$Result.GetResult<Prisma.$working_hourPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Working_hours.
     * @param {working_hourDeleteManyArgs} args - Arguments to filter Working_hours to delete.
     * @example
     * // Delete a few Working_hours
     * const { count } = await prisma.working_hour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends working_hourDeleteManyArgs>(args?: SelectSubset<T, working_hourDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Working_hours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {working_hourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Working_hours
     * const working_hour = await prisma.working_hour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends working_hourUpdateManyArgs>(args: SelectSubset<T, working_hourUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Working_hours and returns the data updated in the database.
     * @param {working_hourUpdateManyAndReturnArgs} args - Arguments to update many Working_hours.
     * @example
     * // Update many Working_hours
     * const working_hour = await prisma.working_hour.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Working_hours and only return the `employee_id`
     * const working_hourWithEmployee_idOnly = await prisma.working_hour.updateManyAndReturn({
     *   select: { employee_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends working_hourUpdateManyAndReturnArgs>(args: SelectSubset<T, working_hourUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$working_hourPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Working_hour.
     * @param {working_hourUpsertArgs} args - Arguments to update or create a Working_hour.
     * @example
     * // Update or create a Working_hour
     * const working_hour = await prisma.working_hour.upsert({
     *   create: {
     *     // ... data to create a Working_hour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Working_hour we want to update
     *   }
     * })
     */
    upsert<T extends working_hourUpsertArgs>(args: SelectSubset<T, working_hourUpsertArgs<ExtArgs>>): Prisma__working_hourClient<$Result.GetResult<Prisma.$working_hourPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Working_hours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {working_hourCountArgs} args - Arguments to filter Working_hours to count.
     * @example
     * // Count the number of Working_hours
     * const count = await prisma.working_hour.count({
     *   where: {
     *     // ... the filter for the Working_hours we want to count
     *   }
     * })
    **/
    count<T extends working_hourCountArgs>(
      args?: Subset<T, working_hourCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Working_hourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Working_hour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Working_hourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Working_hourAggregateArgs>(args: Subset<T, Working_hourAggregateArgs>): Prisma.PrismaPromise<GetWorking_hourAggregateType<T>>

    /**
     * Group by Working_hour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {working_hourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends working_hourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: working_hourGroupByArgs['orderBy'] }
        : { orderBy?: working_hourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, working_hourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorking_hourGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the working_hour model
   */
  readonly fields: working_hourFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for working_hour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__working_hourClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    marked_by<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the working_hour model
   */
  interface working_hourFieldRefs {
    readonly employee_id: FieldRef<"working_hour", 'Int'>
    readonly branch_id: FieldRef<"working_hour", 'String'>
    readonly date: FieldRef<"working_hour", 'String'>
    readonly shift_on: FieldRef<"working_hour", 'String'>
    readonly shift_off: FieldRef<"working_hour", 'String'>
    readonly updated_by: FieldRef<"working_hour", 'Int'>
    readonly present: FieldRef<"working_hour", 'Boolean'>
    readonly total_hours: FieldRef<"working_hour", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * working_hour findUnique
   */
  export type working_hourFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the working_hour
     */
    select?: working_hourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the working_hour
     */
    omit?: working_hourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: working_hourInclude<ExtArgs> | null
    /**
     * Filter, which working_hour to fetch.
     */
    where: working_hourWhereUniqueInput
  }

  /**
   * working_hour findUniqueOrThrow
   */
  export type working_hourFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the working_hour
     */
    select?: working_hourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the working_hour
     */
    omit?: working_hourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: working_hourInclude<ExtArgs> | null
    /**
     * Filter, which working_hour to fetch.
     */
    where: working_hourWhereUniqueInput
  }

  /**
   * working_hour findFirst
   */
  export type working_hourFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the working_hour
     */
    select?: working_hourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the working_hour
     */
    omit?: working_hourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: working_hourInclude<ExtArgs> | null
    /**
     * Filter, which working_hour to fetch.
     */
    where?: working_hourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of working_hours to fetch.
     */
    orderBy?: working_hourOrderByWithRelationInput | working_hourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for working_hours.
     */
    cursor?: working_hourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` working_hours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` working_hours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of working_hours.
     */
    distinct?: Working_hourScalarFieldEnum | Working_hourScalarFieldEnum[]
  }

  /**
   * working_hour findFirstOrThrow
   */
  export type working_hourFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the working_hour
     */
    select?: working_hourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the working_hour
     */
    omit?: working_hourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: working_hourInclude<ExtArgs> | null
    /**
     * Filter, which working_hour to fetch.
     */
    where?: working_hourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of working_hours to fetch.
     */
    orderBy?: working_hourOrderByWithRelationInput | working_hourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for working_hours.
     */
    cursor?: working_hourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` working_hours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` working_hours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of working_hours.
     */
    distinct?: Working_hourScalarFieldEnum | Working_hourScalarFieldEnum[]
  }

  /**
   * working_hour findMany
   */
  export type working_hourFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the working_hour
     */
    select?: working_hourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the working_hour
     */
    omit?: working_hourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: working_hourInclude<ExtArgs> | null
    /**
     * Filter, which working_hours to fetch.
     */
    where?: working_hourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of working_hours to fetch.
     */
    orderBy?: working_hourOrderByWithRelationInput | working_hourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing working_hours.
     */
    cursor?: working_hourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` working_hours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` working_hours.
     */
    skip?: number
    distinct?: Working_hourScalarFieldEnum | Working_hourScalarFieldEnum[]
  }

  /**
   * working_hour create
   */
  export type working_hourCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the working_hour
     */
    select?: working_hourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the working_hour
     */
    omit?: working_hourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: working_hourInclude<ExtArgs> | null
    /**
     * The data needed to create a working_hour.
     */
    data: XOR<working_hourCreateInput, working_hourUncheckedCreateInput>
  }

  /**
   * working_hour createMany
   */
  export type working_hourCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many working_hours.
     */
    data: working_hourCreateManyInput | working_hourCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * working_hour createManyAndReturn
   */
  export type working_hourCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the working_hour
     */
    select?: working_hourSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the working_hour
     */
    omit?: working_hourOmit<ExtArgs> | null
    /**
     * The data used to create many working_hours.
     */
    data: working_hourCreateManyInput | working_hourCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: working_hourIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * working_hour update
   */
  export type working_hourUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the working_hour
     */
    select?: working_hourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the working_hour
     */
    omit?: working_hourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: working_hourInclude<ExtArgs> | null
    /**
     * The data needed to update a working_hour.
     */
    data: XOR<working_hourUpdateInput, working_hourUncheckedUpdateInput>
    /**
     * Choose, which working_hour to update.
     */
    where: working_hourWhereUniqueInput
  }

  /**
   * working_hour updateMany
   */
  export type working_hourUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update working_hours.
     */
    data: XOR<working_hourUpdateManyMutationInput, working_hourUncheckedUpdateManyInput>
    /**
     * Filter which working_hours to update
     */
    where?: working_hourWhereInput
    /**
     * Limit how many working_hours to update.
     */
    limit?: number
  }

  /**
   * working_hour updateManyAndReturn
   */
  export type working_hourUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the working_hour
     */
    select?: working_hourSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the working_hour
     */
    omit?: working_hourOmit<ExtArgs> | null
    /**
     * The data used to update working_hours.
     */
    data: XOR<working_hourUpdateManyMutationInput, working_hourUncheckedUpdateManyInput>
    /**
     * Filter which working_hours to update
     */
    where?: working_hourWhereInput
    /**
     * Limit how many working_hours to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: working_hourIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * working_hour upsert
   */
  export type working_hourUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the working_hour
     */
    select?: working_hourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the working_hour
     */
    omit?: working_hourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: working_hourInclude<ExtArgs> | null
    /**
     * The filter to search for the working_hour to update in case it exists.
     */
    where: working_hourWhereUniqueInput
    /**
     * In case the working_hour found by the `where` argument doesn't exist, create a new working_hour with this data.
     */
    create: XOR<working_hourCreateInput, working_hourUncheckedCreateInput>
    /**
     * In case the working_hour was found with the provided `where` argument, update it with this data.
     */
    update: XOR<working_hourUpdateInput, working_hourUncheckedUpdateInput>
  }

  /**
   * working_hour delete
   */
  export type working_hourDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the working_hour
     */
    select?: working_hourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the working_hour
     */
    omit?: working_hourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: working_hourInclude<ExtArgs> | null
    /**
     * Filter which working_hour to delete.
     */
    where: working_hourWhereUniqueInput
  }

  /**
   * working_hour deleteMany
   */
  export type working_hourDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which working_hours to delete
     */
    where?: working_hourWhereInput
    /**
     * Limit how many working_hours to delete.
     */
    limit?: number
  }

  /**
   * working_hour without action
   */
  export type working_hourDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the working_hour
     */
    select?: working_hourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the working_hour
     */
    omit?: working_hourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: working_hourInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Access_typeScalarFieldEnum: {
    access_type_id: 'access_type_id',
    access_name: 'access_name'
  };

  export type Access_typeScalarFieldEnum = (typeof Access_typeScalarFieldEnum)[keyof typeof Access_typeScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    branch_id: 'branch_id',
    branch_city: 'branch_city',
    branch_address: 'branch_address',
    branch_phone: 'branch_phone',
    branch_email: 'branch_email',
    created_at: 'created_at'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const CartScalarFieldEnum: {
    cart_id: 'cart_id',
    order_id: 'order_id',
    product_id: 'product_id',
    quantity: 'quantity',
    sub_total_amount: 'sub_total_amount',
    created_at: 'created_at'
  };

  export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    category_id: 'category_id',
    category_name: 'category_name'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    customer_id: 'customer_id',
    customer_name: 'customer_name',
    customer_email: 'customer_email',
    customer_phone: 'customer_phone',
    customer_address: 'customer_address',
    visit_count: 'visit_count',
    rewards_points: 'rewards_points',
    created_at: 'created_at'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const DiscountScalarFieldEnum: {
    discount_id: 'discount_id',
    discount_name: 'discount_name',
    discount_desc: 'discount_desc',
    discount_percentage: 'discount_percentage'
  };

  export type DiscountScalarFieldEnum = (typeof DiscountScalarFieldEnum)[keyof typeof DiscountScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    employee_id: 'employee_id',
    employee_name: 'employee_name',
    role_id: 'role_id',
    hired_date: 'hired_date',
    employee_email: 'employee_email',
    employee_phone: 'employee_phone',
    branch_id: 'branch_id',
    employee_image: 'employee_image',
    branch_updated_on: 'branch_updated_on',
    role_updated_on: 'role_updated_on'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    product_id: 'product_id',
    branch_id: 'branch_id',
    quantity: 'quantity',
    reorder_level: 'reorder_level',
    updated_on: 'updated_on'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const Payment_methodScalarFieldEnum: {
    payment_method_id: 'payment_method_id',
    payment_method_name: 'payment_method_name'
  };

  export type Payment_methodScalarFieldEnum = (typeof Payment_methodScalarFieldEnum)[keyof typeof Payment_methodScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    product_id: 'product_id',
    product_name: 'product_name',
    product_desc: 'product_desc',
    category_id: 'category_id',
    product_image: 'product_image',
    buying_price: 'buying_price',
    retail_price: 'retail_price',
    discount: 'discount',
    supplier_id: 'supplier_id',
    product_barcode: 'product_barcode',
    removed: 'removed',
    created_at: 'created_at',
    updated_on: 'updated_on'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const Sales_historyScalarFieldEnum: {
    order_id: 'order_id',
    customer_id: 'customer_id',
    cashier_id: 'cashier_id',
    branch_id: 'branch_id',
    created_at: 'created_at',
    total_amount: 'total_amount',
    profit: 'profit',
    rewards_points: 'rewards_points',
    payment_method_id: 'payment_method_id',
    reference_id: 'reference_id',
    product_count: 'product_count'
  };

  export type Sales_historyScalarFieldEnum = (typeof Sales_historyScalarFieldEnum)[keyof typeof Sales_historyScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    supplier_id: 'supplier_id',
    supplier_name: 'supplier_name',
    supplier_email: 'supplier_email',
    supplier_phone: 'supplier_phone',
    supplier_address: 'supplier_address'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const User_credentialsScalarFieldEnum: {
    user_id: 'user_id',
    username: 'username',
    password: 'password',
    updated_on: 'updated_on'
  };

  export type User_credentialsScalarFieldEnum = (typeof User_credentialsScalarFieldEnum)[keyof typeof User_credentialsScalarFieldEnum]


  export const User_roleScalarFieldEnum: {
    role_id: 'role_id',
    role_name: 'role_name',
    role_desc: 'role_desc',
    user_access: 'user_access'
  };

  export type User_roleScalarFieldEnum = (typeof User_roleScalarFieldEnum)[keyof typeof User_roleScalarFieldEnum]


  export const Variable_optionsScalarFieldEnum: {
    variable_id: 'variable_id',
    variable_name: 'variable_name',
    created_at: 'created_at',
    variable_value: 'variable_value',
    updated_on: 'updated_on'
  };

  export type Variable_optionsScalarFieldEnum = (typeof Variable_optionsScalarFieldEnum)[keyof typeof Variable_optionsScalarFieldEnum]


  export const Working_hourScalarFieldEnum: {
    employee_id: 'employee_id',
    branch_id: 'branch_id',
    date: 'date',
    shift_on: 'shift_on',
    shift_off: 'shift_off',
    updated_by: 'updated_by',
    present: 'present',
    total_hours: 'total_hours'
  };

  export type Working_hourScalarFieldEnum = (typeof Working_hourScalarFieldEnum)[keyof typeof Working_hourScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type access_typeWhereInput = {
    AND?: access_typeWhereInput | access_typeWhereInput[]
    OR?: access_typeWhereInput[]
    NOT?: access_typeWhereInput | access_typeWhereInput[]
    access_type_id?: IntFilter<"access_type"> | number
    access_name?: StringFilter<"access_type"> | string
  }

  export type access_typeOrderByWithRelationInput = {
    access_type_id?: SortOrder
    access_name?: SortOrder
  }

  export type access_typeWhereUniqueInput = Prisma.AtLeast<{
    access_type_id?: number
    access_name?: string
    AND?: access_typeWhereInput | access_typeWhereInput[]
    OR?: access_typeWhereInput[]
    NOT?: access_typeWhereInput | access_typeWhereInput[]
  }, "access_type_id" | "access_name">

  export type access_typeOrderByWithAggregationInput = {
    access_type_id?: SortOrder
    access_name?: SortOrder
    _count?: access_typeCountOrderByAggregateInput
    _avg?: access_typeAvgOrderByAggregateInput
    _max?: access_typeMaxOrderByAggregateInput
    _min?: access_typeMinOrderByAggregateInput
    _sum?: access_typeSumOrderByAggregateInput
  }

  export type access_typeScalarWhereWithAggregatesInput = {
    AND?: access_typeScalarWhereWithAggregatesInput | access_typeScalarWhereWithAggregatesInput[]
    OR?: access_typeScalarWhereWithAggregatesInput[]
    NOT?: access_typeScalarWhereWithAggregatesInput | access_typeScalarWhereWithAggregatesInput[]
    access_type_id?: IntWithAggregatesFilter<"access_type"> | number
    access_name?: StringWithAggregatesFilter<"access_type"> | string
  }

  export type branchWhereInput = {
    AND?: branchWhereInput | branchWhereInput[]
    OR?: branchWhereInput[]
    NOT?: branchWhereInput | branchWhereInput[]
    branch_id?: UuidFilter<"branch"> | string
    branch_city?: StringFilter<"branch"> | string
    branch_address?: StringFilter<"branch"> | string
    branch_phone?: StringFilter<"branch"> | string
    branch_email?: StringFilter<"branch"> | string
    created_at?: DateTimeNullableFilter<"branch"> | Date | string | null
    employee?: EmployeeListRelationFilter
    inventory?: InventoryListRelationFilter
    sales_history?: Sales_historyListRelationFilter
  }

  export type branchOrderByWithRelationInput = {
    branch_id?: SortOrder
    branch_city?: SortOrder
    branch_address?: SortOrder
    branch_phone?: SortOrder
    branch_email?: SortOrder
    created_at?: SortOrderInput | SortOrder
    employee?: employeeOrderByRelationAggregateInput
    inventory?: inventoryOrderByRelationAggregateInput
    sales_history?: sales_historyOrderByRelationAggregateInput
  }

  export type branchWhereUniqueInput = Prisma.AtLeast<{
    branch_id?: string
    branch_city?: string
    branch_phone?: string
    branch_email?: string
    AND?: branchWhereInput | branchWhereInput[]
    OR?: branchWhereInput[]
    NOT?: branchWhereInput | branchWhereInput[]
    branch_address?: StringFilter<"branch"> | string
    created_at?: DateTimeNullableFilter<"branch"> | Date | string | null
    employee?: EmployeeListRelationFilter
    inventory?: InventoryListRelationFilter
    sales_history?: Sales_historyListRelationFilter
  }, "branch_id" | "branch_city" | "branch_phone" | "branch_email">

  export type branchOrderByWithAggregationInput = {
    branch_id?: SortOrder
    branch_city?: SortOrder
    branch_address?: SortOrder
    branch_phone?: SortOrder
    branch_email?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: branchCountOrderByAggregateInput
    _max?: branchMaxOrderByAggregateInput
    _min?: branchMinOrderByAggregateInput
  }

  export type branchScalarWhereWithAggregatesInput = {
    AND?: branchScalarWhereWithAggregatesInput | branchScalarWhereWithAggregatesInput[]
    OR?: branchScalarWhereWithAggregatesInput[]
    NOT?: branchScalarWhereWithAggregatesInput | branchScalarWhereWithAggregatesInput[]
    branch_id?: UuidWithAggregatesFilter<"branch"> | string
    branch_city?: StringWithAggregatesFilter<"branch"> | string
    branch_address?: StringWithAggregatesFilter<"branch"> | string
    branch_phone?: StringWithAggregatesFilter<"branch"> | string
    branch_email?: StringWithAggregatesFilter<"branch"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"branch"> | Date | string | null
  }

  export type cartWhereInput = {
    AND?: cartWhereInput | cartWhereInput[]
    OR?: cartWhereInput[]
    NOT?: cartWhereInput | cartWhereInput[]
    cart_id?: IntFilter<"cart"> | number
    order_id?: IntNullableFilter<"cart"> | number | null
    product_id?: UuidFilter<"cart"> | string
    quantity?: IntFilter<"cart"> | number
    sub_total_amount?: DecimalNullableFilter<"cart"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"cart"> | Date | string | null
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
    sales_history?: XOR<Sales_historyNullableScalarRelationFilter, sales_historyWhereInput> | null
  }

  export type cartOrderByWithRelationInput = {
    cart_id?: SortOrder
    order_id?: SortOrderInput | SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    sub_total_amount?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    product?: productOrderByWithRelationInput
    sales_history?: sales_historyOrderByWithRelationInput
  }

  export type cartWhereUniqueInput = Prisma.AtLeast<{
    cart_id?: number
    AND?: cartWhereInput | cartWhereInput[]
    OR?: cartWhereInput[]
    NOT?: cartWhereInput | cartWhereInput[]
    order_id?: IntNullableFilter<"cart"> | number | null
    product_id?: UuidFilter<"cart"> | string
    quantity?: IntFilter<"cart"> | number
    sub_total_amount?: DecimalNullableFilter<"cart"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"cart"> | Date | string | null
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
    sales_history?: XOR<Sales_historyNullableScalarRelationFilter, sales_historyWhereInput> | null
  }, "cart_id">

  export type cartOrderByWithAggregationInput = {
    cart_id?: SortOrder
    order_id?: SortOrderInput | SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    sub_total_amount?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: cartCountOrderByAggregateInput
    _avg?: cartAvgOrderByAggregateInput
    _max?: cartMaxOrderByAggregateInput
    _min?: cartMinOrderByAggregateInput
    _sum?: cartSumOrderByAggregateInput
  }

  export type cartScalarWhereWithAggregatesInput = {
    AND?: cartScalarWhereWithAggregatesInput | cartScalarWhereWithAggregatesInput[]
    OR?: cartScalarWhereWithAggregatesInput[]
    NOT?: cartScalarWhereWithAggregatesInput | cartScalarWhereWithAggregatesInput[]
    cart_id?: IntWithAggregatesFilter<"cart"> | number
    order_id?: IntNullableWithAggregatesFilter<"cart"> | number | null
    product_id?: UuidWithAggregatesFilter<"cart"> | string
    quantity?: IntWithAggregatesFilter<"cart"> | number
    sub_total_amount?: DecimalNullableWithAggregatesFilter<"cart"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"cart"> | Date | string | null
  }

  export type categoryWhereInput = {
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    category_id?: IntFilter<"category"> | number
    category_name?: StringFilter<"category"> | string
    product?: ProductListRelationFilter
  }

  export type categoryOrderByWithRelationInput = {
    category_id?: SortOrder
    category_name?: SortOrder
    product?: productOrderByRelationAggregateInput
  }

  export type categoryWhereUniqueInput = Prisma.AtLeast<{
    category_id?: number
    category_name?: string
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    product?: ProductListRelationFilter
  }, "category_id" | "category_name">

  export type categoryOrderByWithAggregationInput = {
    category_id?: SortOrder
    category_name?: SortOrder
    _count?: categoryCountOrderByAggregateInput
    _avg?: categoryAvgOrderByAggregateInput
    _max?: categoryMaxOrderByAggregateInput
    _min?: categoryMinOrderByAggregateInput
    _sum?: categorySumOrderByAggregateInput
  }

  export type categoryScalarWhereWithAggregatesInput = {
    AND?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    OR?: categoryScalarWhereWithAggregatesInput[]
    NOT?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    category_id?: IntWithAggregatesFilter<"category"> | number
    category_name?: StringWithAggregatesFilter<"category"> | string
  }

  export type customerWhereInput = {
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    customer_id?: IntFilter<"customer"> | number
    customer_name?: StringFilter<"customer"> | string
    customer_email?: StringNullableFilter<"customer"> | string | null
    customer_phone?: StringFilter<"customer"> | string
    customer_address?: StringNullableFilter<"customer"> | string | null
    visit_count?: IntNullableFilter<"customer"> | number | null
    rewards_points?: DecimalNullableFilter<"customer"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"customer"> | Date | string | null
    sales_history?: Sales_historyListRelationFilter
  }

  export type customerOrderByWithRelationInput = {
    customer_id?: SortOrder
    customer_name?: SortOrder
    customer_email?: SortOrderInput | SortOrder
    customer_phone?: SortOrder
    customer_address?: SortOrderInput | SortOrder
    visit_count?: SortOrderInput | SortOrder
    rewards_points?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    sales_history?: sales_historyOrderByRelationAggregateInput
  }

  export type customerWhereUniqueInput = Prisma.AtLeast<{
    customer_id?: number
    customer_email?: string
    customer_phone?: string
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    customer_name?: StringFilter<"customer"> | string
    customer_address?: StringNullableFilter<"customer"> | string | null
    visit_count?: IntNullableFilter<"customer"> | number | null
    rewards_points?: DecimalNullableFilter<"customer"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"customer"> | Date | string | null
    sales_history?: Sales_historyListRelationFilter
  }, "customer_id" | "customer_email" | "customer_phone">

  export type customerOrderByWithAggregationInput = {
    customer_id?: SortOrder
    customer_name?: SortOrder
    customer_email?: SortOrderInput | SortOrder
    customer_phone?: SortOrder
    customer_address?: SortOrderInput | SortOrder
    visit_count?: SortOrderInput | SortOrder
    rewards_points?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: customerCountOrderByAggregateInput
    _avg?: customerAvgOrderByAggregateInput
    _max?: customerMaxOrderByAggregateInput
    _min?: customerMinOrderByAggregateInput
    _sum?: customerSumOrderByAggregateInput
  }

  export type customerScalarWhereWithAggregatesInput = {
    AND?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    OR?: customerScalarWhereWithAggregatesInput[]
    NOT?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    customer_id?: IntWithAggregatesFilter<"customer"> | number
    customer_name?: StringWithAggregatesFilter<"customer"> | string
    customer_email?: StringNullableWithAggregatesFilter<"customer"> | string | null
    customer_phone?: StringWithAggregatesFilter<"customer"> | string
    customer_address?: StringNullableWithAggregatesFilter<"customer"> | string | null
    visit_count?: IntNullableWithAggregatesFilter<"customer"> | number | null
    rewards_points?: DecimalNullableWithAggregatesFilter<"customer"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"customer"> | Date | string | null
  }

  export type discountWhereInput = {
    AND?: discountWhereInput | discountWhereInput[]
    OR?: discountWhereInput[]
    NOT?: discountWhereInput | discountWhereInput[]
    discount_id?: IntFilter<"discount"> | number
    discount_name?: StringFilter<"discount"> | string
    discount_desc?: StringNullableFilter<"discount"> | string | null
    discount_percentage?: DecimalFilter<"discount"> | Decimal | DecimalJsLike | number | string
  }

  export type discountOrderByWithRelationInput = {
    discount_id?: SortOrder
    discount_name?: SortOrder
    discount_desc?: SortOrderInput | SortOrder
    discount_percentage?: SortOrder
  }

  export type discountWhereUniqueInput = Prisma.AtLeast<{
    discount_id?: number
    discount_name?: string
    AND?: discountWhereInput | discountWhereInput[]
    OR?: discountWhereInput[]
    NOT?: discountWhereInput | discountWhereInput[]
    discount_desc?: StringNullableFilter<"discount"> | string | null
    discount_percentage?: DecimalFilter<"discount"> | Decimal | DecimalJsLike | number | string
  }, "discount_id" | "discount_name">

  export type discountOrderByWithAggregationInput = {
    discount_id?: SortOrder
    discount_name?: SortOrder
    discount_desc?: SortOrderInput | SortOrder
    discount_percentage?: SortOrder
    _count?: discountCountOrderByAggregateInput
    _avg?: discountAvgOrderByAggregateInput
    _max?: discountMaxOrderByAggregateInput
    _min?: discountMinOrderByAggregateInput
    _sum?: discountSumOrderByAggregateInput
  }

  export type discountScalarWhereWithAggregatesInput = {
    AND?: discountScalarWhereWithAggregatesInput | discountScalarWhereWithAggregatesInput[]
    OR?: discountScalarWhereWithAggregatesInput[]
    NOT?: discountScalarWhereWithAggregatesInput | discountScalarWhereWithAggregatesInput[]
    discount_id?: IntWithAggregatesFilter<"discount"> | number
    discount_name?: StringWithAggregatesFilter<"discount"> | string
    discount_desc?: StringNullableWithAggregatesFilter<"discount"> | string | null
    discount_percentage?: DecimalWithAggregatesFilter<"discount"> | Decimal | DecimalJsLike | number | string
  }

  export type employeeWhereInput = {
    AND?: employeeWhereInput | employeeWhereInput[]
    OR?: employeeWhereInput[]
    NOT?: employeeWhereInput | employeeWhereInput[]
    employee_id?: IntFilter<"employee"> | number
    employee_name?: StringFilter<"employee"> | string
    role_id?: IntFilter<"employee"> | number
    hired_date?: DateTimeNullableFilter<"employee"> | Date | string | null
    employee_email?: StringNullableFilter<"employee"> | string | null
    employee_phone?: StringFilter<"employee"> | string
    branch_id?: UuidFilter<"employee"> | string
    employee_image?: StringNullableFilter<"employee"> | string | null
    branch_updated_on?: DateTimeNullableFilter<"employee"> | Date | string | null
    role_updated_on?: DateTimeNullableFilter<"employee"> | Date | string | null
    branch?: XOR<BranchScalarRelationFilter, branchWhereInput>
    user_role?: XOR<User_roleScalarRelationFilter, user_roleWhereInput>
    sales_history?: Sales_historyListRelationFilter
    user_credentials?: XOR<User_credentialsNullableScalarRelationFilter, user_credentialsWhereInput> | null
    working_hour?: Working_hourListRelationFilter
    working_hour_marked_by?: Working_hourListRelationFilter
  }

  export type employeeOrderByWithRelationInput = {
    employee_id?: SortOrder
    employee_name?: SortOrder
    role_id?: SortOrder
    hired_date?: SortOrderInput | SortOrder
    employee_email?: SortOrderInput | SortOrder
    employee_phone?: SortOrder
    branch_id?: SortOrder
    employee_image?: SortOrderInput | SortOrder
    branch_updated_on?: SortOrderInput | SortOrder
    role_updated_on?: SortOrderInput | SortOrder
    branch?: branchOrderByWithRelationInput
    user_role?: user_roleOrderByWithRelationInput
    sales_history?: sales_historyOrderByRelationAggregateInput
    user_credentials?: user_credentialsOrderByWithRelationInput
    working_hour?: working_hourOrderByRelationAggregateInput
    working_hour_marked_by?: working_hourOrderByRelationAggregateInput
  }

  export type employeeWhereUniqueInput = Prisma.AtLeast<{
    employee_id?: number
    employee_email?: string
    employee_phone?: string
    AND?: employeeWhereInput | employeeWhereInput[]
    OR?: employeeWhereInput[]
    NOT?: employeeWhereInput | employeeWhereInput[]
    employee_name?: StringFilter<"employee"> | string
    role_id?: IntFilter<"employee"> | number
    hired_date?: DateTimeNullableFilter<"employee"> | Date | string | null
    branch_id?: UuidFilter<"employee"> | string
    employee_image?: StringNullableFilter<"employee"> | string | null
    branch_updated_on?: DateTimeNullableFilter<"employee"> | Date | string | null
    role_updated_on?: DateTimeNullableFilter<"employee"> | Date | string | null
    branch?: XOR<BranchScalarRelationFilter, branchWhereInput>
    user_role?: XOR<User_roleScalarRelationFilter, user_roleWhereInput>
    sales_history?: Sales_historyListRelationFilter
    user_credentials?: XOR<User_credentialsNullableScalarRelationFilter, user_credentialsWhereInput> | null
    working_hour?: Working_hourListRelationFilter
    working_hour_marked_by?: Working_hourListRelationFilter
  }, "employee_id" | "employee_email" | "employee_phone">

  export type employeeOrderByWithAggregationInput = {
    employee_id?: SortOrder
    employee_name?: SortOrder
    role_id?: SortOrder
    hired_date?: SortOrderInput | SortOrder
    employee_email?: SortOrderInput | SortOrder
    employee_phone?: SortOrder
    branch_id?: SortOrder
    employee_image?: SortOrderInput | SortOrder
    branch_updated_on?: SortOrderInput | SortOrder
    role_updated_on?: SortOrderInput | SortOrder
    _count?: employeeCountOrderByAggregateInput
    _avg?: employeeAvgOrderByAggregateInput
    _max?: employeeMaxOrderByAggregateInput
    _min?: employeeMinOrderByAggregateInput
    _sum?: employeeSumOrderByAggregateInput
  }

  export type employeeScalarWhereWithAggregatesInput = {
    AND?: employeeScalarWhereWithAggregatesInput | employeeScalarWhereWithAggregatesInput[]
    OR?: employeeScalarWhereWithAggregatesInput[]
    NOT?: employeeScalarWhereWithAggregatesInput | employeeScalarWhereWithAggregatesInput[]
    employee_id?: IntWithAggregatesFilter<"employee"> | number
    employee_name?: StringWithAggregatesFilter<"employee"> | string
    role_id?: IntWithAggregatesFilter<"employee"> | number
    hired_date?: DateTimeNullableWithAggregatesFilter<"employee"> | Date | string | null
    employee_email?: StringNullableWithAggregatesFilter<"employee"> | string | null
    employee_phone?: StringWithAggregatesFilter<"employee"> | string
    branch_id?: UuidWithAggregatesFilter<"employee"> | string
    employee_image?: StringNullableWithAggregatesFilter<"employee"> | string | null
    branch_updated_on?: DateTimeNullableWithAggregatesFilter<"employee"> | Date | string | null
    role_updated_on?: DateTimeNullableWithAggregatesFilter<"employee"> | Date | string | null
  }

  export type inventoryWhereInput = {
    AND?: inventoryWhereInput | inventoryWhereInput[]
    OR?: inventoryWhereInput[]
    NOT?: inventoryWhereInput | inventoryWhereInput[]
    product_id?: UuidFilter<"inventory"> | string
    branch_id?: UuidFilter<"inventory"> | string
    quantity?: IntNullableFilter<"inventory"> | number | null
    reorder_level?: IntNullableFilter<"inventory"> | number | null
    updated_on?: DateTimeNullableFilter<"inventory"> | Date | string | null
    branch?: XOR<BranchScalarRelationFilter, branchWhereInput>
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
  }

  export type inventoryOrderByWithRelationInput = {
    product_id?: SortOrder
    branch_id?: SortOrder
    quantity?: SortOrderInput | SortOrder
    reorder_level?: SortOrderInput | SortOrder
    updated_on?: SortOrderInput | SortOrder
    branch?: branchOrderByWithRelationInput
    product?: productOrderByWithRelationInput
  }

  export type inventoryWhereUniqueInput = Prisma.AtLeast<{
    product_id_branch_id?: inventoryProduct_idBranch_idCompoundUniqueInput
    AND?: inventoryWhereInput | inventoryWhereInput[]
    OR?: inventoryWhereInput[]
    NOT?: inventoryWhereInput | inventoryWhereInput[]
    product_id?: UuidFilter<"inventory"> | string
    branch_id?: UuidFilter<"inventory"> | string
    quantity?: IntNullableFilter<"inventory"> | number | null
    reorder_level?: IntNullableFilter<"inventory"> | number | null
    updated_on?: DateTimeNullableFilter<"inventory"> | Date | string | null
    branch?: XOR<BranchScalarRelationFilter, branchWhereInput>
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
  }, "product_id_branch_id">

  export type inventoryOrderByWithAggregationInput = {
    product_id?: SortOrder
    branch_id?: SortOrder
    quantity?: SortOrderInput | SortOrder
    reorder_level?: SortOrderInput | SortOrder
    updated_on?: SortOrderInput | SortOrder
    _count?: inventoryCountOrderByAggregateInput
    _avg?: inventoryAvgOrderByAggregateInput
    _max?: inventoryMaxOrderByAggregateInput
    _min?: inventoryMinOrderByAggregateInput
    _sum?: inventorySumOrderByAggregateInput
  }

  export type inventoryScalarWhereWithAggregatesInput = {
    AND?: inventoryScalarWhereWithAggregatesInput | inventoryScalarWhereWithAggregatesInput[]
    OR?: inventoryScalarWhereWithAggregatesInput[]
    NOT?: inventoryScalarWhereWithAggregatesInput | inventoryScalarWhereWithAggregatesInput[]
    product_id?: UuidWithAggregatesFilter<"inventory"> | string
    branch_id?: UuidWithAggregatesFilter<"inventory"> | string
    quantity?: IntNullableWithAggregatesFilter<"inventory"> | number | null
    reorder_level?: IntNullableWithAggregatesFilter<"inventory"> | number | null
    updated_on?: DateTimeNullableWithAggregatesFilter<"inventory"> | Date | string | null
  }

  export type payment_methodWhereInput = {
    AND?: payment_methodWhereInput | payment_methodWhereInput[]
    OR?: payment_methodWhereInput[]
    NOT?: payment_methodWhereInput | payment_methodWhereInput[]
    payment_method_id?: IntFilter<"payment_method"> | number
    payment_method_name?: StringFilter<"payment_method"> | string
    sales_history?: Sales_historyListRelationFilter
  }

  export type payment_methodOrderByWithRelationInput = {
    payment_method_id?: SortOrder
    payment_method_name?: SortOrder
    sales_history?: sales_historyOrderByRelationAggregateInput
  }

  export type payment_methodWhereUniqueInput = Prisma.AtLeast<{
    payment_method_id?: number
    payment_method_name?: string
    AND?: payment_methodWhereInput | payment_methodWhereInput[]
    OR?: payment_methodWhereInput[]
    NOT?: payment_methodWhereInput | payment_methodWhereInput[]
    sales_history?: Sales_historyListRelationFilter
  }, "payment_method_id" | "payment_method_name">

  export type payment_methodOrderByWithAggregationInput = {
    payment_method_id?: SortOrder
    payment_method_name?: SortOrder
    _count?: payment_methodCountOrderByAggregateInput
    _avg?: payment_methodAvgOrderByAggregateInput
    _max?: payment_methodMaxOrderByAggregateInput
    _min?: payment_methodMinOrderByAggregateInput
    _sum?: payment_methodSumOrderByAggregateInput
  }

  export type payment_methodScalarWhereWithAggregatesInput = {
    AND?: payment_methodScalarWhereWithAggregatesInput | payment_methodScalarWhereWithAggregatesInput[]
    OR?: payment_methodScalarWhereWithAggregatesInput[]
    NOT?: payment_methodScalarWhereWithAggregatesInput | payment_methodScalarWhereWithAggregatesInput[]
    payment_method_id?: IntWithAggregatesFilter<"payment_method"> | number
    payment_method_name?: StringWithAggregatesFilter<"payment_method"> | string
  }

  export type productWhereInput = {
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    product_id?: UuidFilter<"product"> | string
    product_name?: StringFilter<"product"> | string
    product_desc?: StringNullableFilter<"product"> | string | null
    category_id?: IntFilter<"product"> | number
    product_image?: StringNullableListFilter<"product">
    buying_price?: DecimalFilter<"product"> | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalFilter<"product"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalNullableFilter<"product"> | Decimal | DecimalJsLike | number | string | null
    supplier_id?: IntFilter<"product"> | number
    product_barcode?: StringFilter<"product"> | string
    removed?: BoolNullableFilter<"product"> | boolean | null
    created_at?: DateTimeNullableFilter<"product"> | Date | string | null
    updated_on?: DateTimeNullableFilter<"product"> | Date | string | null
    cart?: CartListRelationFilter
    inventory?: InventoryListRelationFilter
    category?: XOR<CategoryScalarRelationFilter, categoryWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, supplierWhereInput>
  }

  export type productOrderByWithRelationInput = {
    product_id?: SortOrder
    product_name?: SortOrder
    product_desc?: SortOrderInput | SortOrder
    category_id?: SortOrder
    product_image?: SortOrder
    buying_price?: SortOrder
    retail_price?: SortOrder
    discount?: SortOrderInput | SortOrder
    supplier_id?: SortOrder
    product_barcode?: SortOrder
    removed?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_on?: SortOrderInput | SortOrder
    cart?: cartOrderByRelationAggregateInput
    inventory?: inventoryOrderByRelationAggregateInput
    category?: categoryOrderByWithRelationInput
    supplier?: supplierOrderByWithRelationInput
  }

  export type productWhereUniqueInput = Prisma.AtLeast<{
    product_id?: string
    product_name?: string
    product_barcode?: string
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    product_desc?: StringNullableFilter<"product"> | string | null
    category_id?: IntFilter<"product"> | number
    product_image?: StringNullableListFilter<"product">
    buying_price?: DecimalFilter<"product"> | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalFilter<"product"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalNullableFilter<"product"> | Decimal | DecimalJsLike | number | string | null
    supplier_id?: IntFilter<"product"> | number
    removed?: BoolNullableFilter<"product"> | boolean | null
    created_at?: DateTimeNullableFilter<"product"> | Date | string | null
    updated_on?: DateTimeNullableFilter<"product"> | Date | string | null
    cart?: CartListRelationFilter
    inventory?: InventoryListRelationFilter
    category?: XOR<CategoryScalarRelationFilter, categoryWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, supplierWhereInput>
  }, "product_id" | "product_name" | "product_barcode">

  export type productOrderByWithAggregationInput = {
    product_id?: SortOrder
    product_name?: SortOrder
    product_desc?: SortOrderInput | SortOrder
    category_id?: SortOrder
    product_image?: SortOrder
    buying_price?: SortOrder
    retail_price?: SortOrder
    discount?: SortOrderInput | SortOrder
    supplier_id?: SortOrder
    product_barcode?: SortOrder
    removed?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_on?: SortOrderInput | SortOrder
    _count?: productCountOrderByAggregateInput
    _avg?: productAvgOrderByAggregateInput
    _max?: productMaxOrderByAggregateInput
    _min?: productMinOrderByAggregateInput
    _sum?: productSumOrderByAggregateInput
  }

  export type productScalarWhereWithAggregatesInput = {
    AND?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    OR?: productScalarWhereWithAggregatesInput[]
    NOT?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    product_id?: UuidWithAggregatesFilter<"product"> | string
    product_name?: StringWithAggregatesFilter<"product"> | string
    product_desc?: StringNullableWithAggregatesFilter<"product"> | string | null
    category_id?: IntWithAggregatesFilter<"product"> | number
    product_image?: StringNullableListFilter<"product">
    buying_price?: DecimalWithAggregatesFilter<"product"> | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalWithAggregatesFilter<"product"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalNullableWithAggregatesFilter<"product"> | Decimal | DecimalJsLike | number | string | null
    supplier_id?: IntWithAggregatesFilter<"product"> | number
    product_barcode?: StringWithAggregatesFilter<"product"> | string
    removed?: BoolNullableWithAggregatesFilter<"product"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"product"> | Date | string | null
    updated_on?: DateTimeNullableWithAggregatesFilter<"product"> | Date | string | null
  }

  export type sales_historyWhereInput = {
    AND?: sales_historyWhereInput | sales_historyWhereInput[]
    OR?: sales_historyWhereInput[]
    NOT?: sales_historyWhereInput | sales_historyWhereInput[]
    order_id?: IntFilter<"sales_history"> | number
    customer_id?: IntNullableFilter<"sales_history"> | number | null
    cashier_id?: IntFilter<"sales_history"> | number
    branch_id?: UuidFilter<"sales_history"> | string
    created_at?: DateTimeNullableFilter<"sales_history"> | Date | string | null
    total_amount?: DecimalNullableFilter<"sales_history"> | Decimal | DecimalJsLike | number | string | null
    profit?: DecimalNullableFilter<"sales_history"> | Decimal | DecimalJsLike | number | string | null
    rewards_points?: DecimalNullableFilter<"sales_history"> | Decimal | DecimalJsLike | number | string | null
    payment_method_id?: IntNullableFilter<"sales_history"> | number | null
    reference_id?: StringNullableFilter<"sales_history"> | string | null
    product_count?: IntNullableFilter<"sales_history"> | number | null
    cart?: CartListRelationFilter
    branch?: XOR<BranchScalarRelationFilter, branchWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, customerWhereInput> | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    payment_method?: XOR<Payment_methodNullableScalarRelationFilter, payment_methodWhereInput> | null
  }

  export type sales_historyOrderByWithRelationInput = {
    order_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    cashier_id?: SortOrder
    branch_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    total_amount?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    rewards_points?: SortOrderInput | SortOrder
    payment_method_id?: SortOrderInput | SortOrder
    reference_id?: SortOrderInput | SortOrder
    product_count?: SortOrderInput | SortOrder
    cart?: cartOrderByRelationAggregateInput
    branch?: branchOrderByWithRelationInput
    customer?: customerOrderByWithRelationInput
    employee?: employeeOrderByWithRelationInput
    payment_method?: payment_methodOrderByWithRelationInput
  }

  export type sales_historyWhereUniqueInput = Prisma.AtLeast<{
    order_id?: number
    AND?: sales_historyWhereInput | sales_historyWhereInput[]
    OR?: sales_historyWhereInput[]
    NOT?: sales_historyWhereInput | sales_historyWhereInput[]
    customer_id?: IntNullableFilter<"sales_history"> | number | null
    cashier_id?: IntFilter<"sales_history"> | number
    branch_id?: UuidFilter<"sales_history"> | string
    created_at?: DateTimeNullableFilter<"sales_history"> | Date | string | null
    total_amount?: DecimalNullableFilter<"sales_history"> | Decimal | DecimalJsLike | number | string | null
    profit?: DecimalNullableFilter<"sales_history"> | Decimal | DecimalJsLike | number | string | null
    rewards_points?: DecimalNullableFilter<"sales_history"> | Decimal | DecimalJsLike | number | string | null
    payment_method_id?: IntNullableFilter<"sales_history"> | number | null
    reference_id?: StringNullableFilter<"sales_history"> | string | null
    product_count?: IntNullableFilter<"sales_history"> | number | null
    cart?: CartListRelationFilter
    branch?: XOR<BranchScalarRelationFilter, branchWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, customerWhereInput> | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    payment_method?: XOR<Payment_methodNullableScalarRelationFilter, payment_methodWhereInput> | null
  }, "order_id">

  export type sales_historyOrderByWithAggregationInput = {
    order_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    cashier_id?: SortOrder
    branch_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    total_amount?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    rewards_points?: SortOrderInput | SortOrder
    payment_method_id?: SortOrderInput | SortOrder
    reference_id?: SortOrderInput | SortOrder
    product_count?: SortOrderInput | SortOrder
    _count?: sales_historyCountOrderByAggregateInput
    _avg?: sales_historyAvgOrderByAggregateInput
    _max?: sales_historyMaxOrderByAggregateInput
    _min?: sales_historyMinOrderByAggregateInput
    _sum?: sales_historySumOrderByAggregateInput
  }

  export type sales_historyScalarWhereWithAggregatesInput = {
    AND?: sales_historyScalarWhereWithAggregatesInput | sales_historyScalarWhereWithAggregatesInput[]
    OR?: sales_historyScalarWhereWithAggregatesInput[]
    NOT?: sales_historyScalarWhereWithAggregatesInput | sales_historyScalarWhereWithAggregatesInput[]
    order_id?: IntWithAggregatesFilter<"sales_history"> | number
    customer_id?: IntNullableWithAggregatesFilter<"sales_history"> | number | null
    cashier_id?: IntWithAggregatesFilter<"sales_history"> | number
    branch_id?: UuidWithAggregatesFilter<"sales_history"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"sales_history"> | Date | string | null
    total_amount?: DecimalNullableWithAggregatesFilter<"sales_history"> | Decimal | DecimalJsLike | number | string | null
    profit?: DecimalNullableWithAggregatesFilter<"sales_history"> | Decimal | DecimalJsLike | number | string | null
    rewards_points?: DecimalNullableWithAggregatesFilter<"sales_history"> | Decimal | DecimalJsLike | number | string | null
    payment_method_id?: IntNullableWithAggregatesFilter<"sales_history"> | number | null
    reference_id?: StringNullableWithAggregatesFilter<"sales_history"> | string | null
    product_count?: IntNullableWithAggregatesFilter<"sales_history"> | number | null
  }

  export type supplierWhereInput = {
    AND?: supplierWhereInput | supplierWhereInput[]
    OR?: supplierWhereInput[]
    NOT?: supplierWhereInput | supplierWhereInput[]
    supplier_id?: IntFilter<"supplier"> | number
    supplier_name?: StringFilter<"supplier"> | string
    supplier_email?: StringNullableFilter<"supplier"> | string | null
    supplier_phone?: StringFilter<"supplier"> | string
    supplier_address?: StringFilter<"supplier"> | string
    product?: ProductListRelationFilter
  }

  export type supplierOrderByWithRelationInput = {
    supplier_id?: SortOrder
    supplier_name?: SortOrder
    supplier_email?: SortOrderInput | SortOrder
    supplier_phone?: SortOrder
    supplier_address?: SortOrder
    product?: productOrderByRelationAggregateInput
  }

  export type supplierWhereUniqueInput = Prisma.AtLeast<{
    supplier_id?: number
    supplier_email?: string
    supplier_phone?: string
    AND?: supplierWhereInput | supplierWhereInput[]
    OR?: supplierWhereInput[]
    NOT?: supplierWhereInput | supplierWhereInput[]
    supplier_name?: StringFilter<"supplier"> | string
    supplier_address?: StringFilter<"supplier"> | string
    product?: ProductListRelationFilter
  }, "supplier_id" | "supplier_email" | "supplier_phone">

  export type supplierOrderByWithAggregationInput = {
    supplier_id?: SortOrder
    supplier_name?: SortOrder
    supplier_email?: SortOrderInput | SortOrder
    supplier_phone?: SortOrder
    supplier_address?: SortOrder
    _count?: supplierCountOrderByAggregateInput
    _avg?: supplierAvgOrderByAggregateInput
    _max?: supplierMaxOrderByAggregateInput
    _min?: supplierMinOrderByAggregateInput
    _sum?: supplierSumOrderByAggregateInput
  }

  export type supplierScalarWhereWithAggregatesInput = {
    AND?: supplierScalarWhereWithAggregatesInput | supplierScalarWhereWithAggregatesInput[]
    OR?: supplierScalarWhereWithAggregatesInput[]
    NOT?: supplierScalarWhereWithAggregatesInput | supplierScalarWhereWithAggregatesInput[]
    supplier_id?: IntWithAggregatesFilter<"supplier"> | number
    supplier_name?: StringWithAggregatesFilter<"supplier"> | string
    supplier_email?: StringNullableWithAggregatesFilter<"supplier"> | string | null
    supplier_phone?: StringWithAggregatesFilter<"supplier"> | string
    supplier_address?: StringWithAggregatesFilter<"supplier"> | string
  }

  export type user_credentialsWhereInput = {
    AND?: user_credentialsWhereInput | user_credentialsWhereInput[]
    OR?: user_credentialsWhereInput[]
    NOT?: user_credentialsWhereInput | user_credentialsWhereInput[]
    user_id?: IntFilter<"user_credentials"> | number
    username?: StringFilter<"user_credentials"> | string
    password?: StringFilter<"user_credentials"> | string
    updated_on?: DateTimeNullableFilter<"user_credentials"> | Date | string | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }

  export type user_credentialsOrderByWithRelationInput = {
    user_id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    updated_on?: SortOrderInput | SortOrder
    employee?: employeeOrderByWithRelationInput
  }

  export type user_credentialsWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    username?: string
    password?: string
    AND?: user_credentialsWhereInput | user_credentialsWhereInput[]
    OR?: user_credentialsWhereInput[]
    NOT?: user_credentialsWhereInput | user_credentialsWhereInput[]
    updated_on?: DateTimeNullableFilter<"user_credentials"> | Date | string | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }, "user_id" | "username" | "password">

  export type user_credentialsOrderByWithAggregationInput = {
    user_id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    updated_on?: SortOrderInput | SortOrder
    _count?: user_credentialsCountOrderByAggregateInput
    _avg?: user_credentialsAvgOrderByAggregateInput
    _max?: user_credentialsMaxOrderByAggregateInput
    _min?: user_credentialsMinOrderByAggregateInput
    _sum?: user_credentialsSumOrderByAggregateInput
  }

  export type user_credentialsScalarWhereWithAggregatesInput = {
    AND?: user_credentialsScalarWhereWithAggregatesInput | user_credentialsScalarWhereWithAggregatesInput[]
    OR?: user_credentialsScalarWhereWithAggregatesInput[]
    NOT?: user_credentialsScalarWhereWithAggregatesInput | user_credentialsScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"user_credentials"> | number
    username?: StringWithAggregatesFilter<"user_credentials"> | string
    password?: StringWithAggregatesFilter<"user_credentials"> | string
    updated_on?: DateTimeNullableWithAggregatesFilter<"user_credentials"> | Date | string | null
  }

  export type user_roleWhereInput = {
    AND?: user_roleWhereInput | user_roleWhereInput[]
    OR?: user_roleWhereInput[]
    NOT?: user_roleWhereInput | user_roleWhereInput[]
    role_id?: IntFilter<"user_role"> | number
    role_name?: StringFilter<"user_role"> | string
    role_desc?: StringFilter<"user_role"> | string
    user_access?: IntNullableListFilter<"user_role">
    employee?: EmployeeListRelationFilter
  }

  export type user_roleOrderByWithRelationInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    role_desc?: SortOrder
    user_access?: SortOrder
    employee?: employeeOrderByRelationAggregateInput
  }

  export type user_roleWhereUniqueInput = Prisma.AtLeast<{
    role_id?: number
    role_name?: string
    AND?: user_roleWhereInput | user_roleWhereInput[]
    OR?: user_roleWhereInput[]
    NOT?: user_roleWhereInput | user_roleWhereInput[]
    role_desc?: StringFilter<"user_role"> | string
    user_access?: IntNullableListFilter<"user_role">
    employee?: EmployeeListRelationFilter
  }, "role_id" | "role_name">

  export type user_roleOrderByWithAggregationInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    role_desc?: SortOrder
    user_access?: SortOrder
    _count?: user_roleCountOrderByAggregateInput
    _avg?: user_roleAvgOrderByAggregateInput
    _max?: user_roleMaxOrderByAggregateInput
    _min?: user_roleMinOrderByAggregateInput
    _sum?: user_roleSumOrderByAggregateInput
  }

  export type user_roleScalarWhereWithAggregatesInput = {
    AND?: user_roleScalarWhereWithAggregatesInput | user_roleScalarWhereWithAggregatesInput[]
    OR?: user_roleScalarWhereWithAggregatesInput[]
    NOT?: user_roleScalarWhereWithAggregatesInput | user_roleScalarWhereWithAggregatesInput[]
    role_id?: IntWithAggregatesFilter<"user_role"> | number
    role_name?: StringWithAggregatesFilter<"user_role"> | string
    role_desc?: StringWithAggregatesFilter<"user_role"> | string
    user_access?: IntNullableListFilter<"user_role">
  }

  export type variable_optionsWhereInput = {
    AND?: variable_optionsWhereInput | variable_optionsWhereInput[]
    OR?: variable_optionsWhereInput[]
    NOT?: variable_optionsWhereInput | variable_optionsWhereInput[]
    variable_id?: IntFilter<"variable_options"> | number
    variable_name?: StringFilter<"variable_options"> | string
    created_at?: DateTimeNullableFilter<"variable_options"> | Date | string | null
    variable_value?: DecimalNullableFilter<"variable_options"> | Decimal | DecimalJsLike | number | string | null
    updated_on?: DateTimeNullableFilter<"variable_options"> | Date | string | null
  }

  export type variable_optionsOrderByWithRelationInput = {
    variable_id?: SortOrder
    variable_name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    variable_value?: SortOrderInput | SortOrder
    updated_on?: SortOrderInput | SortOrder
  }

  export type variable_optionsWhereUniqueInput = Prisma.AtLeast<{
    variable_id?: number
    variable_name?: string
    AND?: variable_optionsWhereInput | variable_optionsWhereInput[]
    OR?: variable_optionsWhereInput[]
    NOT?: variable_optionsWhereInput | variable_optionsWhereInput[]
    created_at?: DateTimeNullableFilter<"variable_options"> | Date | string | null
    variable_value?: DecimalNullableFilter<"variable_options"> | Decimal | DecimalJsLike | number | string | null
    updated_on?: DateTimeNullableFilter<"variable_options"> | Date | string | null
  }, "variable_id" | "variable_name">

  export type variable_optionsOrderByWithAggregationInput = {
    variable_id?: SortOrder
    variable_name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    variable_value?: SortOrderInput | SortOrder
    updated_on?: SortOrderInput | SortOrder
    _count?: variable_optionsCountOrderByAggregateInput
    _avg?: variable_optionsAvgOrderByAggregateInput
    _max?: variable_optionsMaxOrderByAggregateInput
    _min?: variable_optionsMinOrderByAggregateInput
    _sum?: variable_optionsSumOrderByAggregateInput
  }

  export type variable_optionsScalarWhereWithAggregatesInput = {
    AND?: variable_optionsScalarWhereWithAggregatesInput | variable_optionsScalarWhereWithAggregatesInput[]
    OR?: variable_optionsScalarWhereWithAggregatesInput[]
    NOT?: variable_optionsScalarWhereWithAggregatesInput | variable_optionsScalarWhereWithAggregatesInput[]
    variable_id?: IntWithAggregatesFilter<"variable_options"> | number
    variable_name?: StringWithAggregatesFilter<"variable_options"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"variable_options"> | Date | string | null
    variable_value?: DecimalNullableWithAggregatesFilter<"variable_options"> | Decimal | DecimalJsLike | number | string | null
    updated_on?: DateTimeNullableWithAggregatesFilter<"variable_options"> | Date | string | null
  }

  export type working_hourWhereInput = {
    AND?: working_hourWhereInput | working_hourWhereInput[]
    OR?: working_hourWhereInput[]
    NOT?: working_hourWhereInput | working_hourWhereInput[]
    employee_id?: IntFilter<"working_hour"> | number
    branch_id?: UuidFilter<"working_hour"> | string
    date?: StringFilter<"working_hour"> | string
    shift_on?: StringFilter<"working_hour"> | string
    shift_off?: StringFilter<"working_hour"> | string
    updated_by?: IntFilter<"working_hour"> | number
    present?: BoolFilter<"working_hour"> | boolean
    total_hours?: DecimalNullableFilter<"working_hour"> | Decimal | DecimalJsLike | number | string | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    marked_by?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }

  export type working_hourOrderByWithRelationInput = {
    employee_id?: SortOrder
    branch_id?: SortOrder
    date?: SortOrder
    shift_on?: SortOrder
    shift_off?: SortOrder
    updated_by?: SortOrder
    present?: SortOrder
    total_hours?: SortOrderInput | SortOrder
    employee?: employeeOrderByWithRelationInput
    marked_by?: employeeOrderByWithRelationInput
  }

  export type working_hourWhereUniqueInput = Prisma.AtLeast<{
    employee_id_branch_id_date?: working_hourEmployee_idBranch_idDateCompoundUniqueInput
    AND?: working_hourWhereInput | working_hourWhereInput[]
    OR?: working_hourWhereInput[]
    NOT?: working_hourWhereInput | working_hourWhereInput[]
    employee_id?: IntFilter<"working_hour"> | number
    branch_id?: UuidFilter<"working_hour"> | string
    date?: StringFilter<"working_hour"> | string
    shift_on?: StringFilter<"working_hour"> | string
    shift_off?: StringFilter<"working_hour"> | string
    updated_by?: IntFilter<"working_hour"> | number
    present?: BoolFilter<"working_hour"> | boolean
    total_hours?: DecimalNullableFilter<"working_hour"> | Decimal | DecimalJsLike | number | string | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    marked_by?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }, "employee_id_branch_id_date">

  export type working_hourOrderByWithAggregationInput = {
    employee_id?: SortOrder
    branch_id?: SortOrder
    date?: SortOrder
    shift_on?: SortOrder
    shift_off?: SortOrder
    updated_by?: SortOrder
    present?: SortOrder
    total_hours?: SortOrderInput | SortOrder
    _count?: working_hourCountOrderByAggregateInput
    _avg?: working_hourAvgOrderByAggregateInput
    _max?: working_hourMaxOrderByAggregateInput
    _min?: working_hourMinOrderByAggregateInput
    _sum?: working_hourSumOrderByAggregateInput
  }

  export type working_hourScalarWhereWithAggregatesInput = {
    AND?: working_hourScalarWhereWithAggregatesInput | working_hourScalarWhereWithAggregatesInput[]
    OR?: working_hourScalarWhereWithAggregatesInput[]
    NOT?: working_hourScalarWhereWithAggregatesInput | working_hourScalarWhereWithAggregatesInput[]
    employee_id?: IntWithAggregatesFilter<"working_hour"> | number
    branch_id?: UuidWithAggregatesFilter<"working_hour"> | string
    date?: StringWithAggregatesFilter<"working_hour"> | string
    shift_on?: StringWithAggregatesFilter<"working_hour"> | string
    shift_off?: StringWithAggregatesFilter<"working_hour"> | string
    updated_by?: IntWithAggregatesFilter<"working_hour"> | number
    present?: BoolWithAggregatesFilter<"working_hour"> | boolean
    total_hours?: DecimalNullableWithAggregatesFilter<"working_hour"> | Decimal | DecimalJsLike | number | string | null
  }

  export type access_typeCreateInput = {
    access_name: string
  }

  export type access_typeUncheckedCreateInput = {
    access_type_id?: number
    access_name: string
  }

  export type access_typeUpdateInput = {
    access_name?: StringFieldUpdateOperationsInput | string
  }

  export type access_typeUncheckedUpdateInput = {
    access_type_id?: IntFieldUpdateOperationsInput | number
    access_name?: StringFieldUpdateOperationsInput | string
  }

  export type access_typeCreateManyInput = {
    access_type_id?: number
    access_name: string
  }

  export type access_typeUpdateManyMutationInput = {
    access_name?: StringFieldUpdateOperationsInput | string
  }

  export type access_typeUncheckedUpdateManyInput = {
    access_type_id?: IntFieldUpdateOperationsInput | number
    access_name?: StringFieldUpdateOperationsInput | string
  }

  export type branchCreateInput = {
    branch_id?: string
    branch_city: string
    branch_address: string
    branch_phone: string
    branch_email: string
    created_at?: Date | string | null
    employee?: employeeCreateNestedManyWithoutBranchInput
    inventory?: inventoryCreateNestedManyWithoutBranchInput
    sales_history?: sales_historyCreateNestedManyWithoutBranchInput
  }

  export type branchUncheckedCreateInput = {
    branch_id?: string
    branch_city: string
    branch_address: string
    branch_phone: string
    branch_email: string
    created_at?: Date | string | null
    employee?: employeeUncheckedCreateNestedManyWithoutBranchInput
    inventory?: inventoryUncheckedCreateNestedManyWithoutBranchInput
    sales_history?: sales_historyUncheckedCreateNestedManyWithoutBranchInput
  }

  export type branchUpdateInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    branch_city?: StringFieldUpdateOperationsInput | string
    branch_address?: StringFieldUpdateOperationsInput | string
    branch_phone?: StringFieldUpdateOperationsInput | string
    branch_email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: employeeUpdateManyWithoutBranchNestedInput
    inventory?: inventoryUpdateManyWithoutBranchNestedInput
    sales_history?: sales_historyUpdateManyWithoutBranchNestedInput
  }

  export type branchUncheckedUpdateInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    branch_city?: StringFieldUpdateOperationsInput | string
    branch_address?: StringFieldUpdateOperationsInput | string
    branch_phone?: StringFieldUpdateOperationsInput | string
    branch_email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: employeeUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: inventoryUncheckedUpdateManyWithoutBranchNestedInput
    sales_history?: sales_historyUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type branchCreateManyInput = {
    branch_id?: string
    branch_city: string
    branch_address: string
    branch_phone: string
    branch_email: string
    created_at?: Date | string | null
  }

  export type branchUpdateManyMutationInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    branch_city?: StringFieldUpdateOperationsInput | string
    branch_address?: StringFieldUpdateOperationsInput | string
    branch_phone?: StringFieldUpdateOperationsInput | string
    branch_email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type branchUncheckedUpdateManyInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    branch_city?: StringFieldUpdateOperationsInput | string
    branch_address?: StringFieldUpdateOperationsInput | string
    branch_phone?: StringFieldUpdateOperationsInput | string
    branch_email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cartCreateInput = {
    quantity: number
    sub_total_amount?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    product: productCreateNestedOneWithoutCartInput
    sales_history?: sales_historyCreateNestedOneWithoutCartInput
  }

  export type cartUncheckedCreateInput = {
    cart_id?: number
    order_id?: number | null
    product_id: string
    quantity: number
    sub_total_amount?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
  }

  export type cartUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    sub_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: productUpdateOneRequiredWithoutCartNestedInput
    sales_history?: sales_historyUpdateOneWithoutCartNestedInput
  }

  export type cartUncheckedUpdateInput = {
    cart_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sub_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cartCreateManyInput = {
    cart_id?: number
    order_id?: number | null
    product_id: string
    quantity: number
    sub_total_amount?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
  }

  export type cartUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    sub_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cartUncheckedUpdateManyInput = {
    cart_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sub_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type categoryCreateInput = {
    category_name: string
    product?: productCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateInput = {
    category_id?: number
    category_name: string
    product?: productUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryUpdateInput = {
    category_name?: StringFieldUpdateOperationsInput | string
    product?: productUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateInput = {
    category_id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
    product?: productUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type categoryCreateManyInput = {
    category_id?: number
    category_name: string
  }

  export type categoryUpdateManyMutationInput = {
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type categoryUncheckedUpdateManyInput = {
    category_id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type customerCreateInput = {
    customer_name: string
    customer_email?: string | null
    customer_phone: string
    customer_address?: string | null
    visit_count?: number | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    sales_history?: sales_historyCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateInput = {
    customer_id?: number
    customer_name: string
    customer_email?: string | null
    customer_phone: string
    customer_address?: string | null
    visit_count?: number | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    sales_history?: sales_historyUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerUpdateInput = {
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    visit_count?: NullableIntFieldUpdateOperationsInput | number | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales_history?: sales_historyUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateInput = {
    customer_id?: IntFieldUpdateOperationsInput | number
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    visit_count?: NullableIntFieldUpdateOperationsInput | number | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales_history?: sales_historyUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerCreateManyInput = {
    customer_id?: number
    customer_name: string
    customer_email?: string | null
    customer_phone: string
    customer_address?: string | null
    visit_count?: number | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
  }

  export type customerUpdateManyMutationInput = {
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    visit_count?: NullableIntFieldUpdateOperationsInput | number | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type customerUncheckedUpdateManyInput = {
    customer_id?: IntFieldUpdateOperationsInput | number
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    visit_count?: NullableIntFieldUpdateOperationsInput | number | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type discountCreateInput = {
    discount_name: string
    discount_desc?: string | null
    discount_percentage: Decimal | DecimalJsLike | number | string
  }

  export type discountUncheckedCreateInput = {
    discount_id?: number
    discount_name: string
    discount_desc?: string | null
    discount_percentage: Decimal | DecimalJsLike | number | string
  }

  export type discountUpdateInput = {
    discount_name?: StringFieldUpdateOperationsInput | string
    discount_desc?: NullableStringFieldUpdateOperationsInput | string | null
    discount_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type discountUncheckedUpdateInput = {
    discount_id?: IntFieldUpdateOperationsInput | number
    discount_name?: StringFieldUpdateOperationsInput | string
    discount_desc?: NullableStringFieldUpdateOperationsInput | string | null
    discount_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type discountCreateManyInput = {
    discount_id?: number
    discount_name: string
    discount_desc?: string | null
    discount_percentage: Decimal | DecimalJsLike | number | string
  }

  export type discountUpdateManyMutationInput = {
    discount_name?: StringFieldUpdateOperationsInput | string
    discount_desc?: NullableStringFieldUpdateOperationsInput | string | null
    discount_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type discountUncheckedUpdateManyInput = {
    discount_id?: IntFieldUpdateOperationsInput | number
    discount_name?: StringFieldUpdateOperationsInput | string
    discount_desc?: NullableStringFieldUpdateOperationsInput | string | null
    discount_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type employeeCreateInput = {
    employee_name: string
    hired_date?: Date | string | null
    employee_email?: string | null
    employee_phone: string
    employee_image?: string | null
    branch_updated_on?: Date | string | null
    role_updated_on?: Date | string | null
    branch: branchCreateNestedOneWithoutEmployeeInput
    user_role: user_roleCreateNestedOneWithoutEmployeeInput
    sales_history?: sales_historyCreateNestedManyWithoutEmployeeInput
    user_credentials?: user_credentialsCreateNestedOneWithoutEmployeeInput
    working_hour?: working_hourCreateNestedManyWithoutEmployeeInput
    working_hour_marked_by?: working_hourCreateNestedManyWithoutMarked_byInput
  }

  export type employeeUncheckedCreateInput = {
    employee_id?: number
    employee_name: string
    role_id: number
    hired_date?: Date | string | null
    employee_email?: string | null
    employee_phone: string
    branch_id: string
    employee_image?: string | null
    branch_updated_on?: Date | string | null
    role_updated_on?: Date | string | null
    sales_history?: sales_historyUncheckedCreateNestedManyWithoutEmployeeInput
    user_credentials?: user_credentialsUncheckedCreateNestedOneWithoutEmployeeInput
    working_hour?: working_hourUncheckedCreateNestedManyWithoutEmployeeInput
    working_hour_marked_by?: working_hourUncheckedCreateNestedManyWithoutMarked_byInput
  }

  export type employeeUpdateInput = {
    employee_name?: StringFieldUpdateOperationsInput | string
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: branchUpdateOneRequiredWithoutEmployeeNestedInput
    user_role?: user_roleUpdateOneRequiredWithoutEmployeeNestedInput
    sales_history?: sales_historyUpdateManyWithoutEmployeeNestedInput
    user_credentials?: user_credentialsUpdateOneWithoutEmployeeNestedInput
    working_hour?: working_hourUpdateManyWithoutEmployeeNestedInput
    working_hour_marked_by?: working_hourUpdateManyWithoutMarked_byNestedInput
  }

  export type employeeUncheckedUpdateInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_name?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    branch_id?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales_history?: sales_historyUncheckedUpdateManyWithoutEmployeeNestedInput
    user_credentials?: user_credentialsUncheckedUpdateOneWithoutEmployeeNestedInput
    working_hour?: working_hourUncheckedUpdateManyWithoutEmployeeNestedInput
    working_hour_marked_by?: working_hourUncheckedUpdateManyWithoutMarked_byNestedInput
  }

  export type employeeCreateManyInput = {
    employee_id?: number
    employee_name: string
    role_id: number
    hired_date?: Date | string | null
    employee_email?: string | null
    employee_phone: string
    branch_id: string
    employee_image?: string | null
    branch_updated_on?: Date | string | null
    role_updated_on?: Date | string | null
  }

  export type employeeUpdateManyMutationInput = {
    employee_name?: StringFieldUpdateOperationsInput | string
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employeeUncheckedUpdateManyInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_name?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    branch_id?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventoryCreateInput = {
    quantity?: number | null
    reorder_level?: number | null
    updated_on?: Date | string | null
    branch: branchCreateNestedOneWithoutInventoryInput
    product: productCreateNestedOneWithoutInventoryInput
  }

  export type inventoryUncheckedCreateInput = {
    product_id: string
    branch_id: string
    quantity?: number | null
    reorder_level?: number | null
    updated_on?: Date | string | null
  }

  export type inventoryUpdateInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    reorder_level?: NullableIntFieldUpdateOperationsInput | number | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: branchUpdateOneRequiredWithoutInventoryNestedInput
    product?: productUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type inventoryUncheckedUpdateInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    branch_id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    reorder_level?: NullableIntFieldUpdateOperationsInput | number | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventoryCreateManyInput = {
    product_id: string
    branch_id: string
    quantity?: number | null
    reorder_level?: number | null
    updated_on?: Date | string | null
  }

  export type inventoryUpdateManyMutationInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    reorder_level?: NullableIntFieldUpdateOperationsInput | number | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventoryUncheckedUpdateManyInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    branch_id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    reorder_level?: NullableIntFieldUpdateOperationsInput | number | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type payment_methodCreateInput = {
    payment_method_name: string
    sales_history?: sales_historyCreateNestedManyWithoutPayment_methodInput
  }

  export type payment_methodUncheckedCreateInput = {
    payment_method_id?: number
    payment_method_name: string
    sales_history?: sales_historyUncheckedCreateNestedManyWithoutPayment_methodInput
  }

  export type payment_methodUpdateInput = {
    payment_method_name?: StringFieldUpdateOperationsInput | string
    sales_history?: sales_historyUpdateManyWithoutPayment_methodNestedInput
  }

  export type payment_methodUncheckedUpdateInput = {
    payment_method_id?: IntFieldUpdateOperationsInput | number
    payment_method_name?: StringFieldUpdateOperationsInput | string
    sales_history?: sales_historyUncheckedUpdateManyWithoutPayment_methodNestedInput
  }

  export type payment_methodCreateManyInput = {
    payment_method_id?: number
    payment_method_name: string
  }

  export type payment_methodUpdateManyMutationInput = {
    payment_method_name?: StringFieldUpdateOperationsInput | string
  }

  export type payment_methodUncheckedUpdateManyInput = {
    payment_method_id?: IntFieldUpdateOperationsInput | number
    payment_method_name?: StringFieldUpdateOperationsInput | string
  }

  export type productCreateInput = {
    product_id?: string
    product_name: string
    product_desc?: string | null
    product_image?: productCreateproduct_imageInput | string[]
    buying_price: Decimal | DecimalJsLike | number | string
    retail_price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    product_barcode: string
    removed?: boolean | null
    created_at?: Date | string | null
    updated_on?: Date | string | null
    cart?: cartCreateNestedManyWithoutProductInput
    inventory?: inventoryCreateNestedManyWithoutProductInput
    category: categoryCreateNestedOneWithoutProductInput
    supplier: supplierCreateNestedOneWithoutProductInput
  }

  export type productUncheckedCreateInput = {
    product_id?: string
    product_name: string
    product_desc?: string | null
    category_id: number
    product_image?: productCreateproduct_imageInput | string[]
    buying_price: Decimal | DecimalJsLike | number | string
    retail_price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    supplier_id: number
    product_barcode: string
    removed?: boolean | null
    created_at?: Date | string | null
    updated_on?: Date | string | null
    cart?: cartUncheckedCreateNestedManyWithoutProductInput
    inventory?: inventoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type productUpdateInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    product_desc?: NullableStringFieldUpdateOperationsInput | string | null
    product_image?: productUpdateproduct_imageInput | string[]
    buying_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_barcode?: StringFieldUpdateOperationsInput | string
    removed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cart?: cartUpdateManyWithoutProductNestedInput
    inventory?: inventoryUpdateManyWithoutProductNestedInput
    category?: categoryUpdateOneRequiredWithoutProductNestedInput
    supplier?: supplierUpdateOneRequiredWithoutProductNestedInput
  }

  export type productUncheckedUpdateInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    product_desc?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: IntFieldUpdateOperationsInput | number
    product_image?: productUpdateproduct_imageInput | string[]
    buying_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier_id?: IntFieldUpdateOperationsInput | number
    product_barcode?: StringFieldUpdateOperationsInput | string
    removed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cart?: cartUncheckedUpdateManyWithoutProductNestedInput
    inventory?: inventoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productCreateManyInput = {
    product_id?: string
    product_name: string
    product_desc?: string | null
    category_id: number
    product_image?: productCreateproduct_imageInput | string[]
    buying_price: Decimal | DecimalJsLike | number | string
    retail_price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    supplier_id: number
    product_barcode: string
    removed?: boolean | null
    created_at?: Date | string | null
    updated_on?: Date | string | null
  }

  export type productUpdateManyMutationInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    product_desc?: NullableStringFieldUpdateOperationsInput | string | null
    product_image?: productUpdateproduct_imageInput | string[]
    buying_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_barcode?: StringFieldUpdateOperationsInput | string
    removed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type productUncheckedUpdateManyInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    product_desc?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: IntFieldUpdateOperationsInput | number
    product_image?: productUpdateproduct_imageInput | string[]
    buying_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier_id?: IntFieldUpdateOperationsInput | number
    product_barcode?: StringFieldUpdateOperationsInput | string
    removed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sales_historyCreateInput = {
    created_at?: Date | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    reference_id?: string | null
    product_count?: number | null
    cart?: cartCreateNestedManyWithoutSales_historyInput
    branch: branchCreateNestedOneWithoutSales_historyInput
    customer?: customerCreateNestedOneWithoutSales_historyInput
    employee: employeeCreateNestedOneWithoutSales_historyInput
    payment_method?: payment_methodCreateNestedOneWithoutSales_historyInput
  }

  export type sales_historyUncheckedCreateInput = {
    order_id?: number
    customer_id?: number | null
    cashier_id: number
    branch_id: string
    created_at?: Date | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    payment_method_id?: number | null
    reference_id?: string | null
    product_count?: number | null
    cart?: cartUncheckedCreateNestedManyWithoutSales_historyInput
  }

  export type sales_historyUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
    cart?: cartUpdateManyWithoutSales_historyNestedInput
    branch?: branchUpdateOneRequiredWithoutSales_historyNestedInput
    customer?: customerUpdateOneWithoutSales_historyNestedInput
    employee?: employeeUpdateOneRequiredWithoutSales_historyNestedInput
    payment_method?: payment_methodUpdateOneWithoutSales_historyNestedInput
  }

  export type sales_historyUncheckedUpdateInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    cashier_id?: IntFieldUpdateOperationsInput | number
    branch_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
    cart?: cartUncheckedUpdateManyWithoutSales_historyNestedInput
  }

  export type sales_historyCreateManyInput = {
    order_id?: number
    customer_id?: number | null
    cashier_id: number
    branch_id: string
    created_at?: Date | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    payment_method_id?: number | null
    reference_id?: string | null
    product_count?: number | null
  }

  export type sales_historyUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type sales_historyUncheckedUpdateManyInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    cashier_id?: IntFieldUpdateOperationsInput | number
    branch_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type supplierCreateInput = {
    supplier_name: string
    supplier_email?: string | null
    supplier_phone: string
    supplier_address: string
    product?: productCreateNestedManyWithoutSupplierInput
  }

  export type supplierUncheckedCreateInput = {
    supplier_id?: number
    supplier_name: string
    supplier_email?: string | null
    supplier_phone: string
    supplier_address: string
    product?: productUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type supplierUpdateInput = {
    supplier_name?: StringFieldUpdateOperationsInput | string
    supplier_email?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_phone?: StringFieldUpdateOperationsInput | string
    supplier_address?: StringFieldUpdateOperationsInput | string
    product?: productUpdateManyWithoutSupplierNestedInput
  }

  export type supplierUncheckedUpdateInput = {
    supplier_id?: IntFieldUpdateOperationsInput | number
    supplier_name?: StringFieldUpdateOperationsInput | string
    supplier_email?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_phone?: StringFieldUpdateOperationsInput | string
    supplier_address?: StringFieldUpdateOperationsInput | string
    product?: productUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type supplierCreateManyInput = {
    supplier_id?: number
    supplier_name: string
    supplier_email?: string | null
    supplier_phone: string
    supplier_address: string
  }

  export type supplierUpdateManyMutationInput = {
    supplier_name?: StringFieldUpdateOperationsInput | string
    supplier_email?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_phone?: StringFieldUpdateOperationsInput | string
    supplier_address?: StringFieldUpdateOperationsInput | string
  }

  export type supplierUncheckedUpdateManyInput = {
    supplier_id?: IntFieldUpdateOperationsInput | number
    supplier_name?: StringFieldUpdateOperationsInput | string
    supplier_email?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_phone?: StringFieldUpdateOperationsInput | string
    supplier_address?: StringFieldUpdateOperationsInput | string
  }

  export type user_credentialsCreateInput = {
    username: string
    password: string
    updated_on?: Date | string | null
    employee: employeeCreateNestedOneWithoutUser_credentialsInput
  }

  export type user_credentialsUncheckedCreateInput = {
    user_id: number
    username: string
    password: string
    updated_on?: Date | string | null
  }

  export type user_credentialsUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: employeeUpdateOneRequiredWithoutUser_credentialsNestedInput
  }

  export type user_credentialsUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_credentialsCreateManyInput = {
    user_id: number
    username: string
    password: string
    updated_on?: Date | string | null
  }

  export type user_credentialsUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_credentialsUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_roleCreateInput = {
    role_name: string
    role_desc: string
    user_access?: user_roleCreateuser_accessInput | number[]
    employee?: employeeCreateNestedManyWithoutUser_roleInput
  }

  export type user_roleUncheckedCreateInput = {
    role_id?: number
    role_name: string
    role_desc: string
    user_access?: user_roleCreateuser_accessInput | number[]
    employee?: employeeUncheckedCreateNestedManyWithoutUser_roleInput
  }

  export type user_roleUpdateInput = {
    role_name?: StringFieldUpdateOperationsInput | string
    role_desc?: StringFieldUpdateOperationsInput | string
    user_access?: user_roleUpdateuser_accessInput | number[]
    employee?: employeeUpdateManyWithoutUser_roleNestedInput
  }

  export type user_roleUncheckedUpdateInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    role_desc?: StringFieldUpdateOperationsInput | string
    user_access?: user_roleUpdateuser_accessInput | number[]
    employee?: employeeUncheckedUpdateManyWithoutUser_roleNestedInput
  }

  export type user_roleCreateManyInput = {
    role_id?: number
    role_name: string
    role_desc: string
    user_access?: user_roleCreateuser_accessInput | number[]
  }

  export type user_roleUpdateManyMutationInput = {
    role_name?: StringFieldUpdateOperationsInput | string
    role_desc?: StringFieldUpdateOperationsInput | string
    user_access?: user_roleUpdateuser_accessInput | number[]
  }

  export type user_roleUncheckedUpdateManyInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    role_desc?: StringFieldUpdateOperationsInput | string
    user_access?: user_roleUpdateuser_accessInput | number[]
  }

  export type variable_optionsCreateInput = {
    variable_name: string
    created_at?: Date | string | null
    variable_value?: Decimal | DecimalJsLike | number | string | null
    updated_on?: Date | string | null
  }

  export type variable_optionsUncheckedCreateInput = {
    variable_id?: number
    variable_name: string
    created_at?: Date | string | null
    variable_value?: Decimal | DecimalJsLike | number | string | null
    updated_on?: Date | string | null
  }

  export type variable_optionsUpdateInput = {
    variable_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variable_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type variable_optionsUncheckedUpdateInput = {
    variable_id?: IntFieldUpdateOperationsInput | number
    variable_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variable_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type variable_optionsCreateManyInput = {
    variable_id?: number
    variable_name: string
    created_at?: Date | string | null
    variable_value?: Decimal | DecimalJsLike | number | string | null
    updated_on?: Date | string | null
  }

  export type variable_optionsUpdateManyMutationInput = {
    variable_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variable_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type variable_optionsUncheckedUpdateManyInput = {
    variable_id?: IntFieldUpdateOperationsInput | number
    variable_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variable_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type working_hourCreateInput = {
    branch_id: string
    date: string
    shift_on: string
    shift_off: string
    present: boolean
    total_hours?: Decimal | DecimalJsLike | number | string | null
    employee: employeeCreateNestedOneWithoutWorking_hourInput
    marked_by: employeeCreateNestedOneWithoutWorking_hour_marked_byInput
  }

  export type working_hourUncheckedCreateInput = {
    employee_id: number
    branch_id: string
    date: string
    shift_on: string
    shift_off: string
    updated_by: number
    present: boolean
    total_hours?: Decimal | DecimalJsLike | number | string | null
  }

  export type working_hourUpdateInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    shift_on?: StringFieldUpdateOperationsInput | string
    shift_off?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    total_hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employee?: employeeUpdateOneRequiredWithoutWorking_hourNestedInput
    marked_by?: employeeUpdateOneRequiredWithoutWorking_hour_marked_byNestedInput
  }

  export type working_hourUncheckedUpdateInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    branch_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    shift_on?: StringFieldUpdateOperationsInput | string
    shift_off?: StringFieldUpdateOperationsInput | string
    updated_by?: IntFieldUpdateOperationsInput | number
    present?: BoolFieldUpdateOperationsInput | boolean
    total_hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type working_hourCreateManyInput = {
    employee_id: number
    branch_id: string
    date: string
    shift_on: string
    shift_off: string
    updated_by: number
    present: boolean
    total_hours?: Decimal | DecimalJsLike | number | string | null
  }

  export type working_hourUpdateManyMutationInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    shift_on?: StringFieldUpdateOperationsInput | string
    shift_off?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    total_hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type working_hourUncheckedUpdateManyInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    branch_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    shift_on?: StringFieldUpdateOperationsInput | string
    shift_off?: StringFieldUpdateOperationsInput | string
    updated_by?: IntFieldUpdateOperationsInput | number
    present?: BoolFieldUpdateOperationsInput | boolean
    total_hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type access_typeCountOrderByAggregateInput = {
    access_type_id?: SortOrder
    access_name?: SortOrder
  }

  export type access_typeAvgOrderByAggregateInput = {
    access_type_id?: SortOrder
  }

  export type access_typeMaxOrderByAggregateInput = {
    access_type_id?: SortOrder
    access_name?: SortOrder
  }

  export type access_typeMinOrderByAggregateInput = {
    access_type_id?: SortOrder
    access_name?: SortOrder
  }

  export type access_typeSumOrderByAggregateInput = {
    access_type_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EmployeeListRelationFilter = {
    every?: employeeWhereInput
    some?: employeeWhereInput
    none?: employeeWhereInput
  }

  export type InventoryListRelationFilter = {
    every?: inventoryWhereInput
    some?: inventoryWhereInput
    none?: inventoryWhereInput
  }

  export type Sales_historyListRelationFilter = {
    every?: sales_historyWhereInput
    some?: sales_historyWhereInput
    none?: sales_historyWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type employeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type inventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sales_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type branchCountOrderByAggregateInput = {
    branch_id?: SortOrder
    branch_city?: SortOrder
    branch_address?: SortOrder
    branch_phone?: SortOrder
    branch_email?: SortOrder
    created_at?: SortOrder
  }

  export type branchMaxOrderByAggregateInput = {
    branch_id?: SortOrder
    branch_city?: SortOrder
    branch_address?: SortOrder
    branch_phone?: SortOrder
    branch_email?: SortOrder
    created_at?: SortOrder
  }

  export type branchMinOrderByAggregateInput = {
    branch_id?: SortOrder
    branch_city?: SortOrder
    branch_address?: SortOrder
    branch_phone?: SortOrder
    branch_email?: SortOrder
    created_at?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ProductScalarRelationFilter = {
    is?: productWhereInput
    isNot?: productWhereInput
  }

  export type Sales_historyNullableScalarRelationFilter = {
    is?: sales_historyWhereInput | null
    isNot?: sales_historyWhereInput | null
  }

  export type cartCountOrderByAggregateInput = {
    cart_id?: SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    sub_total_amount?: SortOrder
    created_at?: SortOrder
  }

  export type cartAvgOrderByAggregateInput = {
    cart_id?: SortOrder
    order_id?: SortOrder
    quantity?: SortOrder
    sub_total_amount?: SortOrder
  }

  export type cartMaxOrderByAggregateInput = {
    cart_id?: SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    sub_total_amount?: SortOrder
    created_at?: SortOrder
  }

  export type cartMinOrderByAggregateInput = {
    cart_id?: SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    sub_total_amount?: SortOrder
    created_at?: SortOrder
  }

  export type cartSumOrderByAggregateInput = {
    cart_id?: SortOrder
    order_id?: SortOrder
    quantity?: SortOrder
    sub_total_amount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ProductListRelationFilter = {
    every?: productWhereInput
    some?: productWhereInput
    none?: productWhereInput
  }

  export type productOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoryCountOrderByAggregateInput = {
    category_id?: SortOrder
    category_name?: SortOrder
  }

  export type categoryAvgOrderByAggregateInput = {
    category_id?: SortOrder
  }

  export type categoryMaxOrderByAggregateInput = {
    category_id?: SortOrder
    category_name?: SortOrder
  }

  export type categoryMinOrderByAggregateInput = {
    category_id?: SortOrder
    category_name?: SortOrder
  }

  export type categorySumOrderByAggregateInput = {
    category_id?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type customerCountOrderByAggregateInput = {
    customer_id?: SortOrder
    customer_name?: SortOrder
    customer_email?: SortOrder
    customer_phone?: SortOrder
    customer_address?: SortOrder
    visit_count?: SortOrder
    rewards_points?: SortOrder
    created_at?: SortOrder
  }

  export type customerAvgOrderByAggregateInput = {
    customer_id?: SortOrder
    visit_count?: SortOrder
    rewards_points?: SortOrder
  }

  export type customerMaxOrderByAggregateInput = {
    customer_id?: SortOrder
    customer_name?: SortOrder
    customer_email?: SortOrder
    customer_phone?: SortOrder
    customer_address?: SortOrder
    visit_count?: SortOrder
    rewards_points?: SortOrder
    created_at?: SortOrder
  }

  export type customerMinOrderByAggregateInput = {
    customer_id?: SortOrder
    customer_name?: SortOrder
    customer_email?: SortOrder
    customer_phone?: SortOrder
    customer_address?: SortOrder
    visit_count?: SortOrder
    rewards_points?: SortOrder
    created_at?: SortOrder
  }

  export type customerSumOrderByAggregateInput = {
    customer_id?: SortOrder
    visit_count?: SortOrder
    rewards_points?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type discountCountOrderByAggregateInput = {
    discount_id?: SortOrder
    discount_name?: SortOrder
    discount_desc?: SortOrder
    discount_percentage?: SortOrder
  }

  export type discountAvgOrderByAggregateInput = {
    discount_id?: SortOrder
    discount_percentage?: SortOrder
  }

  export type discountMaxOrderByAggregateInput = {
    discount_id?: SortOrder
    discount_name?: SortOrder
    discount_desc?: SortOrder
    discount_percentage?: SortOrder
  }

  export type discountMinOrderByAggregateInput = {
    discount_id?: SortOrder
    discount_name?: SortOrder
    discount_desc?: SortOrder
    discount_percentage?: SortOrder
  }

  export type discountSumOrderByAggregateInput = {
    discount_id?: SortOrder
    discount_percentage?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BranchScalarRelationFilter = {
    is?: branchWhereInput
    isNot?: branchWhereInput
  }

  export type User_roleScalarRelationFilter = {
    is?: user_roleWhereInput
    isNot?: user_roleWhereInput
  }

  export type User_credentialsNullableScalarRelationFilter = {
    is?: user_credentialsWhereInput | null
    isNot?: user_credentialsWhereInput | null
  }

  export type Working_hourListRelationFilter = {
    every?: working_hourWhereInput
    some?: working_hourWhereInput
    none?: working_hourWhereInput
  }

  export type working_hourOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type employeeCountOrderByAggregateInput = {
    employee_id?: SortOrder
    employee_name?: SortOrder
    role_id?: SortOrder
    hired_date?: SortOrder
    employee_email?: SortOrder
    employee_phone?: SortOrder
    branch_id?: SortOrder
    employee_image?: SortOrder
    branch_updated_on?: SortOrder
    role_updated_on?: SortOrder
  }

  export type employeeAvgOrderByAggregateInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
  }

  export type employeeMaxOrderByAggregateInput = {
    employee_id?: SortOrder
    employee_name?: SortOrder
    role_id?: SortOrder
    hired_date?: SortOrder
    employee_email?: SortOrder
    employee_phone?: SortOrder
    branch_id?: SortOrder
    employee_image?: SortOrder
    branch_updated_on?: SortOrder
    role_updated_on?: SortOrder
  }

  export type employeeMinOrderByAggregateInput = {
    employee_id?: SortOrder
    employee_name?: SortOrder
    role_id?: SortOrder
    hired_date?: SortOrder
    employee_email?: SortOrder
    employee_phone?: SortOrder
    branch_id?: SortOrder
    employee_image?: SortOrder
    branch_updated_on?: SortOrder
    role_updated_on?: SortOrder
  }

  export type employeeSumOrderByAggregateInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
  }

  export type inventoryProduct_idBranch_idCompoundUniqueInput = {
    product_id: string
    branch_id: string
  }

  export type inventoryCountOrderByAggregateInput = {
    product_id?: SortOrder
    branch_id?: SortOrder
    quantity?: SortOrder
    reorder_level?: SortOrder
    updated_on?: SortOrder
  }

  export type inventoryAvgOrderByAggregateInput = {
    quantity?: SortOrder
    reorder_level?: SortOrder
  }

  export type inventoryMaxOrderByAggregateInput = {
    product_id?: SortOrder
    branch_id?: SortOrder
    quantity?: SortOrder
    reorder_level?: SortOrder
    updated_on?: SortOrder
  }

  export type inventoryMinOrderByAggregateInput = {
    product_id?: SortOrder
    branch_id?: SortOrder
    quantity?: SortOrder
    reorder_level?: SortOrder
    updated_on?: SortOrder
  }

  export type inventorySumOrderByAggregateInput = {
    quantity?: SortOrder
    reorder_level?: SortOrder
  }

  export type payment_methodCountOrderByAggregateInput = {
    payment_method_id?: SortOrder
    payment_method_name?: SortOrder
  }

  export type payment_methodAvgOrderByAggregateInput = {
    payment_method_id?: SortOrder
  }

  export type payment_methodMaxOrderByAggregateInput = {
    payment_method_id?: SortOrder
    payment_method_name?: SortOrder
  }

  export type payment_methodMinOrderByAggregateInput = {
    payment_method_id?: SortOrder
    payment_method_name?: SortOrder
  }

  export type payment_methodSumOrderByAggregateInput = {
    payment_method_id?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type CartListRelationFilter = {
    every?: cartWhereInput
    some?: cartWhereInput
    none?: cartWhereInput
  }

  export type CategoryScalarRelationFilter = {
    is?: categoryWhereInput
    isNot?: categoryWhereInput
  }

  export type SupplierScalarRelationFilter = {
    is?: supplierWhereInput
    isNot?: supplierWhereInput
  }

  export type cartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productCountOrderByAggregateInput = {
    product_id?: SortOrder
    product_name?: SortOrder
    product_desc?: SortOrder
    category_id?: SortOrder
    product_image?: SortOrder
    buying_price?: SortOrder
    retail_price?: SortOrder
    discount?: SortOrder
    supplier_id?: SortOrder
    product_barcode?: SortOrder
    removed?: SortOrder
    created_at?: SortOrder
    updated_on?: SortOrder
  }

  export type productAvgOrderByAggregateInput = {
    category_id?: SortOrder
    buying_price?: SortOrder
    retail_price?: SortOrder
    discount?: SortOrder
    supplier_id?: SortOrder
  }

  export type productMaxOrderByAggregateInput = {
    product_id?: SortOrder
    product_name?: SortOrder
    product_desc?: SortOrder
    category_id?: SortOrder
    buying_price?: SortOrder
    retail_price?: SortOrder
    discount?: SortOrder
    supplier_id?: SortOrder
    product_barcode?: SortOrder
    removed?: SortOrder
    created_at?: SortOrder
    updated_on?: SortOrder
  }

  export type productMinOrderByAggregateInput = {
    product_id?: SortOrder
    product_name?: SortOrder
    product_desc?: SortOrder
    category_id?: SortOrder
    buying_price?: SortOrder
    retail_price?: SortOrder
    discount?: SortOrder
    supplier_id?: SortOrder
    product_barcode?: SortOrder
    removed?: SortOrder
    created_at?: SortOrder
    updated_on?: SortOrder
  }

  export type productSumOrderByAggregateInput = {
    category_id?: SortOrder
    buying_price?: SortOrder
    retail_price?: SortOrder
    discount?: SortOrder
    supplier_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: customerWhereInput | null
    isNot?: customerWhereInput | null
  }

  export type EmployeeScalarRelationFilter = {
    is?: employeeWhereInput
    isNot?: employeeWhereInput
  }

  export type Payment_methodNullableScalarRelationFilter = {
    is?: payment_methodWhereInput | null
    isNot?: payment_methodWhereInput | null
  }

  export type sales_historyCountOrderByAggregateInput = {
    order_id?: SortOrder
    customer_id?: SortOrder
    cashier_id?: SortOrder
    branch_id?: SortOrder
    created_at?: SortOrder
    total_amount?: SortOrder
    profit?: SortOrder
    rewards_points?: SortOrder
    payment_method_id?: SortOrder
    reference_id?: SortOrder
    product_count?: SortOrder
  }

  export type sales_historyAvgOrderByAggregateInput = {
    order_id?: SortOrder
    customer_id?: SortOrder
    cashier_id?: SortOrder
    total_amount?: SortOrder
    profit?: SortOrder
    rewards_points?: SortOrder
    payment_method_id?: SortOrder
    product_count?: SortOrder
  }

  export type sales_historyMaxOrderByAggregateInput = {
    order_id?: SortOrder
    customer_id?: SortOrder
    cashier_id?: SortOrder
    branch_id?: SortOrder
    created_at?: SortOrder
    total_amount?: SortOrder
    profit?: SortOrder
    rewards_points?: SortOrder
    payment_method_id?: SortOrder
    reference_id?: SortOrder
    product_count?: SortOrder
  }

  export type sales_historyMinOrderByAggregateInput = {
    order_id?: SortOrder
    customer_id?: SortOrder
    cashier_id?: SortOrder
    branch_id?: SortOrder
    created_at?: SortOrder
    total_amount?: SortOrder
    profit?: SortOrder
    rewards_points?: SortOrder
    payment_method_id?: SortOrder
    reference_id?: SortOrder
    product_count?: SortOrder
  }

  export type sales_historySumOrderByAggregateInput = {
    order_id?: SortOrder
    customer_id?: SortOrder
    cashier_id?: SortOrder
    total_amount?: SortOrder
    profit?: SortOrder
    rewards_points?: SortOrder
    payment_method_id?: SortOrder
    product_count?: SortOrder
  }

  export type supplierCountOrderByAggregateInput = {
    supplier_id?: SortOrder
    supplier_name?: SortOrder
    supplier_email?: SortOrder
    supplier_phone?: SortOrder
    supplier_address?: SortOrder
  }

  export type supplierAvgOrderByAggregateInput = {
    supplier_id?: SortOrder
  }

  export type supplierMaxOrderByAggregateInput = {
    supplier_id?: SortOrder
    supplier_name?: SortOrder
    supplier_email?: SortOrder
    supplier_phone?: SortOrder
    supplier_address?: SortOrder
  }

  export type supplierMinOrderByAggregateInput = {
    supplier_id?: SortOrder
    supplier_name?: SortOrder
    supplier_email?: SortOrder
    supplier_phone?: SortOrder
    supplier_address?: SortOrder
  }

  export type supplierSumOrderByAggregateInput = {
    supplier_id?: SortOrder
  }

  export type user_credentialsCountOrderByAggregateInput = {
    user_id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    updated_on?: SortOrder
  }

  export type user_credentialsAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type user_credentialsMaxOrderByAggregateInput = {
    user_id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    updated_on?: SortOrder
  }

  export type user_credentialsMinOrderByAggregateInput = {
    user_id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    updated_on?: SortOrder
  }

  export type user_credentialsSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type user_roleCountOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    role_desc?: SortOrder
    user_access?: SortOrder
  }

  export type user_roleAvgOrderByAggregateInput = {
    role_id?: SortOrder
    user_access?: SortOrder
  }

  export type user_roleMaxOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    role_desc?: SortOrder
  }

  export type user_roleMinOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    role_desc?: SortOrder
  }

  export type user_roleSumOrderByAggregateInput = {
    role_id?: SortOrder
    user_access?: SortOrder
  }

  export type variable_optionsCountOrderByAggregateInput = {
    variable_id?: SortOrder
    variable_name?: SortOrder
    created_at?: SortOrder
    variable_value?: SortOrder
    updated_on?: SortOrder
  }

  export type variable_optionsAvgOrderByAggregateInput = {
    variable_id?: SortOrder
    variable_value?: SortOrder
  }

  export type variable_optionsMaxOrderByAggregateInput = {
    variable_id?: SortOrder
    variable_name?: SortOrder
    created_at?: SortOrder
    variable_value?: SortOrder
    updated_on?: SortOrder
  }

  export type variable_optionsMinOrderByAggregateInput = {
    variable_id?: SortOrder
    variable_name?: SortOrder
    created_at?: SortOrder
    variable_value?: SortOrder
    updated_on?: SortOrder
  }

  export type variable_optionsSumOrderByAggregateInput = {
    variable_id?: SortOrder
    variable_value?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type working_hourEmployee_idBranch_idDateCompoundUniqueInput = {
    employee_id: number
    branch_id: string
    date: string
  }

  export type working_hourCountOrderByAggregateInput = {
    employee_id?: SortOrder
    branch_id?: SortOrder
    date?: SortOrder
    shift_on?: SortOrder
    shift_off?: SortOrder
    updated_by?: SortOrder
    present?: SortOrder
    total_hours?: SortOrder
  }

  export type working_hourAvgOrderByAggregateInput = {
    employee_id?: SortOrder
    updated_by?: SortOrder
    total_hours?: SortOrder
  }

  export type working_hourMaxOrderByAggregateInput = {
    employee_id?: SortOrder
    branch_id?: SortOrder
    date?: SortOrder
    shift_on?: SortOrder
    shift_off?: SortOrder
    updated_by?: SortOrder
    present?: SortOrder
    total_hours?: SortOrder
  }

  export type working_hourMinOrderByAggregateInput = {
    employee_id?: SortOrder
    branch_id?: SortOrder
    date?: SortOrder
    shift_on?: SortOrder
    shift_off?: SortOrder
    updated_by?: SortOrder
    present?: SortOrder
    total_hours?: SortOrder
  }

  export type working_hourSumOrderByAggregateInput = {
    employee_id?: SortOrder
    updated_by?: SortOrder
    total_hours?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type employeeCreateNestedManyWithoutBranchInput = {
    create?: XOR<employeeCreateWithoutBranchInput, employeeUncheckedCreateWithoutBranchInput> | employeeCreateWithoutBranchInput[] | employeeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutBranchInput | employeeCreateOrConnectWithoutBranchInput[]
    createMany?: employeeCreateManyBranchInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type inventoryCreateNestedManyWithoutBranchInput = {
    create?: XOR<inventoryCreateWithoutBranchInput, inventoryUncheckedCreateWithoutBranchInput> | inventoryCreateWithoutBranchInput[] | inventoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: inventoryCreateOrConnectWithoutBranchInput | inventoryCreateOrConnectWithoutBranchInput[]
    createMany?: inventoryCreateManyBranchInputEnvelope
    connect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
  }

  export type sales_historyCreateNestedManyWithoutBranchInput = {
    create?: XOR<sales_historyCreateWithoutBranchInput, sales_historyUncheckedCreateWithoutBranchInput> | sales_historyCreateWithoutBranchInput[] | sales_historyUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: sales_historyCreateOrConnectWithoutBranchInput | sales_historyCreateOrConnectWithoutBranchInput[]
    createMany?: sales_historyCreateManyBranchInputEnvelope
    connect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
  }

  export type employeeUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<employeeCreateWithoutBranchInput, employeeUncheckedCreateWithoutBranchInput> | employeeCreateWithoutBranchInput[] | employeeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutBranchInput | employeeCreateOrConnectWithoutBranchInput[]
    createMany?: employeeCreateManyBranchInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type inventoryUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<inventoryCreateWithoutBranchInput, inventoryUncheckedCreateWithoutBranchInput> | inventoryCreateWithoutBranchInput[] | inventoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: inventoryCreateOrConnectWithoutBranchInput | inventoryCreateOrConnectWithoutBranchInput[]
    createMany?: inventoryCreateManyBranchInputEnvelope
    connect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
  }

  export type sales_historyUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<sales_historyCreateWithoutBranchInput, sales_historyUncheckedCreateWithoutBranchInput> | sales_historyCreateWithoutBranchInput[] | sales_historyUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: sales_historyCreateOrConnectWithoutBranchInput | sales_historyCreateOrConnectWithoutBranchInput[]
    createMany?: sales_historyCreateManyBranchInputEnvelope
    connect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type employeeUpdateManyWithoutBranchNestedInput = {
    create?: XOR<employeeCreateWithoutBranchInput, employeeUncheckedCreateWithoutBranchInput> | employeeCreateWithoutBranchInput[] | employeeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutBranchInput | employeeCreateOrConnectWithoutBranchInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutBranchInput | employeeUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: employeeCreateManyBranchInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutBranchInput | employeeUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutBranchInput | employeeUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type inventoryUpdateManyWithoutBranchNestedInput = {
    create?: XOR<inventoryCreateWithoutBranchInput, inventoryUncheckedCreateWithoutBranchInput> | inventoryCreateWithoutBranchInput[] | inventoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: inventoryCreateOrConnectWithoutBranchInput | inventoryCreateOrConnectWithoutBranchInput[]
    upsert?: inventoryUpsertWithWhereUniqueWithoutBranchInput | inventoryUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: inventoryCreateManyBranchInputEnvelope
    set?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    disconnect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    delete?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    connect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    update?: inventoryUpdateWithWhereUniqueWithoutBranchInput | inventoryUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: inventoryUpdateManyWithWhereWithoutBranchInput | inventoryUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: inventoryScalarWhereInput | inventoryScalarWhereInput[]
  }

  export type sales_historyUpdateManyWithoutBranchNestedInput = {
    create?: XOR<sales_historyCreateWithoutBranchInput, sales_historyUncheckedCreateWithoutBranchInput> | sales_historyCreateWithoutBranchInput[] | sales_historyUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: sales_historyCreateOrConnectWithoutBranchInput | sales_historyCreateOrConnectWithoutBranchInput[]
    upsert?: sales_historyUpsertWithWhereUniqueWithoutBranchInput | sales_historyUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: sales_historyCreateManyBranchInputEnvelope
    set?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    disconnect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    delete?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    connect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    update?: sales_historyUpdateWithWhereUniqueWithoutBranchInput | sales_historyUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: sales_historyUpdateManyWithWhereWithoutBranchInput | sales_historyUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: sales_historyScalarWhereInput | sales_historyScalarWhereInput[]
  }

  export type employeeUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<employeeCreateWithoutBranchInput, employeeUncheckedCreateWithoutBranchInput> | employeeCreateWithoutBranchInput[] | employeeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutBranchInput | employeeCreateOrConnectWithoutBranchInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutBranchInput | employeeUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: employeeCreateManyBranchInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutBranchInput | employeeUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutBranchInput | employeeUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type inventoryUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<inventoryCreateWithoutBranchInput, inventoryUncheckedCreateWithoutBranchInput> | inventoryCreateWithoutBranchInput[] | inventoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: inventoryCreateOrConnectWithoutBranchInput | inventoryCreateOrConnectWithoutBranchInput[]
    upsert?: inventoryUpsertWithWhereUniqueWithoutBranchInput | inventoryUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: inventoryCreateManyBranchInputEnvelope
    set?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    disconnect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    delete?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    connect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    update?: inventoryUpdateWithWhereUniqueWithoutBranchInput | inventoryUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: inventoryUpdateManyWithWhereWithoutBranchInput | inventoryUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: inventoryScalarWhereInput | inventoryScalarWhereInput[]
  }

  export type sales_historyUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<sales_historyCreateWithoutBranchInput, sales_historyUncheckedCreateWithoutBranchInput> | sales_historyCreateWithoutBranchInput[] | sales_historyUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: sales_historyCreateOrConnectWithoutBranchInput | sales_historyCreateOrConnectWithoutBranchInput[]
    upsert?: sales_historyUpsertWithWhereUniqueWithoutBranchInput | sales_historyUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: sales_historyCreateManyBranchInputEnvelope
    set?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    disconnect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    delete?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    connect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    update?: sales_historyUpdateWithWhereUniqueWithoutBranchInput | sales_historyUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: sales_historyUpdateManyWithWhereWithoutBranchInput | sales_historyUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: sales_historyScalarWhereInput | sales_historyScalarWhereInput[]
  }

  export type productCreateNestedOneWithoutCartInput = {
    create?: XOR<productCreateWithoutCartInput, productUncheckedCreateWithoutCartInput>
    connectOrCreate?: productCreateOrConnectWithoutCartInput
    connect?: productWhereUniqueInput
  }

  export type sales_historyCreateNestedOneWithoutCartInput = {
    create?: XOR<sales_historyCreateWithoutCartInput, sales_historyUncheckedCreateWithoutCartInput>
    connectOrCreate?: sales_historyCreateOrConnectWithoutCartInput
    connect?: sales_historyWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type productUpdateOneRequiredWithoutCartNestedInput = {
    create?: XOR<productCreateWithoutCartInput, productUncheckedCreateWithoutCartInput>
    connectOrCreate?: productCreateOrConnectWithoutCartInput
    upsert?: productUpsertWithoutCartInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutCartInput, productUpdateWithoutCartInput>, productUncheckedUpdateWithoutCartInput>
  }

  export type sales_historyUpdateOneWithoutCartNestedInput = {
    create?: XOR<sales_historyCreateWithoutCartInput, sales_historyUncheckedCreateWithoutCartInput>
    connectOrCreate?: sales_historyCreateOrConnectWithoutCartInput
    upsert?: sales_historyUpsertWithoutCartInput
    disconnect?: sales_historyWhereInput | boolean
    delete?: sales_historyWhereInput | boolean
    connect?: sales_historyWhereUniqueInput
    update?: XOR<XOR<sales_historyUpdateToOneWithWhereWithoutCartInput, sales_historyUpdateWithoutCartInput>, sales_historyUncheckedUpdateWithoutCartInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type productCreateNestedManyWithoutCategoryInput = {
    create?: XOR<productCreateWithoutCategoryInput, productUncheckedCreateWithoutCategoryInput> | productCreateWithoutCategoryInput[] | productUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: productCreateOrConnectWithoutCategoryInput | productCreateOrConnectWithoutCategoryInput[]
    createMany?: productCreateManyCategoryInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type productUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<productCreateWithoutCategoryInput, productUncheckedCreateWithoutCategoryInput> | productCreateWithoutCategoryInput[] | productUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: productCreateOrConnectWithoutCategoryInput | productCreateOrConnectWithoutCategoryInput[]
    createMany?: productCreateManyCategoryInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type productUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<productCreateWithoutCategoryInput, productUncheckedCreateWithoutCategoryInput> | productCreateWithoutCategoryInput[] | productUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: productCreateOrConnectWithoutCategoryInput | productCreateOrConnectWithoutCategoryInput[]
    upsert?: productUpsertWithWhereUniqueWithoutCategoryInput | productUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: productCreateManyCategoryInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutCategoryInput | productUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: productUpdateManyWithWhereWithoutCategoryInput | productUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type productUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<productCreateWithoutCategoryInput, productUncheckedCreateWithoutCategoryInput> | productCreateWithoutCategoryInput[] | productUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: productCreateOrConnectWithoutCategoryInput | productCreateOrConnectWithoutCategoryInput[]
    upsert?: productUpsertWithWhereUniqueWithoutCategoryInput | productUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: productCreateManyCategoryInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutCategoryInput | productUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: productUpdateManyWithWhereWithoutCategoryInput | productUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type sales_historyCreateNestedManyWithoutCustomerInput = {
    create?: XOR<sales_historyCreateWithoutCustomerInput, sales_historyUncheckedCreateWithoutCustomerInput> | sales_historyCreateWithoutCustomerInput[] | sales_historyUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: sales_historyCreateOrConnectWithoutCustomerInput | sales_historyCreateOrConnectWithoutCustomerInput[]
    createMany?: sales_historyCreateManyCustomerInputEnvelope
    connect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
  }

  export type sales_historyUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<sales_historyCreateWithoutCustomerInput, sales_historyUncheckedCreateWithoutCustomerInput> | sales_historyCreateWithoutCustomerInput[] | sales_historyUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: sales_historyCreateOrConnectWithoutCustomerInput | sales_historyCreateOrConnectWithoutCustomerInput[]
    createMany?: sales_historyCreateManyCustomerInputEnvelope
    connect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type sales_historyUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<sales_historyCreateWithoutCustomerInput, sales_historyUncheckedCreateWithoutCustomerInput> | sales_historyCreateWithoutCustomerInput[] | sales_historyUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: sales_historyCreateOrConnectWithoutCustomerInput | sales_historyCreateOrConnectWithoutCustomerInput[]
    upsert?: sales_historyUpsertWithWhereUniqueWithoutCustomerInput | sales_historyUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: sales_historyCreateManyCustomerInputEnvelope
    set?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    disconnect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    delete?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    connect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    update?: sales_historyUpdateWithWhereUniqueWithoutCustomerInput | sales_historyUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: sales_historyUpdateManyWithWhereWithoutCustomerInput | sales_historyUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: sales_historyScalarWhereInput | sales_historyScalarWhereInput[]
  }

  export type sales_historyUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<sales_historyCreateWithoutCustomerInput, sales_historyUncheckedCreateWithoutCustomerInput> | sales_historyCreateWithoutCustomerInput[] | sales_historyUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: sales_historyCreateOrConnectWithoutCustomerInput | sales_historyCreateOrConnectWithoutCustomerInput[]
    upsert?: sales_historyUpsertWithWhereUniqueWithoutCustomerInput | sales_historyUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: sales_historyCreateManyCustomerInputEnvelope
    set?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    disconnect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    delete?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    connect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    update?: sales_historyUpdateWithWhereUniqueWithoutCustomerInput | sales_historyUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: sales_historyUpdateManyWithWhereWithoutCustomerInput | sales_historyUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: sales_historyScalarWhereInput | sales_historyScalarWhereInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type branchCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<branchCreateWithoutEmployeeInput, branchUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: branchCreateOrConnectWithoutEmployeeInput
    connect?: branchWhereUniqueInput
  }

  export type user_roleCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<user_roleCreateWithoutEmployeeInput, user_roleUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: user_roleCreateOrConnectWithoutEmployeeInput
    connect?: user_roleWhereUniqueInput
  }

  export type sales_historyCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<sales_historyCreateWithoutEmployeeInput, sales_historyUncheckedCreateWithoutEmployeeInput> | sales_historyCreateWithoutEmployeeInput[] | sales_historyUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: sales_historyCreateOrConnectWithoutEmployeeInput | sales_historyCreateOrConnectWithoutEmployeeInput[]
    createMany?: sales_historyCreateManyEmployeeInputEnvelope
    connect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
  }

  export type user_credentialsCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<user_credentialsCreateWithoutEmployeeInput, user_credentialsUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: user_credentialsCreateOrConnectWithoutEmployeeInput
    connect?: user_credentialsWhereUniqueInput
  }

  export type working_hourCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<working_hourCreateWithoutEmployeeInput, working_hourUncheckedCreateWithoutEmployeeInput> | working_hourCreateWithoutEmployeeInput[] | working_hourUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: working_hourCreateOrConnectWithoutEmployeeInput | working_hourCreateOrConnectWithoutEmployeeInput[]
    createMany?: working_hourCreateManyEmployeeInputEnvelope
    connect?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
  }

  export type working_hourCreateNestedManyWithoutMarked_byInput = {
    create?: XOR<working_hourCreateWithoutMarked_byInput, working_hourUncheckedCreateWithoutMarked_byInput> | working_hourCreateWithoutMarked_byInput[] | working_hourUncheckedCreateWithoutMarked_byInput[]
    connectOrCreate?: working_hourCreateOrConnectWithoutMarked_byInput | working_hourCreateOrConnectWithoutMarked_byInput[]
    createMany?: working_hourCreateManyMarked_byInputEnvelope
    connect?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
  }

  export type sales_historyUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<sales_historyCreateWithoutEmployeeInput, sales_historyUncheckedCreateWithoutEmployeeInput> | sales_historyCreateWithoutEmployeeInput[] | sales_historyUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: sales_historyCreateOrConnectWithoutEmployeeInput | sales_historyCreateOrConnectWithoutEmployeeInput[]
    createMany?: sales_historyCreateManyEmployeeInputEnvelope
    connect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
  }

  export type user_credentialsUncheckedCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<user_credentialsCreateWithoutEmployeeInput, user_credentialsUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: user_credentialsCreateOrConnectWithoutEmployeeInput
    connect?: user_credentialsWhereUniqueInput
  }

  export type working_hourUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<working_hourCreateWithoutEmployeeInput, working_hourUncheckedCreateWithoutEmployeeInput> | working_hourCreateWithoutEmployeeInput[] | working_hourUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: working_hourCreateOrConnectWithoutEmployeeInput | working_hourCreateOrConnectWithoutEmployeeInput[]
    createMany?: working_hourCreateManyEmployeeInputEnvelope
    connect?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
  }

  export type working_hourUncheckedCreateNestedManyWithoutMarked_byInput = {
    create?: XOR<working_hourCreateWithoutMarked_byInput, working_hourUncheckedCreateWithoutMarked_byInput> | working_hourCreateWithoutMarked_byInput[] | working_hourUncheckedCreateWithoutMarked_byInput[]
    connectOrCreate?: working_hourCreateOrConnectWithoutMarked_byInput | working_hourCreateOrConnectWithoutMarked_byInput[]
    createMany?: working_hourCreateManyMarked_byInputEnvelope
    connect?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
  }

  export type branchUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<branchCreateWithoutEmployeeInput, branchUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: branchCreateOrConnectWithoutEmployeeInput
    upsert?: branchUpsertWithoutEmployeeInput
    connect?: branchWhereUniqueInput
    update?: XOR<XOR<branchUpdateToOneWithWhereWithoutEmployeeInput, branchUpdateWithoutEmployeeInput>, branchUncheckedUpdateWithoutEmployeeInput>
  }

  export type user_roleUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<user_roleCreateWithoutEmployeeInput, user_roleUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: user_roleCreateOrConnectWithoutEmployeeInput
    upsert?: user_roleUpsertWithoutEmployeeInput
    connect?: user_roleWhereUniqueInput
    update?: XOR<XOR<user_roleUpdateToOneWithWhereWithoutEmployeeInput, user_roleUpdateWithoutEmployeeInput>, user_roleUncheckedUpdateWithoutEmployeeInput>
  }

  export type sales_historyUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<sales_historyCreateWithoutEmployeeInput, sales_historyUncheckedCreateWithoutEmployeeInput> | sales_historyCreateWithoutEmployeeInput[] | sales_historyUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: sales_historyCreateOrConnectWithoutEmployeeInput | sales_historyCreateOrConnectWithoutEmployeeInput[]
    upsert?: sales_historyUpsertWithWhereUniqueWithoutEmployeeInput | sales_historyUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: sales_historyCreateManyEmployeeInputEnvelope
    set?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    disconnect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    delete?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    connect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    update?: sales_historyUpdateWithWhereUniqueWithoutEmployeeInput | sales_historyUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: sales_historyUpdateManyWithWhereWithoutEmployeeInput | sales_historyUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: sales_historyScalarWhereInput | sales_historyScalarWhereInput[]
  }

  export type user_credentialsUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<user_credentialsCreateWithoutEmployeeInput, user_credentialsUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: user_credentialsCreateOrConnectWithoutEmployeeInput
    upsert?: user_credentialsUpsertWithoutEmployeeInput
    disconnect?: user_credentialsWhereInput | boolean
    delete?: user_credentialsWhereInput | boolean
    connect?: user_credentialsWhereUniqueInput
    update?: XOR<XOR<user_credentialsUpdateToOneWithWhereWithoutEmployeeInput, user_credentialsUpdateWithoutEmployeeInput>, user_credentialsUncheckedUpdateWithoutEmployeeInput>
  }

  export type working_hourUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<working_hourCreateWithoutEmployeeInput, working_hourUncheckedCreateWithoutEmployeeInput> | working_hourCreateWithoutEmployeeInput[] | working_hourUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: working_hourCreateOrConnectWithoutEmployeeInput | working_hourCreateOrConnectWithoutEmployeeInput[]
    upsert?: working_hourUpsertWithWhereUniqueWithoutEmployeeInput | working_hourUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: working_hourCreateManyEmployeeInputEnvelope
    set?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
    disconnect?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
    delete?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
    connect?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
    update?: working_hourUpdateWithWhereUniqueWithoutEmployeeInput | working_hourUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: working_hourUpdateManyWithWhereWithoutEmployeeInput | working_hourUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: working_hourScalarWhereInput | working_hourScalarWhereInput[]
  }

  export type working_hourUpdateManyWithoutMarked_byNestedInput = {
    create?: XOR<working_hourCreateWithoutMarked_byInput, working_hourUncheckedCreateWithoutMarked_byInput> | working_hourCreateWithoutMarked_byInput[] | working_hourUncheckedCreateWithoutMarked_byInput[]
    connectOrCreate?: working_hourCreateOrConnectWithoutMarked_byInput | working_hourCreateOrConnectWithoutMarked_byInput[]
    upsert?: working_hourUpsertWithWhereUniqueWithoutMarked_byInput | working_hourUpsertWithWhereUniqueWithoutMarked_byInput[]
    createMany?: working_hourCreateManyMarked_byInputEnvelope
    set?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
    disconnect?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
    delete?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
    connect?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
    update?: working_hourUpdateWithWhereUniqueWithoutMarked_byInput | working_hourUpdateWithWhereUniqueWithoutMarked_byInput[]
    updateMany?: working_hourUpdateManyWithWhereWithoutMarked_byInput | working_hourUpdateManyWithWhereWithoutMarked_byInput[]
    deleteMany?: working_hourScalarWhereInput | working_hourScalarWhereInput[]
  }

  export type sales_historyUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<sales_historyCreateWithoutEmployeeInput, sales_historyUncheckedCreateWithoutEmployeeInput> | sales_historyCreateWithoutEmployeeInput[] | sales_historyUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: sales_historyCreateOrConnectWithoutEmployeeInput | sales_historyCreateOrConnectWithoutEmployeeInput[]
    upsert?: sales_historyUpsertWithWhereUniqueWithoutEmployeeInput | sales_historyUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: sales_historyCreateManyEmployeeInputEnvelope
    set?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    disconnect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    delete?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    connect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    update?: sales_historyUpdateWithWhereUniqueWithoutEmployeeInput | sales_historyUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: sales_historyUpdateManyWithWhereWithoutEmployeeInput | sales_historyUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: sales_historyScalarWhereInput | sales_historyScalarWhereInput[]
  }

  export type user_credentialsUncheckedUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<user_credentialsCreateWithoutEmployeeInput, user_credentialsUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: user_credentialsCreateOrConnectWithoutEmployeeInput
    upsert?: user_credentialsUpsertWithoutEmployeeInput
    disconnect?: user_credentialsWhereInput | boolean
    delete?: user_credentialsWhereInput | boolean
    connect?: user_credentialsWhereUniqueInput
    update?: XOR<XOR<user_credentialsUpdateToOneWithWhereWithoutEmployeeInput, user_credentialsUpdateWithoutEmployeeInput>, user_credentialsUncheckedUpdateWithoutEmployeeInput>
  }

  export type working_hourUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<working_hourCreateWithoutEmployeeInput, working_hourUncheckedCreateWithoutEmployeeInput> | working_hourCreateWithoutEmployeeInput[] | working_hourUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: working_hourCreateOrConnectWithoutEmployeeInput | working_hourCreateOrConnectWithoutEmployeeInput[]
    upsert?: working_hourUpsertWithWhereUniqueWithoutEmployeeInput | working_hourUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: working_hourCreateManyEmployeeInputEnvelope
    set?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
    disconnect?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
    delete?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
    connect?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
    update?: working_hourUpdateWithWhereUniqueWithoutEmployeeInput | working_hourUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: working_hourUpdateManyWithWhereWithoutEmployeeInput | working_hourUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: working_hourScalarWhereInput | working_hourScalarWhereInput[]
  }

  export type working_hourUncheckedUpdateManyWithoutMarked_byNestedInput = {
    create?: XOR<working_hourCreateWithoutMarked_byInput, working_hourUncheckedCreateWithoutMarked_byInput> | working_hourCreateWithoutMarked_byInput[] | working_hourUncheckedCreateWithoutMarked_byInput[]
    connectOrCreate?: working_hourCreateOrConnectWithoutMarked_byInput | working_hourCreateOrConnectWithoutMarked_byInput[]
    upsert?: working_hourUpsertWithWhereUniqueWithoutMarked_byInput | working_hourUpsertWithWhereUniqueWithoutMarked_byInput[]
    createMany?: working_hourCreateManyMarked_byInputEnvelope
    set?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
    disconnect?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
    delete?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
    connect?: working_hourWhereUniqueInput | working_hourWhereUniqueInput[]
    update?: working_hourUpdateWithWhereUniqueWithoutMarked_byInput | working_hourUpdateWithWhereUniqueWithoutMarked_byInput[]
    updateMany?: working_hourUpdateManyWithWhereWithoutMarked_byInput | working_hourUpdateManyWithWhereWithoutMarked_byInput[]
    deleteMany?: working_hourScalarWhereInput | working_hourScalarWhereInput[]
  }

  export type branchCreateNestedOneWithoutInventoryInput = {
    create?: XOR<branchCreateWithoutInventoryInput, branchUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: branchCreateOrConnectWithoutInventoryInput
    connect?: branchWhereUniqueInput
  }

  export type productCreateNestedOneWithoutInventoryInput = {
    create?: XOR<productCreateWithoutInventoryInput, productUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: productCreateOrConnectWithoutInventoryInput
    connect?: productWhereUniqueInput
  }

  export type branchUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<branchCreateWithoutInventoryInput, branchUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: branchCreateOrConnectWithoutInventoryInput
    upsert?: branchUpsertWithoutInventoryInput
    connect?: branchWhereUniqueInput
    update?: XOR<XOR<branchUpdateToOneWithWhereWithoutInventoryInput, branchUpdateWithoutInventoryInput>, branchUncheckedUpdateWithoutInventoryInput>
  }

  export type productUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<productCreateWithoutInventoryInput, productUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: productCreateOrConnectWithoutInventoryInput
    upsert?: productUpsertWithoutInventoryInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutInventoryInput, productUpdateWithoutInventoryInput>, productUncheckedUpdateWithoutInventoryInput>
  }

  export type sales_historyCreateNestedManyWithoutPayment_methodInput = {
    create?: XOR<sales_historyCreateWithoutPayment_methodInput, sales_historyUncheckedCreateWithoutPayment_methodInput> | sales_historyCreateWithoutPayment_methodInput[] | sales_historyUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: sales_historyCreateOrConnectWithoutPayment_methodInput | sales_historyCreateOrConnectWithoutPayment_methodInput[]
    createMany?: sales_historyCreateManyPayment_methodInputEnvelope
    connect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
  }

  export type sales_historyUncheckedCreateNestedManyWithoutPayment_methodInput = {
    create?: XOR<sales_historyCreateWithoutPayment_methodInput, sales_historyUncheckedCreateWithoutPayment_methodInput> | sales_historyCreateWithoutPayment_methodInput[] | sales_historyUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: sales_historyCreateOrConnectWithoutPayment_methodInput | sales_historyCreateOrConnectWithoutPayment_methodInput[]
    createMany?: sales_historyCreateManyPayment_methodInputEnvelope
    connect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
  }

  export type sales_historyUpdateManyWithoutPayment_methodNestedInput = {
    create?: XOR<sales_historyCreateWithoutPayment_methodInput, sales_historyUncheckedCreateWithoutPayment_methodInput> | sales_historyCreateWithoutPayment_methodInput[] | sales_historyUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: sales_historyCreateOrConnectWithoutPayment_methodInput | sales_historyCreateOrConnectWithoutPayment_methodInput[]
    upsert?: sales_historyUpsertWithWhereUniqueWithoutPayment_methodInput | sales_historyUpsertWithWhereUniqueWithoutPayment_methodInput[]
    createMany?: sales_historyCreateManyPayment_methodInputEnvelope
    set?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    disconnect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    delete?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    connect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    update?: sales_historyUpdateWithWhereUniqueWithoutPayment_methodInput | sales_historyUpdateWithWhereUniqueWithoutPayment_methodInput[]
    updateMany?: sales_historyUpdateManyWithWhereWithoutPayment_methodInput | sales_historyUpdateManyWithWhereWithoutPayment_methodInput[]
    deleteMany?: sales_historyScalarWhereInput | sales_historyScalarWhereInput[]
  }

  export type sales_historyUncheckedUpdateManyWithoutPayment_methodNestedInput = {
    create?: XOR<sales_historyCreateWithoutPayment_methodInput, sales_historyUncheckedCreateWithoutPayment_methodInput> | sales_historyCreateWithoutPayment_methodInput[] | sales_historyUncheckedCreateWithoutPayment_methodInput[]
    connectOrCreate?: sales_historyCreateOrConnectWithoutPayment_methodInput | sales_historyCreateOrConnectWithoutPayment_methodInput[]
    upsert?: sales_historyUpsertWithWhereUniqueWithoutPayment_methodInput | sales_historyUpsertWithWhereUniqueWithoutPayment_methodInput[]
    createMany?: sales_historyCreateManyPayment_methodInputEnvelope
    set?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    disconnect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    delete?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    connect?: sales_historyWhereUniqueInput | sales_historyWhereUniqueInput[]
    update?: sales_historyUpdateWithWhereUniqueWithoutPayment_methodInput | sales_historyUpdateWithWhereUniqueWithoutPayment_methodInput[]
    updateMany?: sales_historyUpdateManyWithWhereWithoutPayment_methodInput | sales_historyUpdateManyWithWhereWithoutPayment_methodInput[]
    deleteMany?: sales_historyScalarWhereInput | sales_historyScalarWhereInput[]
  }

  export type productCreateproduct_imageInput = {
    set: string[]
  }

  export type cartCreateNestedManyWithoutProductInput = {
    create?: XOR<cartCreateWithoutProductInput, cartUncheckedCreateWithoutProductInput> | cartCreateWithoutProductInput[] | cartUncheckedCreateWithoutProductInput[]
    connectOrCreate?: cartCreateOrConnectWithoutProductInput | cartCreateOrConnectWithoutProductInput[]
    createMany?: cartCreateManyProductInputEnvelope
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
  }

  export type inventoryCreateNestedManyWithoutProductInput = {
    create?: XOR<inventoryCreateWithoutProductInput, inventoryUncheckedCreateWithoutProductInput> | inventoryCreateWithoutProductInput[] | inventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: inventoryCreateOrConnectWithoutProductInput | inventoryCreateOrConnectWithoutProductInput[]
    createMany?: inventoryCreateManyProductInputEnvelope
    connect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
  }

  export type categoryCreateNestedOneWithoutProductInput = {
    create?: XOR<categoryCreateWithoutProductInput, categoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: categoryCreateOrConnectWithoutProductInput
    connect?: categoryWhereUniqueInput
  }

  export type supplierCreateNestedOneWithoutProductInput = {
    create?: XOR<supplierCreateWithoutProductInput, supplierUncheckedCreateWithoutProductInput>
    connectOrCreate?: supplierCreateOrConnectWithoutProductInput
    connect?: supplierWhereUniqueInput
  }

  export type cartUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<cartCreateWithoutProductInput, cartUncheckedCreateWithoutProductInput> | cartCreateWithoutProductInput[] | cartUncheckedCreateWithoutProductInput[]
    connectOrCreate?: cartCreateOrConnectWithoutProductInput | cartCreateOrConnectWithoutProductInput[]
    createMany?: cartCreateManyProductInputEnvelope
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
  }

  export type inventoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<inventoryCreateWithoutProductInput, inventoryUncheckedCreateWithoutProductInput> | inventoryCreateWithoutProductInput[] | inventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: inventoryCreateOrConnectWithoutProductInput | inventoryCreateOrConnectWithoutProductInput[]
    createMany?: inventoryCreateManyProductInputEnvelope
    connect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
  }

  export type productUpdateproduct_imageInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type cartUpdateManyWithoutProductNestedInput = {
    create?: XOR<cartCreateWithoutProductInput, cartUncheckedCreateWithoutProductInput> | cartCreateWithoutProductInput[] | cartUncheckedCreateWithoutProductInput[]
    connectOrCreate?: cartCreateOrConnectWithoutProductInput | cartCreateOrConnectWithoutProductInput[]
    upsert?: cartUpsertWithWhereUniqueWithoutProductInput | cartUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: cartCreateManyProductInputEnvelope
    set?: cartWhereUniqueInput | cartWhereUniqueInput[]
    disconnect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    delete?: cartWhereUniqueInput | cartWhereUniqueInput[]
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    update?: cartUpdateWithWhereUniqueWithoutProductInput | cartUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: cartUpdateManyWithWhereWithoutProductInput | cartUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: cartScalarWhereInput | cartScalarWhereInput[]
  }

  export type inventoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<inventoryCreateWithoutProductInput, inventoryUncheckedCreateWithoutProductInput> | inventoryCreateWithoutProductInput[] | inventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: inventoryCreateOrConnectWithoutProductInput | inventoryCreateOrConnectWithoutProductInput[]
    upsert?: inventoryUpsertWithWhereUniqueWithoutProductInput | inventoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: inventoryCreateManyProductInputEnvelope
    set?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    disconnect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    delete?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    connect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    update?: inventoryUpdateWithWhereUniqueWithoutProductInput | inventoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: inventoryUpdateManyWithWhereWithoutProductInput | inventoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: inventoryScalarWhereInput | inventoryScalarWhereInput[]
  }

  export type categoryUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<categoryCreateWithoutProductInput, categoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: categoryCreateOrConnectWithoutProductInput
    upsert?: categoryUpsertWithoutProductInput
    connect?: categoryWhereUniqueInput
    update?: XOR<XOR<categoryUpdateToOneWithWhereWithoutProductInput, categoryUpdateWithoutProductInput>, categoryUncheckedUpdateWithoutProductInput>
  }

  export type supplierUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<supplierCreateWithoutProductInput, supplierUncheckedCreateWithoutProductInput>
    connectOrCreate?: supplierCreateOrConnectWithoutProductInput
    upsert?: supplierUpsertWithoutProductInput
    connect?: supplierWhereUniqueInput
    update?: XOR<XOR<supplierUpdateToOneWithWhereWithoutProductInput, supplierUpdateWithoutProductInput>, supplierUncheckedUpdateWithoutProductInput>
  }

  export type cartUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<cartCreateWithoutProductInput, cartUncheckedCreateWithoutProductInput> | cartCreateWithoutProductInput[] | cartUncheckedCreateWithoutProductInput[]
    connectOrCreate?: cartCreateOrConnectWithoutProductInput | cartCreateOrConnectWithoutProductInput[]
    upsert?: cartUpsertWithWhereUniqueWithoutProductInput | cartUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: cartCreateManyProductInputEnvelope
    set?: cartWhereUniqueInput | cartWhereUniqueInput[]
    disconnect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    delete?: cartWhereUniqueInput | cartWhereUniqueInput[]
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    update?: cartUpdateWithWhereUniqueWithoutProductInput | cartUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: cartUpdateManyWithWhereWithoutProductInput | cartUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: cartScalarWhereInput | cartScalarWhereInput[]
  }

  export type inventoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<inventoryCreateWithoutProductInput, inventoryUncheckedCreateWithoutProductInput> | inventoryCreateWithoutProductInput[] | inventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: inventoryCreateOrConnectWithoutProductInput | inventoryCreateOrConnectWithoutProductInput[]
    upsert?: inventoryUpsertWithWhereUniqueWithoutProductInput | inventoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: inventoryCreateManyProductInputEnvelope
    set?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    disconnect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    delete?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    connect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    update?: inventoryUpdateWithWhereUniqueWithoutProductInput | inventoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: inventoryUpdateManyWithWhereWithoutProductInput | inventoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: inventoryScalarWhereInput | inventoryScalarWhereInput[]
  }

  export type cartCreateNestedManyWithoutSales_historyInput = {
    create?: XOR<cartCreateWithoutSales_historyInput, cartUncheckedCreateWithoutSales_historyInput> | cartCreateWithoutSales_historyInput[] | cartUncheckedCreateWithoutSales_historyInput[]
    connectOrCreate?: cartCreateOrConnectWithoutSales_historyInput | cartCreateOrConnectWithoutSales_historyInput[]
    createMany?: cartCreateManySales_historyInputEnvelope
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
  }

  export type branchCreateNestedOneWithoutSales_historyInput = {
    create?: XOR<branchCreateWithoutSales_historyInput, branchUncheckedCreateWithoutSales_historyInput>
    connectOrCreate?: branchCreateOrConnectWithoutSales_historyInput
    connect?: branchWhereUniqueInput
  }

  export type customerCreateNestedOneWithoutSales_historyInput = {
    create?: XOR<customerCreateWithoutSales_historyInput, customerUncheckedCreateWithoutSales_historyInput>
    connectOrCreate?: customerCreateOrConnectWithoutSales_historyInput
    connect?: customerWhereUniqueInput
  }

  export type employeeCreateNestedOneWithoutSales_historyInput = {
    create?: XOR<employeeCreateWithoutSales_historyInput, employeeUncheckedCreateWithoutSales_historyInput>
    connectOrCreate?: employeeCreateOrConnectWithoutSales_historyInput
    connect?: employeeWhereUniqueInput
  }

  export type payment_methodCreateNestedOneWithoutSales_historyInput = {
    create?: XOR<payment_methodCreateWithoutSales_historyInput, payment_methodUncheckedCreateWithoutSales_historyInput>
    connectOrCreate?: payment_methodCreateOrConnectWithoutSales_historyInput
    connect?: payment_methodWhereUniqueInput
  }

  export type cartUncheckedCreateNestedManyWithoutSales_historyInput = {
    create?: XOR<cartCreateWithoutSales_historyInput, cartUncheckedCreateWithoutSales_historyInput> | cartCreateWithoutSales_historyInput[] | cartUncheckedCreateWithoutSales_historyInput[]
    connectOrCreate?: cartCreateOrConnectWithoutSales_historyInput | cartCreateOrConnectWithoutSales_historyInput[]
    createMany?: cartCreateManySales_historyInputEnvelope
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
  }

  export type cartUpdateManyWithoutSales_historyNestedInput = {
    create?: XOR<cartCreateWithoutSales_historyInput, cartUncheckedCreateWithoutSales_historyInput> | cartCreateWithoutSales_historyInput[] | cartUncheckedCreateWithoutSales_historyInput[]
    connectOrCreate?: cartCreateOrConnectWithoutSales_historyInput | cartCreateOrConnectWithoutSales_historyInput[]
    upsert?: cartUpsertWithWhereUniqueWithoutSales_historyInput | cartUpsertWithWhereUniqueWithoutSales_historyInput[]
    createMany?: cartCreateManySales_historyInputEnvelope
    set?: cartWhereUniqueInput | cartWhereUniqueInput[]
    disconnect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    delete?: cartWhereUniqueInput | cartWhereUniqueInput[]
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    update?: cartUpdateWithWhereUniqueWithoutSales_historyInput | cartUpdateWithWhereUniqueWithoutSales_historyInput[]
    updateMany?: cartUpdateManyWithWhereWithoutSales_historyInput | cartUpdateManyWithWhereWithoutSales_historyInput[]
    deleteMany?: cartScalarWhereInput | cartScalarWhereInput[]
  }

  export type branchUpdateOneRequiredWithoutSales_historyNestedInput = {
    create?: XOR<branchCreateWithoutSales_historyInput, branchUncheckedCreateWithoutSales_historyInput>
    connectOrCreate?: branchCreateOrConnectWithoutSales_historyInput
    upsert?: branchUpsertWithoutSales_historyInput
    connect?: branchWhereUniqueInput
    update?: XOR<XOR<branchUpdateToOneWithWhereWithoutSales_historyInput, branchUpdateWithoutSales_historyInput>, branchUncheckedUpdateWithoutSales_historyInput>
  }

  export type customerUpdateOneWithoutSales_historyNestedInput = {
    create?: XOR<customerCreateWithoutSales_historyInput, customerUncheckedCreateWithoutSales_historyInput>
    connectOrCreate?: customerCreateOrConnectWithoutSales_historyInput
    upsert?: customerUpsertWithoutSales_historyInput
    disconnect?: customerWhereInput | boolean
    delete?: customerWhereInput | boolean
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutSales_historyInput, customerUpdateWithoutSales_historyInput>, customerUncheckedUpdateWithoutSales_historyInput>
  }

  export type employeeUpdateOneRequiredWithoutSales_historyNestedInput = {
    create?: XOR<employeeCreateWithoutSales_historyInput, employeeUncheckedCreateWithoutSales_historyInput>
    connectOrCreate?: employeeCreateOrConnectWithoutSales_historyInput
    upsert?: employeeUpsertWithoutSales_historyInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutSales_historyInput, employeeUpdateWithoutSales_historyInput>, employeeUncheckedUpdateWithoutSales_historyInput>
  }

  export type payment_methodUpdateOneWithoutSales_historyNestedInput = {
    create?: XOR<payment_methodCreateWithoutSales_historyInput, payment_methodUncheckedCreateWithoutSales_historyInput>
    connectOrCreate?: payment_methodCreateOrConnectWithoutSales_historyInput
    upsert?: payment_methodUpsertWithoutSales_historyInput
    disconnect?: payment_methodWhereInput | boolean
    delete?: payment_methodWhereInput | boolean
    connect?: payment_methodWhereUniqueInput
    update?: XOR<XOR<payment_methodUpdateToOneWithWhereWithoutSales_historyInput, payment_methodUpdateWithoutSales_historyInput>, payment_methodUncheckedUpdateWithoutSales_historyInput>
  }

  export type cartUncheckedUpdateManyWithoutSales_historyNestedInput = {
    create?: XOR<cartCreateWithoutSales_historyInput, cartUncheckedCreateWithoutSales_historyInput> | cartCreateWithoutSales_historyInput[] | cartUncheckedCreateWithoutSales_historyInput[]
    connectOrCreate?: cartCreateOrConnectWithoutSales_historyInput | cartCreateOrConnectWithoutSales_historyInput[]
    upsert?: cartUpsertWithWhereUniqueWithoutSales_historyInput | cartUpsertWithWhereUniqueWithoutSales_historyInput[]
    createMany?: cartCreateManySales_historyInputEnvelope
    set?: cartWhereUniqueInput | cartWhereUniqueInput[]
    disconnect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    delete?: cartWhereUniqueInput | cartWhereUniqueInput[]
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    update?: cartUpdateWithWhereUniqueWithoutSales_historyInput | cartUpdateWithWhereUniqueWithoutSales_historyInput[]
    updateMany?: cartUpdateManyWithWhereWithoutSales_historyInput | cartUpdateManyWithWhereWithoutSales_historyInput[]
    deleteMany?: cartScalarWhereInput | cartScalarWhereInput[]
  }

  export type productCreateNestedManyWithoutSupplierInput = {
    create?: XOR<productCreateWithoutSupplierInput, productUncheckedCreateWithoutSupplierInput> | productCreateWithoutSupplierInput[] | productUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: productCreateOrConnectWithoutSupplierInput | productCreateOrConnectWithoutSupplierInput[]
    createMany?: productCreateManySupplierInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type productUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<productCreateWithoutSupplierInput, productUncheckedCreateWithoutSupplierInput> | productCreateWithoutSupplierInput[] | productUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: productCreateOrConnectWithoutSupplierInput | productCreateOrConnectWithoutSupplierInput[]
    createMany?: productCreateManySupplierInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type productUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<productCreateWithoutSupplierInput, productUncheckedCreateWithoutSupplierInput> | productCreateWithoutSupplierInput[] | productUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: productCreateOrConnectWithoutSupplierInput | productCreateOrConnectWithoutSupplierInput[]
    upsert?: productUpsertWithWhereUniqueWithoutSupplierInput | productUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: productCreateManySupplierInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutSupplierInput | productUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: productUpdateManyWithWhereWithoutSupplierInput | productUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type productUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<productCreateWithoutSupplierInput, productUncheckedCreateWithoutSupplierInput> | productCreateWithoutSupplierInput[] | productUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: productCreateOrConnectWithoutSupplierInput | productCreateOrConnectWithoutSupplierInput[]
    upsert?: productUpsertWithWhereUniqueWithoutSupplierInput | productUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: productCreateManySupplierInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutSupplierInput | productUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: productUpdateManyWithWhereWithoutSupplierInput | productUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type employeeCreateNestedOneWithoutUser_credentialsInput = {
    create?: XOR<employeeCreateWithoutUser_credentialsInput, employeeUncheckedCreateWithoutUser_credentialsInput>
    connectOrCreate?: employeeCreateOrConnectWithoutUser_credentialsInput
    connect?: employeeWhereUniqueInput
  }

  export type employeeUpdateOneRequiredWithoutUser_credentialsNestedInput = {
    create?: XOR<employeeCreateWithoutUser_credentialsInput, employeeUncheckedCreateWithoutUser_credentialsInput>
    connectOrCreate?: employeeCreateOrConnectWithoutUser_credentialsInput
    upsert?: employeeUpsertWithoutUser_credentialsInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutUser_credentialsInput, employeeUpdateWithoutUser_credentialsInput>, employeeUncheckedUpdateWithoutUser_credentialsInput>
  }

  export type user_roleCreateuser_accessInput = {
    set: number[]
  }

  export type employeeCreateNestedManyWithoutUser_roleInput = {
    create?: XOR<employeeCreateWithoutUser_roleInput, employeeUncheckedCreateWithoutUser_roleInput> | employeeCreateWithoutUser_roleInput[] | employeeUncheckedCreateWithoutUser_roleInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutUser_roleInput | employeeCreateOrConnectWithoutUser_roleInput[]
    createMany?: employeeCreateManyUser_roleInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type employeeUncheckedCreateNestedManyWithoutUser_roleInput = {
    create?: XOR<employeeCreateWithoutUser_roleInput, employeeUncheckedCreateWithoutUser_roleInput> | employeeCreateWithoutUser_roleInput[] | employeeUncheckedCreateWithoutUser_roleInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutUser_roleInput | employeeCreateOrConnectWithoutUser_roleInput[]
    createMany?: employeeCreateManyUser_roleInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type user_roleUpdateuser_accessInput = {
    set?: number[]
    push?: number | number[]
  }

  export type employeeUpdateManyWithoutUser_roleNestedInput = {
    create?: XOR<employeeCreateWithoutUser_roleInput, employeeUncheckedCreateWithoutUser_roleInput> | employeeCreateWithoutUser_roleInput[] | employeeUncheckedCreateWithoutUser_roleInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutUser_roleInput | employeeCreateOrConnectWithoutUser_roleInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutUser_roleInput | employeeUpsertWithWhereUniqueWithoutUser_roleInput[]
    createMany?: employeeCreateManyUser_roleInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutUser_roleInput | employeeUpdateWithWhereUniqueWithoutUser_roleInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutUser_roleInput | employeeUpdateManyWithWhereWithoutUser_roleInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type employeeUncheckedUpdateManyWithoutUser_roleNestedInput = {
    create?: XOR<employeeCreateWithoutUser_roleInput, employeeUncheckedCreateWithoutUser_roleInput> | employeeCreateWithoutUser_roleInput[] | employeeUncheckedCreateWithoutUser_roleInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutUser_roleInput | employeeCreateOrConnectWithoutUser_roleInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutUser_roleInput | employeeUpsertWithWhereUniqueWithoutUser_roleInput[]
    createMany?: employeeCreateManyUser_roleInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutUser_roleInput | employeeUpdateWithWhereUniqueWithoutUser_roleInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutUser_roleInput | employeeUpdateManyWithWhereWithoutUser_roleInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type employeeCreateNestedOneWithoutWorking_hourInput = {
    create?: XOR<employeeCreateWithoutWorking_hourInput, employeeUncheckedCreateWithoutWorking_hourInput>
    connectOrCreate?: employeeCreateOrConnectWithoutWorking_hourInput
    connect?: employeeWhereUniqueInput
  }

  export type employeeCreateNestedOneWithoutWorking_hour_marked_byInput = {
    create?: XOR<employeeCreateWithoutWorking_hour_marked_byInput, employeeUncheckedCreateWithoutWorking_hour_marked_byInput>
    connectOrCreate?: employeeCreateOrConnectWithoutWorking_hour_marked_byInput
    connect?: employeeWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type employeeUpdateOneRequiredWithoutWorking_hourNestedInput = {
    create?: XOR<employeeCreateWithoutWorking_hourInput, employeeUncheckedCreateWithoutWorking_hourInput>
    connectOrCreate?: employeeCreateOrConnectWithoutWorking_hourInput
    upsert?: employeeUpsertWithoutWorking_hourInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutWorking_hourInput, employeeUpdateWithoutWorking_hourInput>, employeeUncheckedUpdateWithoutWorking_hourInput>
  }

  export type employeeUpdateOneRequiredWithoutWorking_hour_marked_byNestedInput = {
    create?: XOR<employeeCreateWithoutWorking_hour_marked_byInput, employeeUncheckedCreateWithoutWorking_hour_marked_byInput>
    connectOrCreate?: employeeCreateOrConnectWithoutWorking_hour_marked_byInput
    upsert?: employeeUpsertWithoutWorking_hour_marked_byInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutWorking_hour_marked_byInput, employeeUpdateWithoutWorking_hour_marked_byInput>, employeeUncheckedUpdateWithoutWorking_hour_marked_byInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type employeeCreateWithoutBranchInput = {
    employee_name: string
    hired_date?: Date | string | null
    employee_email?: string | null
    employee_phone: string
    employee_image?: string | null
    branch_updated_on?: Date | string | null
    role_updated_on?: Date | string | null
    user_role: user_roleCreateNestedOneWithoutEmployeeInput
    sales_history?: sales_historyCreateNestedManyWithoutEmployeeInput
    user_credentials?: user_credentialsCreateNestedOneWithoutEmployeeInput
    working_hour?: working_hourCreateNestedManyWithoutEmployeeInput
    working_hour_marked_by?: working_hourCreateNestedManyWithoutMarked_byInput
  }

  export type employeeUncheckedCreateWithoutBranchInput = {
    employee_id?: number
    employee_name: string
    role_id: number
    hired_date?: Date | string | null
    employee_email?: string | null
    employee_phone: string
    employee_image?: string | null
    branch_updated_on?: Date | string | null
    role_updated_on?: Date | string | null
    sales_history?: sales_historyUncheckedCreateNestedManyWithoutEmployeeInput
    user_credentials?: user_credentialsUncheckedCreateNestedOneWithoutEmployeeInput
    working_hour?: working_hourUncheckedCreateNestedManyWithoutEmployeeInput
    working_hour_marked_by?: working_hourUncheckedCreateNestedManyWithoutMarked_byInput
  }

  export type employeeCreateOrConnectWithoutBranchInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutBranchInput, employeeUncheckedCreateWithoutBranchInput>
  }

  export type employeeCreateManyBranchInputEnvelope = {
    data: employeeCreateManyBranchInput | employeeCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type inventoryCreateWithoutBranchInput = {
    quantity?: number | null
    reorder_level?: number | null
    updated_on?: Date | string | null
    product: productCreateNestedOneWithoutInventoryInput
  }

  export type inventoryUncheckedCreateWithoutBranchInput = {
    product_id: string
    quantity?: number | null
    reorder_level?: number | null
    updated_on?: Date | string | null
  }

  export type inventoryCreateOrConnectWithoutBranchInput = {
    where: inventoryWhereUniqueInput
    create: XOR<inventoryCreateWithoutBranchInput, inventoryUncheckedCreateWithoutBranchInput>
  }

  export type inventoryCreateManyBranchInputEnvelope = {
    data: inventoryCreateManyBranchInput | inventoryCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type sales_historyCreateWithoutBranchInput = {
    created_at?: Date | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    reference_id?: string | null
    product_count?: number | null
    cart?: cartCreateNestedManyWithoutSales_historyInput
    customer?: customerCreateNestedOneWithoutSales_historyInput
    employee: employeeCreateNestedOneWithoutSales_historyInput
    payment_method?: payment_methodCreateNestedOneWithoutSales_historyInput
  }

  export type sales_historyUncheckedCreateWithoutBranchInput = {
    order_id?: number
    customer_id?: number | null
    cashier_id: number
    created_at?: Date | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    payment_method_id?: number | null
    reference_id?: string | null
    product_count?: number | null
    cart?: cartUncheckedCreateNestedManyWithoutSales_historyInput
  }

  export type sales_historyCreateOrConnectWithoutBranchInput = {
    where: sales_historyWhereUniqueInput
    create: XOR<sales_historyCreateWithoutBranchInput, sales_historyUncheckedCreateWithoutBranchInput>
  }

  export type sales_historyCreateManyBranchInputEnvelope = {
    data: sales_historyCreateManyBranchInput | sales_historyCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type employeeUpsertWithWhereUniqueWithoutBranchInput = {
    where: employeeWhereUniqueInput
    update: XOR<employeeUpdateWithoutBranchInput, employeeUncheckedUpdateWithoutBranchInput>
    create: XOR<employeeCreateWithoutBranchInput, employeeUncheckedCreateWithoutBranchInput>
  }

  export type employeeUpdateWithWhereUniqueWithoutBranchInput = {
    where: employeeWhereUniqueInput
    data: XOR<employeeUpdateWithoutBranchInput, employeeUncheckedUpdateWithoutBranchInput>
  }

  export type employeeUpdateManyWithWhereWithoutBranchInput = {
    where: employeeScalarWhereInput
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyWithoutBranchInput>
  }

  export type employeeScalarWhereInput = {
    AND?: employeeScalarWhereInput | employeeScalarWhereInput[]
    OR?: employeeScalarWhereInput[]
    NOT?: employeeScalarWhereInput | employeeScalarWhereInput[]
    employee_id?: IntFilter<"employee"> | number
    employee_name?: StringFilter<"employee"> | string
    role_id?: IntFilter<"employee"> | number
    hired_date?: DateTimeNullableFilter<"employee"> | Date | string | null
    employee_email?: StringNullableFilter<"employee"> | string | null
    employee_phone?: StringFilter<"employee"> | string
    branch_id?: UuidFilter<"employee"> | string
    employee_image?: StringNullableFilter<"employee"> | string | null
    branch_updated_on?: DateTimeNullableFilter<"employee"> | Date | string | null
    role_updated_on?: DateTimeNullableFilter<"employee"> | Date | string | null
  }

  export type inventoryUpsertWithWhereUniqueWithoutBranchInput = {
    where: inventoryWhereUniqueInput
    update: XOR<inventoryUpdateWithoutBranchInput, inventoryUncheckedUpdateWithoutBranchInput>
    create: XOR<inventoryCreateWithoutBranchInput, inventoryUncheckedCreateWithoutBranchInput>
  }

  export type inventoryUpdateWithWhereUniqueWithoutBranchInput = {
    where: inventoryWhereUniqueInput
    data: XOR<inventoryUpdateWithoutBranchInput, inventoryUncheckedUpdateWithoutBranchInput>
  }

  export type inventoryUpdateManyWithWhereWithoutBranchInput = {
    where: inventoryScalarWhereInput
    data: XOR<inventoryUpdateManyMutationInput, inventoryUncheckedUpdateManyWithoutBranchInput>
  }

  export type inventoryScalarWhereInput = {
    AND?: inventoryScalarWhereInput | inventoryScalarWhereInput[]
    OR?: inventoryScalarWhereInput[]
    NOT?: inventoryScalarWhereInput | inventoryScalarWhereInput[]
    product_id?: UuidFilter<"inventory"> | string
    branch_id?: UuidFilter<"inventory"> | string
    quantity?: IntNullableFilter<"inventory"> | number | null
    reorder_level?: IntNullableFilter<"inventory"> | number | null
    updated_on?: DateTimeNullableFilter<"inventory"> | Date | string | null
  }

  export type sales_historyUpsertWithWhereUniqueWithoutBranchInput = {
    where: sales_historyWhereUniqueInput
    update: XOR<sales_historyUpdateWithoutBranchInput, sales_historyUncheckedUpdateWithoutBranchInput>
    create: XOR<sales_historyCreateWithoutBranchInput, sales_historyUncheckedCreateWithoutBranchInput>
  }

  export type sales_historyUpdateWithWhereUniqueWithoutBranchInput = {
    where: sales_historyWhereUniqueInput
    data: XOR<sales_historyUpdateWithoutBranchInput, sales_historyUncheckedUpdateWithoutBranchInput>
  }

  export type sales_historyUpdateManyWithWhereWithoutBranchInput = {
    where: sales_historyScalarWhereInput
    data: XOR<sales_historyUpdateManyMutationInput, sales_historyUncheckedUpdateManyWithoutBranchInput>
  }

  export type sales_historyScalarWhereInput = {
    AND?: sales_historyScalarWhereInput | sales_historyScalarWhereInput[]
    OR?: sales_historyScalarWhereInput[]
    NOT?: sales_historyScalarWhereInput | sales_historyScalarWhereInput[]
    order_id?: IntFilter<"sales_history"> | number
    customer_id?: IntNullableFilter<"sales_history"> | number | null
    cashier_id?: IntFilter<"sales_history"> | number
    branch_id?: UuidFilter<"sales_history"> | string
    created_at?: DateTimeNullableFilter<"sales_history"> | Date | string | null
    total_amount?: DecimalNullableFilter<"sales_history"> | Decimal | DecimalJsLike | number | string | null
    profit?: DecimalNullableFilter<"sales_history"> | Decimal | DecimalJsLike | number | string | null
    rewards_points?: DecimalNullableFilter<"sales_history"> | Decimal | DecimalJsLike | number | string | null
    payment_method_id?: IntNullableFilter<"sales_history"> | number | null
    reference_id?: StringNullableFilter<"sales_history"> | string | null
    product_count?: IntNullableFilter<"sales_history"> | number | null
  }

  export type productCreateWithoutCartInput = {
    product_id?: string
    product_name: string
    product_desc?: string | null
    product_image?: productCreateproduct_imageInput | string[]
    buying_price: Decimal | DecimalJsLike | number | string
    retail_price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    product_barcode: string
    removed?: boolean | null
    created_at?: Date | string | null
    updated_on?: Date | string | null
    inventory?: inventoryCreateNestedManyWithoutProductInput
    category: categoryCreateNestedOneWithoutProductInput
    supplier: supplierCreateNestedOneWithoutProductInput
  }

  export type productUncheckedCreateWithoutCartInput = {
    product_id?: string
    product_name: string
    product_desc?: string | null
    category_id: number
    product_image?: productCreateproduct_imageInput | string[]
    buying_price: Decimal | DecimalJsLike | number | string
    retail_price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    supplier_id: number
    product_barcode: string
    removed?: boolean | null
    created_at?: Date | string | null
    updated_on?: Date | string | null
    inventory?: inventoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutCartInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutCartInput, productUncheckedCreateWithoutCartInput>
  }

  export type sales_historyCreateWithoutCartInput = {
    created_at?: Date | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    reference_id?: string | null
    product_count?: number | null
    branch: branchCreateNestedOneWithoutSales_historyInput
    customer?: customerCreateNestedOneWithoutSales_historyInput
    employee: employeeCreateNestedOneWithoutSales_historyInput
    payment_method?: payment_methodCreateNestedOneWithoutSales_historyInput
  }

  export type sales_historyUncheckedCreateWithoutCartInput = {
    order_id?: number
    customer_id?: number | null
    cashier_id: number
    branch_id: string
    created_at?: Date | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    payment_method_id?: number | null
    reference_id?: string | null
    product_count?: number | null
  }

  export type sales_historyCreateOrConnectWithoutCartInput = {
    where: sales_historyWhereUniqueInput
    create: XOR<sales_historyCreateWithoutCartInput, sales_historyUncheckedCreateWithoutCartInput>
  }

  export type productUpsertWithoutCartInput = {
    update: XOR<productUpdateWithoutCartInput, productUncheckedUpdateWithoutCartInput>
    create: XOR<productCreateWithoutCartInput, productUncheckedCreateWithoutCartInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutCartInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutCartInput, productUncheckedUpdateWithoutCartInput>
  }

  export type productUpdateWithoutCartInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    product_desc?: NullableStringFieldUpdateOperationsInput | string | null
    product_image?: productUpdateproduct_imageInput | string[]
    buying_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_barcode?: StringFieldUpdateOperationsInput | string
    removed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventory?: inventoryUpdateManyWithoutProductNestedInput
    category?: categoryUpdateOneRequiredWithoutProductNestedInput
    supplier?: supplierUpdateOneRequiredWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutCartInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    product_desc?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: IntFieldUpdateOperationsInput | number
    product_image?: productUpdateproduct_imageInput | string[]
    buying_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier_id?: IntFieldUpdateOperationsInput | number
    product_barcode?: StringFieldUpdateOperationsInput | string
    removed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventory?: inventoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type sales_historyUpsertWithoutCartInput = {
    update: XOR<sales_historyUpdateWithoutCartInput, sales_historyUncheckedUpdateWithoutCartInput>
    create: XOR<sales_historyCreateWithoutCartInput, sales_historyUncheckedCreateWithoutCartInput>
    where?: sales_historyWhereInput
  }

  export type sales_historyUpdateToOneWithWhereWithoutCartInput = {
    where?: sales_historyWhereInput
    data: XOR<sales_historyUpdateWithoutCartInput, sales_historyUncheckedUpdateWithoutCartInput>
  }

  export type sales_historyUpdateWithoutCartInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: branchUpdateOneRequiredWithoutSales_historyNestedInput
    customer?: customerUpdateOneWithoutSales_historyNestedInput
    employee?: employeeUpdateOneRequiredWithoutSales_historyNestedInput
    payment_method?: payment_methodUpdateOneWithoutSales_historyNestedInput
  }

  export type sales_historyUncheckedUpdateWithoutCartInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    cashier_id?: IntFieldUpdateOperationsInput | number
    branch_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type productCreateWithoutCategoryInput = {
    product_id?: string
    product_name: string
    product_desc?: string | null
    product_image?: productCreateproduct_imageInput | string[]
    buying_price: Decimal | DecimalJsLike | number | string
    retail_price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    product_barcode: string
    removed?: boolean | null
    created_at?: Date | string | null
    updated_on?: Date | string | null
    cart?: cartCreateNestedManyWithoutProductInput
    inventory?: inventoryCreateNestedManyWithoutProductInput
    supplier: supplierCreateNestedOneWithoutProductInput
  }

  export type productUncheckedCreateWithoutCategoryInput = {
    product_id?: string
    product_name: string
    product_desc?: string | null
    product_image?: productCreateproduct_imageInput | string[]
    buying_price: Decimal | DecimalJsLike | number | string
    retail_price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    supplier_id: number
    product_barcode: string
    removed?: boolean | null
    created_at?: Date | string | null
    updated_on?: Date | string | null
    cart?: cartUncheckedCreateNestedManyWithoutProductInput
    inventory?: inventoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutCategoryInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutCategoryInput, productUncheckedCreateWithoutCategoryInput>
  }

  export type productCreateManyCategoryInputEnvelope = {
    data: productCreateManyCategoryInput | productCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type productUpsertWithWhereUniqueWithoutCategoryInput = {
    where: productWhereUniqueInput
    update: XOR<productUpdateWithoutCategoryInput, productUncheckedUpdateWithoutCategoryInput>
    create: XOR<productCreateWithoutCategoryInput, productUncheckedCreateWithoutCategoryInput>
  }

  export type productUpdateWithWhereUniqueWithoutCategoryInput = {
    where: productWhereUniqueInput
    data: XOR<productUpdateWithoutCategoryInput, productUncheckedUpdateWithoutCategoryInput>
  }

  export type productUpdateManyWithWhereWithoutCategoryInput = {
    where: productScalarWhereInput
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyWithoutCategoryInput>
  }

  export type productScalarWhereInput = {
    AND?: productScalarWhereInput | productScalarWhereInput[]
    OR?: productScalarWhereInput[]
    NOT?: productScalarWhereInput | productScalarWhereInput[]
    product_id?: UuidFilter<"product"> | string
    product_name?: StringFilter<"product"> | string
    product_desc?: StringNullableFilter<"product"> | string | null
    category_id?: IntFilter<"product"> | number
    product_image?: StringNullableListFilter<"product">
    buying_price?: DecimalFilter<"product"> | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalFilter<"product"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalNullableFilter<"product"> | Decimal | DecimalJsLike | number | string | null
    supplier_id?: IntFilter<"product"> | number
    product_barcode?: StringFilter<"product"> | string
    removed?: BoolNullableFilter<"product"> | boolean | null
    created_at?: DateTimeNullableFilter<"product"> | Date | string | null
    updated_on?: DateTimeNullableFilter<"product"> | Date | string | null
  }

  export type sales_historyCreateWithoutCustomerInput = {
    created_at?: Date | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    reference_id?: string | null
    product_count?: number | null
    cart?: cartCreateNestedManyWithoutSales_historyInput
    branch: branchCreateNestedOneWithoutSales_historyInput
    employee: employeeCreateNestedOneWithoutSales_historyInput
    payment_method?: payment_methodCreateNestedOneWithoutSales_historyInput
  }

  export type sales_historyUncheckedCreateWithoutCustomerInput = {
    order_id?: number
    cashier_id: number
    branch_id: string
    created_at?: Date | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    payment_method_id?: number | null
    reference_id?: string | null
    product_count?: number | null
    cart?: cartUncheckedCreateNestedManyWithoutSales_historyInput
  }

  export type sales_historyCreateOrConnectWithoutCustomerInput = {
    where: sales_historyWhereUniqueInput
    create: XOR<sales_historyCreateWithoutCustomerInput, sales_historyUncheckedCreateWithoutCustomerInput>
  }

  export type sales_historyCreateManyCustomerInputEnvelope = {
    data: sales_historyCreateManyCustomerInput | sales_historyCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type sales_historyUpsertWithWhereUniqueWithoutCustomerInput = {
    where: sales_historyWhereUniqueInput
    update: XOR<sales_historyUpdateWithoutCustomerInput, sales_historyUncheckedUpdateWithoutCustomerInput>
    create: XOR<sales_historyCreateWithoutCustomerInput, sales_historyUncheckedCreateWithoutCustomerInput>
  }

  export type sales_historyUpdateWithWhereUniqueWithoutCustomerInput = {
    where: sales_historyWhereUniqueInput
    data: XOR<sales_historyUpdateWithoutCustomerInput, sales_historyUncheckedUpdateWithoutCustomerInput>
  }

  export type sales_historyUpdateManyWithWhereWithoutCustomerInput = {
    where: sales_historyScalarWhereInput
    data: XOR<sales_historyUpdateManyMutationInput, sales_historyUncheckedUpdateManyWithoutCustomerInput>
  }

  export type branchCreateWithoutEmployeeInput = {
    branch_id?: string
    branch_city: string
    branch_address: string
    branch_phone: string
    branch_email: string
    created_at?: Date | string | null
    inventory?: inventoryCreateNestedManyWithoutBranchInput
    sales_history?: sales_historyCreateNestedManyWithoutBranchInput
  }

  export type branchUncheckedCreateWithoutEmployeeInput = {
    branch_id?: string
    branch_city: string
    branch_address: string
    branch_phone: string
    branch_email: string
    created_at?: Date | string | null
    inventory?: inventoryUncheckedCreateNestedManyWithoutBranchInput
    sales_history?: sales_historyUncheckedCreateNestedManyWithoutBranchInput
  }

  export type branchCreateOrConnectWithoutEmployeeInput = {
    where: branchWhereUniqueInput
    create: XOR<branchCreateWithoutEmployeeInput, branchUncheckedCreateWithoutEmployeeInput>
  }

  export type user_roleCreateWithoutEmployeeInput = {
    role_name: string
    role_desc: string
    user_access?: user_roleCreateuser_accessInput | number[]
  }

  export type user_roleUncheckedCreateWithoutEmployeeInput = {
    role_id?: number
    role_name: string
    role_desc: string
    user_access?: user_roleCreateuser_accessInput | number[]
  }

  export type user_roleCreateOrConnectWithoutEmployeeInput = {
    where: user_roleWhereUniqueInput
    create: XOR<user_roleCreateWithoutEmployeeInput, user_roleUncheckedCreateWithoutEmployeeInput>
  }

  export type sales_historyCreateWithoutEmployeeInput = {
    created_at?: Date | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    reference_id?: string | null
    product_count?: number | null
    cart?: cartCreateNestedManyWithoutSales_historyInput
    branch: branchCreateNestedOneWithoutSales_historyInput
    customer?: customerCreateNestedOneWithoutSales_historyInput
    payment_method?: payment_methodCreateNestedOneWithoutSales_historyInput
  }

  export type sales_historyUncheckedCreateWithoutEmployeeInput = {
    order_id?: number
    customer_id?: number | null
    branch_id: string
    created_at?: Date | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    payment_method_id?: number | null
    reference_id?: string | null
    product_count?: number | null
    cart?: cartUncheckedCreateNestedManyWithoutSales_historyInput
  }

  export type sales_historyCreateOrConnectWithoutEmployeeInput = {
    where: sales_historyWhereUniqueInput
    create: XOR<sales_historyCreateWithoutEmployeeInput, sales_historyUncheckedCreateWithoutEmployeeInput>
  }

  export type sales_historyCreateManyEmployeeInputEnvelope = {
    data: sales_historyCreateManyEmployeeInput | sales_historyCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type user_credentialsCreateWithoutEmployeeInput = {
    username: string
    password: string
    updated_on?: Date | string | null
  }

  export type user_credentialsUncheckedCreateWithoutEmployeeInput = {
    username: string
    password: string
    updated_on?: Date | string | null
  }

  export type user_credentialsCreateOrConnectWithoutEmployeeInput = {
    where: user_credentialsWhereUniqueInput
    create: XOR<user_credentialsCreateWithoutEmployeeInput, user_credentialsUncheckedCreateWithoutEmployeeInput>
  }

  export type working_hourCreateWithoutEmployeeInput = {
    branch_id: string
    date: string
    shift_on: string
    shift_off: string
    present: boolean
    total_hours?: Decimal | DecimalJsLike | number | string | null
    marked_by: employeeCreateNestedOneWithoutWorking_hour_marked_byInput
  }

  export type working_hourUncheckedCreateWithoutEmployeeInput = {
    branch_id: string
    date: string
    shift_on: string
    shift_off: string
    updated_by: number
    present: boolean
    total_hours?: Decimal | DecimalJsLike | number | string | null
  }

  export type working_hourCreateOrConnectWithoutEmployeeInput = {
    where: working_hourWhereUniqueInput
    create: XOR<working_hourCreateWithoutEmployeeInput, working_hourUncheckedCreateWithoutEmployeeInput>
  }

  export type working_hourCreateManyEmployeeInputEnvelope = {
    data: working_hourCreateManyEmployeeInput | working_hourCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type working_hourCreateWithoutMarked_byInput = {
    branch_id: string
    date: string
    shift_on: string
    shift_off: string
    present: boolean
    total_hours?: Decimal | DecimalJsLike | number | string | null
    employee: employeeCreateNestedOneWithoutWorking_hourInput
  }

  export type working_hourUncheckedCreateWithoutMarked_byInput = {
    employee_id: number
    branch_id: string
    date: string
    shift_on: string
    shift_off: string
    present: boolean
    total_hours?: Decimal | DecimalJsLike | number | string | null
  }

  export type working_hourCreateOrConnectWithoutMarked_byInput = {
    where: working_hourWhereUniqueInput
    create: XOR<working_hourCreateWithoutMarked_byInput, working_hourUncheckedCreateWithoutMarked_byInput>
  }

  export type working_hourCreateManyMarked_byInputEnvelope = {
    data: working_hourCreateManyMarked_byInput | working_hourCreateManyMarked_byInput[]
    skipDuplicates?: boolean
  }

  export type branchUpsertWithoutEmployeeInput = {
    update: XOR<branchUpdateWithoutEmployeeInput, branchUncheckedUpdateWithoutEmployeeInput>
    create: XOR<branchCreateWithoutEmployeeInput, branchUncheckedCreateWithoutEmployeeInput>
    where?: branchWhereInput
  }

  export type branchUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: branchWhereInput
    data: XOR<branchUpdateWithoutEmployeeInput, branchUncheckedUpdateWithoutEmployeeInput>
  }

  export type branchUpdateWithoutEmployeeInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    branch_city?: StringFieldUpdateOperationsInput | string
    branch_address?: StringFieldUpdateOperationsInput | string
    branch_phone?: StringFieldUpdateOperationsInput | string
    branch_email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventory?: inventoryUpdateManyWithoutBranchNestedInput
    sales_history?: sales_historyUpdateManyWithoutBranchNestedInput
  }

  export type branchUncheckedUpdateWithoutEmployeeInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    branch_city?: StringFieldUpdateOperationsInput | string
    branch_address?: StringFieldUpdateOperationsInput | string
    branch_phone?: StringFieldUpdateOperationsInput | string
    branch_email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventory?: inventoryUncheckedUpdateManyWithoutBranchNestedInput
    sales_history?: sales_historyUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type user_roleUpsertWithoutEmployeeInput = {
    update: XOR<user_roleUpdateWithoutEmployeeInput, user_roleUncheckedUpdateWithoutEmployeeInput>
    create: XOR<user_roleCreateWithoutEmployeeInput, user_roleUncheckedCreateWithoutEmployeeInput>
    where?: user_roleWhereInput
  }

  export type user_roleUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: user_roleWhereInput
    data: XOR<user_roleUpdateWithoutEmployeeInput, user_roleUncheckedUpdateWithoutEmployeeInput>
  }

  export type user_roleUpdateWithoutEmployeeInput = {
    role_name?: StringFieldUpdateOperationsInput | string
    role_desc?: StringFieldUpdateOperationsInput | string
    user_access?: user_roleUpdateuser_accessInput | number[]
  }

  export type user_roleUncheckedUpdateWithoutEmployeeInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    role_desc?: StringFieldUpdateOperationsInput | string
    user_access?: user_roleUpdateuser_accessInput | number[]
  }

  export type sales_historyUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: sales_historyWhereUniqueInput
    update: XOR<sales_historyUpdateWithoutEmployeeInput, sales_historyUncheckedUpdateWithoutEmployeeInput>
    create: XOR<sales_historyCreateWithoutEmployeeInput, sales_historyUncheckedCreateWithoutEmployeeInput>
  }

  export type sales_historyUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: sales_historyWhereUniqueInput
    data: XOR<sales_historyUpdateWithoutEmployeeInput, sales_historyUncheckedUpdateWithoutEmployeeInput>
  }

  export type sales_historyUpdateManyWithWhereWithoutEmployeeInput = {
    where: sales_historyScalarWhereInput
    data: XOR<sales_historyUpdateManyMutationInput, sales_historyUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type user_credentialsUpsertWithoutEmployeeInput = {
    update: XOR<user_credentialsUpdateWithoutEmployeeInput, user_credentialsUncheckedUpdateWithoutEmployeeInput>
    create: XOR<user_credentialsCreateWithoutEmployeeInput, user_credentialsUncheckedCreateWithoutEmployeeInput>
    where?: user_credentialsWhereInput
  }

  export type user_credentialsUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: user_credentialsWhereInput
    data: XOR<user_credentialsUpdateWithoutEmployeeInput, user_credentialsUncheckedUpdateWithoutEmployeeInput>
  }

  export type user_credentialsUpdateWithoutEmployeeInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_credentialsUncheckedUpdateWithoutEmployeeInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type working_hourUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: working_hourWhereUniqueInput
    update: XOR<working_hourUpdateWithoutEmployeeInput, working_hourUncheckedUpdateWithoutEmployeeInput>
    create: XOR<working_hourCreateWithoutEmployeeInput, working_hourUncheckedCreateWithoutEmployeeInput>
  }

  export type working_hourUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: working_hourWhereUniqueInput
    data: XOR<working_hourUpdateWithoutEmployeeInput, working_hourUncheckedUpdateWithoutEmployeeInput>
  }

  export type working_hourUpdateManyWithWhereWithoutEmployeeInput = {
    where: working_hourScalarWhereInput
    data: XOR<working_hourUpdateManyMutationInput, working_hourUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type working_hourScalarWhereInput = {
    AND?: working_hourScalarWhereInput | working_hourScalarWhereInput[]
    OR?: working_hourScalarWhereInput[]
    NOT?: working_hourScalarWhereInput | working_hourScalarWhereInput[]
    employee_id?: IntFilter<"working_hour"> | number
    branch_id?: UuidFilter<"working_hour"> | string
    date?: StringFilter<"working_hour"> | string
    shift_on?: StringFilter<"working_hour"> | string
    shift_off?: StringFilter<"working_hour"> | string
    updated_by?: IntFilter<"working_hour"> | number
    present?: BoolFilter<"working_hour"> | boolean
    total_hours?: DecimalNullableFilter<"working_hour"> | Decimal | DecimalJsLike | number | string | null
  }

  export type working_hourUpsertWithWhereUniqueWithoutMarked_byInput = {
    where: working_hourWhereUniqueInput
    update: XOR<working_hourUpdateWithoutMarked_byInput, working_hourUncheckedUpdateWithoutMarked_byInput>
    create: XOR<working_hourCreateWithoutMarked_byInput, working_hourUncheckedCreateWithoutMarked_byInput>
  }

  export type working_hourUpdateWithWhereUniqueWithoutMarked_byInput = {
    where: working_hourWhereUniqueInput
    data: XOR<working_hourUpdateWithoutMarked_byInput, working_hourUncheckedUpdateWithoutMarked_byInput>
  }

  export type working_hourUpdateManyWithWhereWithoutMarked_byInput = {
    where: working_hourScalarWhereInput
    data: XOR<working_hourUpdateManyMutationInput, working_hourUncheckedUpdateManyWithoutMarked_byInput>
  }

  export type branchCreateWithoutInventoryInput = {
    branch_id?: string
    branch_city: string
    branch_address: string
    branch_phone: string
    branch_email: string
    created_at?: Date | string | null
    employee?: employeeCreateNestedManyWithoutBranchInput
    sales_history?: sales_historyCreateNestedManyWithoutBranchInput
  }

  export type branchUncheckedCreateWithoutInventoryInput = {
    branch_id?: string
    branch_city: string
    branch_address: string
    branch_phone: string
    branch_email: string
    created_at?: Date | string | null
    employee?: employeeUncheckedCreateNestedManyWithoutBranchInput
    sales_history?: sales_historyUncheckedCreateNestedManyWithoutBranchInput
  }

  export type branchCreateOrConnectWithoutInventoryInput = {
    where: branchWhereUniqueInput
    create: XOR<branchCreateWithoutInventoryInput, branchUncheckedCreateWithoutInventoryInput>
  }

  export type productCreateWithoutInventoryInput = {
    product_id?: string
    product_name: string
    product_desc?: string | null
    product_image?: productCreateproduct_imageInput | string[]
    buying_price: Decimal | DecimalJsLike | number | string
    retail_price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    product_barcode: string
    removed?: boolean | null
    created_at?: Date | string | null
    updated_on?: Date | string | null
    cart?: cartCreateNestedManyWithoutProductInput
    category: categoryCreateNestedOneWithoutProductInput
    supplier: supplierCreateNestedOneWithoutProductInput
  }

  export type productUncheckedCreateWithoutInventoryInput = {
    product_id?: string
    product_name: string
    product_desc?: string | null
    category_id: number
    product_image?: productCreateproduct_imageInput | string[]
    buying_price: Decimal | DecimalJsLike | number | string
    retail_price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    supplier_id: number
    product_barcode: string
    removed?: boolean | null
    created_at?: Date | string | null
    updated_on?: Date | string | null
    cart?: cartUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutInventoryInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutInventoryInput, productUncheckedCreateWithoutInventoryInput>
  }

  export type branchUpsertWithoutInventoryInput = {
    update: XOR<branchUpdateWithoutInventoryInput, branchUncheckedUpdateWithoutInventoryInput>
    create: XOR<branchCreateWithoutInventoryInput, branchUncheckedCreateWithoutInventoryInput>
    where?: branchWhereInput
  }

  export type branchUpdateToOneWithWhereWithoutInventoryInput = {
    where?: branchWhereInput
    data: XOR<branchUpdateWithoutInventoryInput, branchUncheckedUpdateWithoutInventoryInput>
  }

  export type branchUpdateWithoutInventoryInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    branch_city?: StringFieldUpdateOperationsInput | string
    branch_address?: StringFieldUpdateOperationsInput | string
    branch_phone?: StringFieldUpdateOperationsInput | string
    branch_email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: employeeUpdateManyWithoutBranchNestedInput
    sales_history?: sales_historyUpdateManyWithoutBranchNestedInput
  }

  export type branchUncheckedUpdateWithoutInventoryInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    branch_city?: StringFieldUpdateOperationsInput | string
    branch_address?: StringFieldUpdateOperationsInput | string
    branch_phone?: StringFieldUpdateOperationsInput | string
    branch_email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: employeeUncheckedUpdateManyWithoutBranchNestedInput
    sales_history?: sales_historyUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type productUpsertWithoutInventoryInput = {
    update: XOR<productUpdateWithoutInventoryInput, productUncheckedUpdateWithoutInventoryInput>
    create: XOR<productCreateWithoutInventoryInput, productUncheckedCreateWithoutInventoryInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutInventoryInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutInventoryInput, productUncheckedUpdateWithoutInventoryInput>
  }

  export type productUpdateWithoutInventoryInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    product_desc?: NullableStringFieldUpdateOperationsInput | string | null
    product_image?: productUpdateproduct_imageInput | string[]
    buying_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_barcode?: StringFieldUpdateOperationsInput | string
    removed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cart?: cartUpdateManyWithoutProductNestedInput
    category?: categoryUpdateOneRequiredWithoutProductNestedInput
    supplier?: supplierUpdateOneRequiredWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutInventoryInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    product_desc?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: IntFieldUpdateOperationsInput | number
    product_image?: productUpdateproduct_imageInput | string[]
    buying_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier_id?: IntFieldUpdateOperationsInput | number
    product_barcode?: StringFieldUpdateOperationsInput | string
    removed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cart?: cartUncheckedUpdateManyWithoutProductNestedInput
  }

  export type sales_historyCreateWithoutPayment_methodInput = {
    created_at?: Date | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    reference_id?: string | null
    product_count?: number | null
    cart?: cartCreateNestedManyWithoutSales_historyInput
    branch: branchCreateNestedOneWithoutSales_historyInput
    customer?: customerCreateNestedOneWithoutSales_historyInput
    employee: employeeCreateNestedOneWithoutSales_historyInput
  }

  export type sales_historyUncheckedCreateWithoutPayment_methodInput = {
    order_id?: number
    customer_id?: number | null
    cashier_id: number
    branch_id: string
    created_at?: Date | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    reference_id?: string | null
    product_count?: number | null
    cart?: cartUncheckedCreateNestedManyWithoutSales_historyInput
  }

  export type sales_historyCreateOrConnectWithoutPayment_methodInput = {
    where: sales_historyWhereUniqueInput
    create: XOR<sales_historyCreateWithoutPayment_methodInput, sales_historyUncheckedCreateWithoutPayment_methodInput>
  }

  export type sales_historyCreateManyPayment_methodInputEnvelope = {
    data: sales_historyCreateManyPayment_methodInput | sales_historyCreateManyPayment_methodInput[]
    skipDuplicates?: boolean
  }

  export type sales_historyUpsertWithWhereUniqueWithoutPayment_methodInput = {
    where: sales_historyWhereUniqueInput
    update: XOR<sales_historyUpdateWithoutPayment_methodInput, sales_historyUncheckedUpdateWithoutPayment_methodInput>
    create: XOR<sales_historyCreateWithoutPayment_methodInput, sales_historyUncheckedCreateWithoutPayment_methodInput>
  }

  export type sales_historyUpdateWithWhereUniqueWithoutPayment_methodInput = {
    where: sales_historyWhereUniqueInput
    data: XOR<sales_historyUpdateWithoutPayment_methodInput, sales_historyUncheckedUpdateWithoutPayment_methodInput>
  }

  export type sales_historyUpdateManyWithWhereWithoutPayment_methodInput = {
    where: sales_historyScalarWhereInput
    data: XOR<sales_historyUpdateManyMutationInput, sales_historyUncheckedUpdateManyWithoutPayment_methodInput>
  }

  export type cartCreateWithoutProductInput = {
    quantity: number
    sub_total_amount?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    sales_history?: sales_historyCreateNestedOneWithoutCartInput
  }

  export type cartUncheckedCreateWithoutProductInput = {
    cart_id?: number
    order_id?: number | null
    quantity: number
    sub_total_amount?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
  }

  export type cartCreateOrConnectWithoutProductInput = {
    where: cartWhereUniqueInput
    create: XOR<cartCreateWithoutProductInput, cartUncheckedCreateWithoutProductInput>
  }

  export type cartCreateManyProductInputEnvelope = {
    data: cartCreateManyProductInput | cartCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type inventoryCreateWithoutProductInput = {
    quantity?: number | null
    reorder_level?: number | null
    updated_on?: Date | string | null
    branch: branchCreateNestedOneWithoutInventoryInput
  }

  export type inventoryUncheckedCreateWithoutProductInput = {
    branch_id: string
    quantity?: number | null
    reorder_level?: number | null
    updated_on?: Date | string | null
  }

  export type inventoryCreateOrConnectWithoutProductInput = {
    where: inventoryWhereUniqueInput
    create: XOR<inventoryCreateWithoutProductInput, inventoryUncheckedCreateWithoutProductInput>
  }

  export type inventoryCreateManyProductInputEnvelope = {
    data: inventoryCreateManyProductInput | inventoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type categoryCreateWithoutProductInput = {
    category_name: string
  }

  export type categoryUncheckedCreateWithoutProductInput = {
    category_id?: number
    category_name: string
  }

  export type categoryCreateOrConnectWithoutProductInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutProductInput, categoryUncheckedCreateWithoutProductInput>
  }

  export type supplierCreateWithoutProductInput = {
    supplier_name: string
    supplier_email?: string | null
    supplier_phone: string
    supplier_address: string
  }

  export type supplierUncheckedCreateWithoutProductInput = {
    supplier_id?: number
    supplier_name: string
    supplier_email?: string | null
    supplier_phone: string
    supplier_address: string
  }

  export type supplierCreateOrConnectWithoutProductInput = {
    where: supplierWhereUniqueInput
    create: XOR<supplierCreateWithoutProductInput, supplierUncheckedCreateWithoutProductInput>
  }

  export type cartUpsertWithWhereUniqueWithoutProductInput = {
    where: cartWhereUniqueInput
    update: XOR<cartUpdateWithoutProductInput, cartUncheckedUpdateWithoutProductInput>
    create: XOR<cartCreateWithoutProductInput, cartUncheckedCreateWithoutProductInput>
  }

  export type cartUpdateWithWhereUniqueWithoutProductInput = {
    where: cartWhereUniqueInput
    data: XOR<cartUpdateWithoutProductInput, cartUncheckedUpdateWithoutProductInput>
  }

  export type cartUpdateManyWithWhereWithoutProductInput = {
    where: cartScalarWhereInput
    data: XOR<cartUpdateManyMutationInput, cartUncheckedUpdateManyWithoutProductInput>
  }

  export type cartScalarWhereInput = {
    AND?: cartScalarWhereInput | cartScalarWhereInput[]
    OR?: cartScalarWhereInput[]
    NOT?: cartScalarWhereInput | cartScalarWhereInput[]
    cart_id?: IntFilter<"cart"> | number
    order_id?: IntNullableFilter<"cart"> | number | null
    product_id?: UuidFilter<"cart"> | string
    quantity?: IntFilter<"cart"> | number
    sub_total_amount?: DecimalNullableFilter<"cart"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"cart"> | Date | string | null
  }

  export type inventoryUpsertWithWhereUniqueWithoutProductInput = {
    where: inventoryWhereUniqueInput
    update: XOR<inventoryUpdateWithoutProductInput, inventoryUncheckedUpdateWithoutProductInput>
    create: XOR<inventoryCreateWithoutProductInput, inventoryUncheckedCreateWithoutProductInput>
  }

  export type inventoryUpdateWithWhereUniqueWithoutProductInput = {
    where: inventoryWhereUniqueInput
    data: XOR<inventoryUpdateWithoutProductInput, inventoryUncheckedUpdateWithoutProductInput>
  }

  export type inventoryUpdateManyWithWhereWithoutProductInput = {
    where: inventoryScalarWhereInput
    data: XOR<inventoryUpdateManyMutationInput, inventoryUncheckedUpdateManyWithoutProductInput>
  }

  export type categoryUpsertWithoutProductInput = {
    update: XOR<categoryUpdateWithoutProductInput, categoryUncheckedUpdateWithoutProductInput>
    create: XOR<categoryCreateWithoutProductInput, categoryUncheckedCreateWithoutProductInput>
    where?: categoryWhereInput
  }

  export type categoryUpdateToOneWithWhereWithoutProductInput = {
    where?: categoryWhereInput
    data: XOR<categoryUpdateWithoutProductInput, categoryUncheckedUpdateWithoutProductInput>
  }

  export type categoryUpdateWithoutProductInput = {
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type categoryUncheckedUpdateWithoutProductInput = {
    category_id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type supplierUpsertWithoutProductInput = {
    update: XOR<supplierUpdateWithoutProductInput, supplierUncheckedUpdateWithoutProductInput>
    create: XOR<supplierCreateWithoutProductInput, supplierUncheckedCreateWithoutProductInput>
    where?: supplierWhereInput
  }

  export type supplierUpdateToOneWithWhereWithoutProductInput = {
    where?: supplierWhereInput
    data: XOR<supplierUpdateWithoutProductInput, supplierUncheckedUpdateWithoutProductInput>
  }

  export type supplierUpdateWithoutProductInput = {
    supplier_name?: StringFieldUpdateOperationsInput | string
    supplier_email?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_phone?: StringFieldUpdateOperationsInput | string
    supplier_address?: StringFieldUpdateOperationsInput | string
  }

  export type supplierUncheckedUpdateWithoutProductInput = {
    supplier_id?: IntFieldUpdateOperationsInput | number
    supplier_name?: StringFieldUpdateOperationsInput | string
    supplier_email?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_phone?: StringFieldUpdateOperationsInput | string
    supplier_address?: StringFieldUpdateOperationsInput | string
  }

  export type cartCreateWithoutSales_historyInput = {
    quantity: number
    sub_total_amount?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    product: productCreateNestedOneWithoutCartInput
  }

  export type cartUncheckedCreateWithoutSales_historyInput = {
    cart_id?: number
    product_id: string
    quantity: number
    sub_total_amount?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
  }

  export type cartCreateOrConnectWithoutSales_historyInput = {
    where: cartWhereUniqueInput
    create: XOR<cartCreateWithoutSales_historyInput, cartUncheckedCreateWithoutSales_historyInput>
  }

  export type cartCreateManySales_historyInputEnvelope = {
    data: cartCreateManySales_historyInput | cartCreateManySales_historyInput[]
    skipDuplicates?: boolean
  }

  export type branchCreateWithoutSales_historyInput = {
    branch_id?: string
    branch_city: string
    branch_address: string
    branch_phone: string
    branch_email: string
    created_at?: Date | string | null
    employee?: employeeCreateNestedManyWithoutBranchInput
    inventory?: inventoryCreateNestedManyWithoutBranchInput
  }

  export type branchUncheckedCreateWithoutSales_historyInput = {
    branch_id?: string
    branch_city: string
    branch_address: string
    branch_phone: string
    branch_email: string
    created_at?: Date | string | null
    employee?: employeeUncheckedCreateNestedManyWithoutBranchInput
    inventory?: inventoryUncheckedCreateNestedManyWithoutBranchInput
  }

  export type branchCreateOrConnectWithoutSales_historyInput = {
    where: branchWhereUniqueInput
    create: XOR<branchCreateWithoutSales_historyInput, branchUncheckedCreateWithoutSales_historyInput>
  }

  export type customerCreateWithoutSales_historyInput = {
    customer_name: string
    customer_email?: string | null
    customer_phone: string
    customer_address?: string | null
    visit_count?: number | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
  }

  export type customerUncheckedCreateWithoutSales_historyInput = {
    customer_id?: number
    customer_name: string
    customer_email?: string | null
    customer_phone: string
    customer_address?: string | null
    visit_count?: number | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
  }

  export type customerCreateOrConnectWithoutSales_historyInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutSales_historyInput, customerUncheckedCreateWithoutSales_historyInput>
  }

  export type employeeCreateWithoutSales_historyInput = {
    employee_name: string
    hired_date?: Date | string | null
    employee_email?: string | null
    employee_phone: string
    employee_image?: string | null
    branch_updated_on?: Date | string | null
    role_updated_on?: Date | string | null
    branch: branchCreateNestedOneWithoutEmployeeInput
    user_role: user_roleCreateNestedOneWithoutEmployeeInput
    user_credentials?: user_credentialsCreateNestedOneWithoutEmployeeInput
    working_hour?: working_hourCreateNestedManyWithoutEmployeeInput
    working_hour_marked_by?: working_hourCreateNestedManyWithoutMarked_byInput
  }

  export type employeeUncheckedCreateWithoutSales_historyInput = {
    employee_id?: number
    employee_name: string
    role_id: number
    hired_date?: Date | string | null
    employee_email?: string | null
    employee_phone: string
    branch_id: string
    employee_image?: string | null
    branch_updated_on?: Date | string | null
    role_updated_on?: Date | string | null
    user_credentials?: user_credentialsUncheckedCreateNestedOneWithoutEmployeeInput
    working_hour?: working_hourUncheckedCreateNestedManyWithoutEmployeeInput
    working_hour_marked_by?: working_hourUncheckedCreateNestedManyWithoutMarked_byInput
  }

  export type employeeCreateOrConnectWithoutSales_historyInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutSales_historyInput, employeeUncheckedCreateWithoutSales_historyInput>
  }

  export type payment_methodCreateWithoutSales_historyInput = {
    payment_method_name: string
  }

  export type payment_methodUncheckedCreateWithoutSales_historyInput = {
    payment_method_id?: number
    payment_method_name: string
  }

  export type payment_methodCreateOrConnectWithoutSales_historyInput = {
    where: payment_methodWhereUniqueInput
    create: XOR<payment_methodCreateWithoutSales_historyInput, payment_methodUncheckedCreateWithoutSales_historyInput>
  }

  export type cartUpsertWithWhereUniqueWithoutSales_historyInput = {
    where: cartWhereUniqueInput
    update: XOR<cartUpdateWithoutSales_historyInput, cartUncheckedUpdateWithoutSales_historyInput>
    create: XOR<cartCreateWithoutSales_historyInput, cartUncheckedCreateWithoutSales_historyInput>
  }

  export type cartUpdateWithWhereUniqueWithoutSales_historyInput = {
    where: cartWhereUniqueInput
    data: XOR<cartUpdateWithoutSales_historyInput, cartUncheckedUpdateWithoutSales_historyInput>
  }

  export type cartUpdateManyWithWhereWithoutSales_historyInput = {
    where: cartScalarWhereInput
    data: XOR<cartUpdateManyMutationInput, cartUncheckedUpdateManyWithoutSales_historyInput>
  }

  export type branchUpsertWithoutSales_historyInput = {
    update: XOR<branchUpdateWithoutSales_historyInput, branchUncheckedUpdateWithoutSales_historyInput>
    create: XOR<branchCreateWithoutSales_historyInput, branchUncheckedCreateWithoutSales_historyInput>
    where?: branchWhereInput
  }

  export type branchUpdateToOneWithWhereWithoutSales_historyInput = {
    where?: branchWhereInput
    data: XOR<branchUpdateWithoutSales_historyInput, branchUncheckedUpdateWithoutSales_historyInput>
  }

  export type branchUpdateWithoutSales_historyInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    branch_city?: StringFieldUpdateOperationsInput | string
    branch_address?: StringFieldUpdateOperationsInput | string
    branch_phone?: StringFieldUpdateOperationsInput | string
    branch_email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: employeeUpdateManyWithoutBranchNestedInput
    inventory?: inventoryUpdateManyWithoutBranchNestedInput
  }

  export type branchUncheckedUpdateWithoutSales_historyInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    branch_city?: StringFieldUpdateOperationsInput | string
    branch_address?: StringFieldUpdateOperationsInput | string
    branch_phone?: StringFieldUpdateOperationsInput | string
    branch_email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: employeeUncheckedUpdateManyWithoutBranchNestedInput
    inventory?: inventoryUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type customerUpsertWithoutSales_historyInput = {
    update: XOR<customerUpdateWithoutSales_historyInput, customerUncheckedUpdateWithoutSales_historyInput>
    create: XOR<customerCreateWithoutSales_historyInput, customerUncheckedCreateWithoutSales_historyInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutSales_historyInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutSales_historyInput, customerUncheckedUpdateWithoutSales_historyInput>
  }

  export type customerUpdateWithoutSales_historyInput = {
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    visit_count?: NullableIntFieldUpdateOperationsInput | number | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type customerUncheckedUpdateWithoutSales_historyInput = {
    customer_id?: IntFieldUpdateOperationsInput | number
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: StringFieldUpdateOperationsInput | string
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    visit_count?: NullableIntFieldUpdateOperationsInput | number | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employeeUpsertWithoutSales_historyInput = {
    update: XOR<employeeUpdateWithoutSales_historyInput, employeeUncheckedUpdateWithoutSales_historyInput>
    create: XOR<employeeCreateWithoutSales_historyInput, employeeUncheckedCreateWithoutSales_historyInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutSales_historyInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutSales_historyInput, employeeUncheckedUpdateWithoutSales_historyInput>
  }

  export type employeeUpdateWithoutSales_historyInput = {
    employee_name?: StringFieldUpdateOperationsInput | string
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: branchUpdateOneRequiredWithoutEmployeeNestedInput
    user_role?: user_roleUpdateOneRequiredWithoutEmployeeNestedInput
    user_credentials?: user_credentialsUpdateOneWithoutEmployeeNestedInput
    working_hour?: working_hourUpdateManyWithoutEmployeeNestedInput
    working_hour_marked_by?: working_hourUpdateManyWithoutMarked_byNestedInput
  }

  export type employeeUncheckedUpdateWithoutSales_historyInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_name?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    branch_id?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_credentials?: user_credentialsUncheckedUpdateOneWithoutEmployeeNestedInput
    working_hour?: working_hourUncheckedUpdateManyWithoutEmployeeNestedInput
    working_hour_marked_by?: working_hourUncheckedUpdateManyWithoutMarked_byNestedInput
  }

  export type payment_methodUpsertWithoutSales_historyInput = {
    update: XOR<payment_methodUpdateWithoutSales_historyInput, payment_methodUncheckedUpdateWithoutSales_historyInput>
    create: XOR<payment_methodCreateWithoutSales_historyInput, payment_methodUncheckedCreateWithoutSales_historyInput>
    where?: payment_methodWhereInput
  }

  export type payment_methodUpdateToOneWithWhereWithoutSales_historyInput = {
    where?: payment_methodWhereInput
    data: XOR<payment_methodUpdateWithoutSales_historyInput, payment_methodUncheckedUpdateWithoutSales_historyInput>
  }

  export type payment_methodUpdateWithoutSales_historyInput = {
    payment_method_name?: StringFieldUpdateOperationsInput | string
  }

  export type payment_methodUncheckedUpdateWithoutSales_historyInput = {
    payment_method_id?: IntFieldUpdateOperationsInput | number
    payment_method_name?: StringFieldUpdateOperationsInput | string
  }

  export type productCreateWithoutSupplierInput = {
    product_id?: string
    product_name: string
    product_desc?: string | null
    product_image?: productCreateproduct_imageInput | string[]
    buying_price: Decimal | DecimalJsLike | number | string
    retail_price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    product_barcode: string
    removed?: boolean | null
    created_at?: Date | string | null
    updated_on?: Date | string | null
    cart?: cartCreateNestedManyWithoutProductInput
    inventory?: inventoryCreateNestedManyWithoutProductInput
    category: categoryCreateNestedOneWithoutProductInput
  }

  export type productUncheckedCreateWithoutSupplierInput = {
    product_id?: string
    product_name: string
    product_desc?: string | null
    category_id: number
    product_image?: productCreateproduct_imageInput | string[]
    buying_price: Decimal | DecimalJsLike | number | string
    retail_price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    product_barcode: string
    removed?: boolean | null
    created_at?: Date | string | null
    updated_on?: Date | string | null
    cart?: cartUncheckedCreateNestedManyWithoutProductInput
    inventory?: inventoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutSupplierInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutSupplierInput, productUncheckedCreateWithoutSupplierInput>
  }

  export type productCreateManySupplierInputEnvelope = {
    data: productCreateManySupplierInput | productCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type productUpsertWithWhereUniqueWithoutSupplierInput = {
    where: productWhereUniqueInput
    update: XOR<productUpdateWithoutSupplierInput, productUncheckedUpdateWithoutSupplierInput>
    create: XOR<productCreateWithoutSupplierInput, productUncheckedCreateWithoutSupplierInput>
  }

  export type productUpdateWithWhereUniqueWithoutSupplierInput = {
    where: productWhereUniqueInput
    data: XOR<productUpdateWithoutSupplierInput, productUncheckedUpdateWithoutSupplierInput>
  }

  export type productUpdateManyWithWhereWithoutSupplierInput = {
    where: productScalarWhereInput
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyWithoutSupplierInput>
  }

  export type employeeCreateWithoutUser_credentialsInput = {
    employee_name: string
    hired_date?: Date | string | null
    employee_email?: string | null
    employee_phone: string
    employee_image?: string | null
    branch_updated_on?: Date | string | null
    role_updated_on?: Date | string | null
    branch: branchCreateNestedOneWithoutEmployeeInput
    user_role: user_roleCreateNestedOneWithoutEmployeeInput
    sales_history?: sales_historyCreateNestedManyWithoutEmployeeInput
    working_hour?: working_hourCreateNestedManyWithoutEmployeeInput
    working_hour_marked_by?: working_hourCreateNestedManyWithoutMarked_byInput
  }

  export type employeeUncheckedCreateWithoutUser_credentialsInput = {
    employee_id?: number
    employee_name: string
    role_id: number
    hired_date?: Date | string | null
    employee_email?: string | null
    employee_phone: string
    branch_id: string
    employee_image?: string | null
    branch_updated_on?: Date | string | null
    role_updated_on?: Date | string | null
    sales_history?: sales_historyUncheckedCreateNestedManyWithoutEmployeeInput
    working_hour?: working_hourUncheckedCreateNestedManyWithoutEmployeeInput
    working_hour_marked_by?: working_hourUncheckedCreateNestedManyWithoutMarked_byInput
  }

  export type employeeCreateOrConnectWithoutUser_credentialsInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutUser_credentialsInput, employeeUncheckedCreateWithoutUser_credentialsInput>
  }

  export type employeeUpsertWithoutUser_credentialsInput = {
    update: XOR<employeeUpdateWithoutUser_credentialsInput, employeeUncheckedUpdateWithoutUser_credentialsInput>
    create: XOR<employeeCreateWithoutUser_credentialsInput, employeeUncheckedCreateWithoutUser_credentialsInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutUser_credentialsInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutUser_credentialsInput, employeeUncheckedUpdateWithoutUser_credentialsInput>
  }

  export type employeeUpdateWithoutUser_credentialsInput = {
    employee_name?: StringFieldUpdateOperationsInput | string
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: branchUpdateOneRequiredWithoutEmployeeNestedInput
    user_role?: user_roleUpdateOneRequiredWithoutEmployeeNestedInput
    sales_history?: sales_historyUpdateManyWithoutEmployeeNestedInput
    working_hour?: working_hourUpdateManyWithoutEmployeeNestedInput
    working_hour_marked_by?: working_hourUpdateManyWithoutMarked_byNestedInput
  }

  export type employeeUncheckedUpdateWithoutUser_credentialsInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_name?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    branch_id?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales_history?: sales_historyUncheckedUpdateManyWithoutEmployeeNestedInput
    working_hour?: working_hourUncheckedUpdateManyWithoutEmployeeNestedInput
    working_hour_marked_by?: working_hourUncheckedUpdateManyWithoutMarked_byNestedInput
  }

  export type employeeCreateWithoutUser_roleInput = {
    employee_name: string
    hired_date?: Date | string | null
    employee_email?: string | null
    employee_phone: string
    employee_image?: string | null
    branch_updated_on?: Date | string | null
    role_updated_on?: Date | string | null
    branch: branchCreateNestedOneWithoutEmployeeInput
    sales_history?: sales_historyCreateNestedManyWithoutEmployeeInput
    user_credentials?: user_credentialsCreateNestedOneWithoutEmployeeInput
    working_hour?: working_hourCreateNestedManyWithoutEmployeeInput
    working_hour_marked_by?: working_hourCreateNestedManyWithoutMarked_byInput
  }

  export type employeeUncheckedCreateWithoutUser_roleInput = {
    employee_id?: number
    employee_name: string
    hired_date?: Date | string | null
    employee_email?: string | null
    employee_phone: string
    branch_id: string
    employee_image?: string | null
    branch_updated_on?: Date | string | null
    role_updated_on?: Date | string | null
    sales_history?: sales_historyUncheckedCreateNestedManyWithoutEmployeeInput
    user_credentials?: user_credentialsUncheckedCreateNestedOneWithoutEmployeeInput
    working_hour?: working_hourUncheckedCreateNestedManyWithoutEmployeeInput
    working_hour_marked_by?: working_hourUncheckedCreateNestedManyWithoutMarked_byInput
  }

  export type employeeCreateOrConnectWithoutUser_roleInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutUser_roleInput, employeeUncheckedCreateWithoutUser_roleInput>
  }

  export type employeeCreateManyUser_roleInputEnvelope = {
    data: employeeCreateManyUser_roleInput | employeeCreateManyUser_roleInput[]
    skipDuplicates?: boolean
  }

  export type employeeUpsertWithWhereUniqueWithoutUser_roleInput = {
    where: employeeWhereUniqueInput
    update: XOR<employeeUpdateWithoutUser_roleInput, employeeUncheckedUpdateWithoutUser_roleInput>
    create: XOR<employeeCreateWithoutUser_roleInput, employeeUncheckedCreateWithoutUser_roleInput>
  }

  export type employeeUpdateWithWhereUniqueWithoutUser_roleInput = {
    where: employeeWhereUniqueInput
    data: XOR<employeeUpdateWithoutUser_roleInput, employeeUncheckedUpdateWithoutUser_roleInput>
  }

  export type employeeUpdateManyWithWhereWithoutUser_roleInput = {
    where: employeeScalarWhereInput
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyWithoutUser_roleInput>
  }

  export type employeeCreateWithoutWorking_hourInput = {
    employee_name: string
    hired_date?: Date | string | null
    employee_email?: string | null
    employee_phone: string
    employee_image?: string | null
    branch_updated_on?: Date | string | null
    role_updated_on?: Date | string | null
    branch: branchCreateNestedOneWithoutEmployeeInput
    user_role: user_roleCreateNestedOneWithoutEmployeeInput
    sales_history?: sales_historyCreateNestedManyWithoutEmployeeInput
    user_credentials?: user_credentialsCreateNestedOneWithoutEmployeeInput
    working_hour_marked_by?: working_hourCreateNestedManyWithoutMarked_byInput
  }

  export type employeeUncheckedCreateWithoutWorking_hourInput = {
    employee_id?: number
    employee_name: string
    role_id: number
    hired_date?: Date | string | null
    employee_email?: string | null
    employee_phone: string
    branch_id: string
    employee_image?: string | null
    branch_updated_on?: Date | string | null
    role_updated_on?: Date | string | null
    sales_history?: sales_historyUncheckedCreateNestedManyWithoutEmployeeInput
    user_credentials?: user_credentialsUncheckedCreateNestedOneWithoutEmployeeInput
    working_hour_marked_by?: working_hourUncheckedCreateNestedManyWithoutMarked_byInput
  }

  export type employeeCreateOrConnectWithoutWorking_hourInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutWorking_hourInput, employeeUncheckedCreateWithoutWorking_hourInput>
  }

  export type employeeCreateWithoutWorking_hour_marked_byInput = {
    employee_name: string
    hired_date?: Date | string | null
    employee_email?: string | null
    employee_phone: string
    employee_image?: string | null
    branch_updated_on?: Date | string | null
    role_updated_on?: Date | string | null
    branch: branchCreateNestedOneWithoutEmployeeInput
    user_role: user_roleCreateNestedOneWithoutEmployeeInput
    sales_history?: sales_historyCreateNestedManyWithoutEmployeeInput
    user_credentials?: user_credentialsCreateNestedOneWithoutEmployeeInput
    working_hour?: working_hourCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutWorking_hour_marked_byInput = {
    employee_id?: number
    employee_name: string
    role_id: number
    hired_date?: Date | string | null
    employee_email?: string | null
    employee_phone: string
    branch_id: string
    employee_image?: string | null
    branch_updated_on?: Date | string | null
    role_updated_on?: Date | string | null
    sales_history?: sales_historyUncheckedCreateNestedManyWithoutEmployeeInput
    user_credentials?: user_credentialsUncheckedCreateNestedOneWithoutEmployeeInput
    working_hour?: working_hourUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutWorking_hour_marked_byInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutWorking_hour_marked_byInput, employeeUncheckedCreateWithoutWorking_hour_marked_byInput>
  }

  export type employeeUpsertWithoutWorking_hourInput = {
    update: XOR<employeeUpdateWithoutWorking_hourInput, employeeUncheckedUpdateWithoutWorking_hourInput>
    create: XOR<employeeCreateWithoutWorking_hourInput, employeeUncheckedCreateWithoutWorking_hourInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutWorking_hourInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutWorking_hourInput, employeeUncheckedUpdateWithoutWorking_hourInput>
  }

  export type employeeUpdateWithoutWorking_hourInput = {
    employee_name?: StringFieldUpdateOperationsInput | string
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: branchUpdateOneRequiredWithoutEmployeeNestedInput
    user_role?: user_roleUpdateOneRequiredWithoutEmployeeNestedInput
    sales_history?: sales_historyUpdateManyWithoutEmployeeNestedInput
    user_credentials?: user_credentialsUpdateOneWithoutEmployeeNestedInput
    working_hour_marked_by?: working_hourUpdateManyWithoutMarked_byNestedInput
  }

  export type employeeUncheckedUpdateWithoutWorking_hourInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_name?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    branch_id?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales_history?: sales_historyUncheckedUpdateManyWithoutEmployeeNestedInput
    user_credentials?: user_credentialsUncheckedUpdateOneWithoutEmployeeNestedInput
    working_hour_marked_by?: working_hourUncheckedUpdateManyWithoutMarked_byNestedInput
  }

  export type employeeUpsertWithoutWorking_hour_marked_byInput = {
    update: XOR<employeeUpdateWithoutWorking_hour_marked_byInput, employeeUncheckedUpdateWithoutWorking_hour_marked_byInput>
    create: XOR<employeeCreateWithoutWorking_hour_marked_byInput, employeeUncheckedCreateWithoutWorking_hour_marked_byInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutWorking_hour_marked_byInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutWorking_hour_marked_byInput, employeeUncheckedUpdateWithoutWorking_hour_marked_byInput>
  }

  export type employeeUpdateWithoutWorking_hour_marked_byInput = {
    employee_name?: StringFieldUpdateOperationsInput | string
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: branchUpdateOneRequiredWithoutEmployeeNestedInput
    user_role?: user_roleUpdateOneRequiredWithoutEmployeeNestedInput
    sales_history?: sales_historyUpdateManyWithoutEmployeeNestedInput
    user_credentials?: user_credentialsUpdateOneWithoutEmployeeNestedInput
    working_hour?: working_hourUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutWorking_hour_marked_byInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_name?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    branch_id?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales_history?: sales_historyUncheckedUpdateManyWithoutEmployeeNestedInput
    user_credentials?: user_credentialsUncheckedUpdateOneWithoutEmployeeNestedInput
    working_hour?: working_hourUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeCreateManyBranchInput = {
    employee_id?: number
    employee_name: string
    role_id: number
    hired_date?: Date | string | null
    employee_email?: string | null
    employee_phone: string
    employee_image?: string | null
    branch_updated_on?: Date | string | null
    role_updated_on?: Date | string | null
  }

  export type inventoryCreateManyBranchInput = {
    product_id: string
    quantity?: number | null
    reorder_level?: number | null
    updated_on?: Date | string | null
  }

  export type sales_historyCreateManyBranchInput = {
    order_id?: number
    customer_id?: number | null
    cashier_id: number
    created_at?: Date | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    payment_method_id?: number | null
    reference_id?: string | null
    product_count?: number | null
  }

  export type employeeUpdateWithoutBranchInput = {
    employee_name?: StringFieldUpdateOperationsInput | string
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_role?: user_roleUpdateOneRequiredWithoutEmployeeNestedInput
    sales_history?: sales_historyUpdateManyWithoutEmployeeNestedInput
    user_credentials?: user_credentialsUpdateOneWithoutEmployeeNestedInput
    working_hour?: working_hourUpdateManyWithoutEmployeeNestedInput
    working_hour_marked_by?: working_hourUpdateManyWithoutMarked_byNestedInput
  }

  export type employeeUncheckedUpdateWithoutBranchInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_name?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales_history?: sales_historyUncheckedUpdateManyWithoutEmployeeNestedInput
    user_credentials?: user_credentialsUncheckedUpdateOneWithoutEmployeeNestedInput
    working_hour?: working_hourUncheckedUpdateManyWithoutEmployeeNestedInput
    working_hour_marked_by?: working_hourUncheckedUpdateManyWithoutMarked_byNestedInput
  }

  export type employeeUncheckedUpdateManyWithoutBranchInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_name?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventoryUpdateWithoutBranchInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    reorder_level?: NullableIntFieldUpdateOperationsInput | number | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: productUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type inventoryUncheckedUpdateWithoutBranchInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    reorder_level?: NullableIntFieldUpdateOperationsInput | number | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventoryUncheckedUpdateManyWithoutBranchInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    reorder_level?: NullableIntFieldUpdateOperationsInput | number | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sales_historyUpdateWithoutBranchInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
    cart?: cartUpdateManyWithoutSales_historyNestedInput
    customer?: customerUpdateOneWithoutSales_historyNestedInput
    employee?: employeeUpdateOneRequiredWithoutSales_historyNestedInput
    payment_method?: payment_methodUpdateOneWithoutSales_historyNestedInput
  }

  export type sales_historyUncheckedUpdateWithoutBranchInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    cashier_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
    cart?: cartUncheckedUpdateManyWithoutSales_historyNestedInput
  }

  export type sales_historyUncheckedUpdateManyWithoutBranchInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    cashier_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type productCreateManyCategoryInput = {
    product_id?: string
    product_name: string
    product_desc?: string | null
    product_image?: productCreateproduct_imageInput | string[]
    buying_price: Decimal | DecimalJsLike | number | string
    retail_price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    supplier_id: number
    product_barcode: string
    removed?: boolean | null
    created_at?: Date | string | null
    updated_on?: Date | string | null
  }

  export type productUpdateWithoutCategoryInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    product_desc?: NullableStringFieldUpdateOperationsInput | string | null
    product_image?: productUpdateproduct_imageInput | string[]
    buying_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_barcode?: StringFieldUpdateOperationsInput | string
    removed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cart?: cartUpdateManyWithoutProductNestedInput
    inventory?: inventoryUpdateManyWithoutProductNestedInput
    supplier?: supplierUpdateOneRequiredWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutCategoryInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    product_desc?: NullableStringFieldUpdateOperationsInput | string | null
    product_image?: productUpdateproduct_imageInput | string[]
    buying_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier_id?: IntFieldUpdateOperationsInput | number
    product_barcode?: StringFieldUpdateOperationsInput | string
    removed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cart?: cartUncheckedUpdateManyWithoutProductNestedInput
    inventory?: inventoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateManyWithoutCategoryInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    product_desc?: NullableStringFieldUpdateOperationsInput | string | null
    product_image?: productUpdateproduct_imageInput | string[]
    buying_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier_id?: IntFieldUpdateOperationsInput | number
    product_barcode?: StringFieldUpdateOperationsInput | string
    removed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sales_historyCreateManyCustomerInput = {
    order_id?: number
    cashier_id: number
    branch_id: string
    created_at?: Date | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    payment_method_id?: number | null
    reference_id?: string | null
    product_count?: number | null
  }

  export type sales_historyUpdateWithoutCustomerInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
    cart?: cartUpdateManyWithoutSales_historyNestedInput
    branch?: branchUpdateOneRequiredWithoutSales_historyNestedInput
    employee?: employeeUpdateOneRequiredWithoutSales_historyNestedInput
    payment_method?: payment_methodUpdateOneWithoutSales_historyNestedInput
  }

  export type sales_historyUncheckedUpdateWithoutCustomerInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    cashier_id?: IntFieldUpdateOperationsInput | number
    branch_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
    cart?: cartUncheckedUpdateManyWithoutSales_historyNestedInput
  }

  export type sales_historyUncheckedUpdateManyWithoutCustomerInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    cashier_id?: IntFieldUpdateOperationsInput | number
    branch_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type sales_historyCreateManyEmployeeInput = {
    order_id?: number
    customer_id?: number | null
    branch_id: string
    created_at?: Date | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    payment_method_id?: number | null
    reference_id?: string | null
    product_count?: number | null
  }

  export type working_hourCreateManyEmployeeInput = {
    branch_id: string
    date: string
    shift_on: string
    shift_off: string
    updated_by: number
    present: boolean
    total_hours?: Decimal | DecimalJsLike | number | string | null
  }

  export type working_hourCreateManyMarked_byInput = {
    employee_id: number
    branch_id: string
    date: string
    shift_on: string
    shift_off: string
    present: boolean
    total_hours?: Decimal | DecimalJsLike | number | string | null
  }

  export type sales_historyUpdateWithoutEmployeeInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
    cart?: cartUpdateManyWithoutSales_historyNestedInput
    branch?: branchUpdateOneRequiredWithoutSales_historyNestedInput
    customer?: customerUpdateOneWithoutSales_historyNestedInput
    payment_method?: payment_methodUpdateOneWithoutSales_historyNestedInput
  }

  export type sales_historyUncheckedUpdateWithoutEmployeeInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    branch_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
    cart?: cartUncheckedUpdateManyWithoutSales_historyNestedInput
  }

  export type sales_historyUncheckedUpdateManyWithoutEmployeeInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    branch_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type working_hourUpdateWithoutEmployeeInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    shift_on?: StringFieldUpdateOperationsInput | string
    shift_off?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    total_hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marked_by?: employeeUpdateOneRequiredWithoutWorking_hour_marked_byNestedInput
  }

  export type working_hourUncheckedUpdateWithoutEmployeeInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    shift_on?: StringFieldUpdateOperationsInput | string
    shift_off?: StringFieldUpdateOperationsInput | string
    updated_by?: IntFieldUpdateOperationsInput | number
    present?: BoolFieldUpdateOperationsInput | boolean
    total_hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type working_hourUncheckedUpdateManyWithoutEmployeeInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    shift_on?: StringFieldUpdateOperationsInput | string
    shift_off?: StringFieldUpdateOperationsInput | string
    updated_by?: IntFieldUpdateOperationsInput | number
    present?: BoolFieldUpdateOperationsInput | boolean
    total_hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type working_hourUpdateWithoutMarked_byInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    shift_on?: StringFieldUpdateOperationsInput | string
    shift_off?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    total_hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employee?: employeeUpdateOneRequiredWithoutWorking_hourNestedInput
  }

  export type working_hourUncheckedUpdateWithoutMarked_byInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    branch_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    shift_on?: StringFieldUpdateOperationsInput | string
    shift_off?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    total_hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type working_hourUncheckedUpdateManyWithoutMarked_byInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    branch_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    shift_on?: StringFieldUpdateOperationsInput | string
    shift_off?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    total_hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type sales_historyCreateManyPayment_methodInput = {
    order_id?: number
    customer_id?: number | null
    cashier_id: number
    branch_id: string
    created_at?: Date | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    rewards_points?: Decimal | DecimalJsLike | number | string | null
    reference_id?: string | null
    product_count?: number | null
  }

  export type sales_historyUpdateWithoutPayment_methodInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
    cart?: cartUpdateManyWithoutSales_historyNestedInput
    branch?: branchUpdateOneRequiredWithoutSales_historyNestedInput
    customer?: customerUpdateOneWithoutSales_historyNestedInput
    employee?: employeeUpdateOneRequiredWithoutSales_historyNestedInput
  }

  export type sales_historyUncheckedUpdateWithoutPayment_methodInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    cashier_id?: IntFieldUpdateOperationsInput | number
    branch_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
    cart?: cartUncheckedUpdateManyWithoutSales_historyNestedInput
  }

  export type sales_historyUncheckedUpdateManyWithoutPayment_methodInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    cashier_id?: IntFieldUpdateOperationsInput | number
    branch_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rewards_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cartCreateManyProductInput = {
    cart_id?: number
    order_id?: number | null
    quantity: number
    sub_total_amount?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
  }

  export type inventoryCreateManyProductInput = {
    branch_id: string
    quantity?: number | null
    reorder_level?: number | null
    updated_on?: Date | string | null
  }

  export type cartUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    sub_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales_history?: sales_historyUpdateOneWithoutCartNestedInput
  }

  export type cartUncheckedUpdateWithoutProductInput = {
    cart_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    sub_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cartUncheckedUpdateManyWithoutProductInput = {
    cart_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    sub_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventoryUpdateWithoutProductInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    reorder_level?: NullableIntFieldUpdateOperationsInput | number | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: branchUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type inventoryUncheckedUpdateWithoutProductInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    reorder_level?: NullableIntFieldUpdateOperationsInput | number | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventoryUncheckedUpdateManyWithoutProductInput = {
    branch_id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    reorder_level?: NullableIntFieldUpdateOperationsInput | number | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cartCreateManySales_historyInput = {
    cart_id?: number
    product_id: string
    quantity: number
    sub_total_amount?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
  }

  export type cartUpdateWithoutSales_historyInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    sub_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: productUpdateOneRequiredWithoutCartNestedInput
  }

  export type cartUncheckedUpdateWithoutSales_historyInput = {
    cart_id?: IntFieldUpdateOperationsInput | number
    product_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sub_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cartUncheckedUpdateManyWithoutSales_historyInput = {
    cart_id?: IntFieldUpdateOperationsInput | number
    product_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sub_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type productCreateManySupplierInput = {
    product_id?: string
    product_name: string
    product_desc?: string | null
    category_id: number
    product_image?: productCreateproduct_imageInput | string[]
    buying_price: Decimal | DecimalJsLike | number | string
    retail_price: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    product_barcode: string
    removed?: boolean | null
    created_at?: Date | string | null
    updated_on?: Date | string | null
  }

  export type productUpdateWithoutSupplierInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    product_desc?: NullableStringFieldUpdateOperationsInput | string | null
    product_image?: productUpdateproduct_imageInput | string[]
    buying_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_barcode?: StringFieldUpdateOperationsInput | string
    removed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cart?: cartUpdateManyWithoutProductNestedInput
    inventory?: inventoryUpdateManyWithoutProductNestedInput
    category?: categoryUpdateOneRequiredWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutSupplierInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    product_desc?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: IntFieldUpdateOperationsInput | number
    product_image?: productUpdateproduct_imageInput | string[]
    buying_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_barcode?: StringFieldUpdateOperationsInput | string
    removed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cart?: cartUncheckedUpdateManyWithoutProductNestedInput
    inventory?: inventoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateManyWithoutSupplierInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    product_desc?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: IntFieldUpdateOperationsInput | number
    product_image?: productUpdateproduct_imageInput | string[]
    buying_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retail_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_barcode?: StringFieldUpdateOperationsInput | string
    removed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employeeCreateManyUser_roleInput = {
    employee_id?: number
    employee_name: string
    hired_date?: Date | string | null
    employee_email?: string | null
    employee_phone: string
    branch_id: string
    employee_image?: string | null
    branch_updated_on?: Date | string | null
    role_updated_on?: Date | string | null
  }

  export type employeeUpdateWithoutUser_roleInput = {
    employee_name?: StringFieldUpdateOperationsInput | string
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: branchUpdateOneRequiredWithoutEmployeeNestedInput
    sales_history?: sales_historyUpdateManyWithoutEmployeeNestedInput
    user_credentials?: user_credentialsUpdateOneWithoutEmployeeNestedInput
    working_hour?: working_hourUpdateManyWithoutEmployeeNestedInput
    working_hour_marked_by?: working_hourUpdateManyWithoutMarked_byNestedInput
  }

  export type employeeUncheckedUpdateWithoutUser_roleInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_name?: StringFieldUpdateOperationsInput | string
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    branch_id?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales_history?: sales_historyUncheckedUpdateManyWithoutEmployeeNestedInput
    user_credentials?: user_credentialsUncheckedUpdateOneWithoutEmployeeNestedInput
    working_hour?: working_hourUncheckedUpdateManyWithoutEmployeeNestedInput
    working_hour_marked_by?: working_hourUncheckedUpdateManyWithoutMarked_byNestedInput
  }

  export type employeeUncheckedUpdateManyWithoutUser_roleInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_name?: StringFieldUpdateOperationsInput | string
    hired_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_email?: NullableStringFieldUpdateOperationsInput | string | null
    employee_phone?: StringFieldUpdateOperationsInput | string
    branch_id?: StringFieldUpdateOperationsInput | string
    employee_image?: NullableStringFieldUpdateOperationsInput | string | null
    branch_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_updated_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}